<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>xzre: xzre.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">xzre
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">xzre.h File Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>XZ backdoor structures and functions.  
<a href="#details">More...</a></p>
<div class="textblock"><code>#include &lt;assert.h&gt;</code><br />
<code>#include &lt;stddef.h&gt;</code><br />
<code>#include &lt;stdint.h&gt;</code><br />
<code>#include &lt;lzma.h&gt;</code><br />
<code>#include &lt;openssl/dsa.h&gt;</code><br />
<code>#include &lt;openssl/ec.h&gt;</code><br />
<code>#include &lt;openssl/evp.h&gt;</code><br />
<code>#include &lt;openssl/rsa.h&gt;</code><br />
<code>#include &lt;elf.h&gt;</code><br />
<code>#include &lt;link.h&gt;</code><br />
<code>#include &quot;util.h&quot;</code><br />
</div>
<p><a href="xzre_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structelf__entry__ctx__t.html">elf_entry_ctx_t</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdasm__ctx__t.html">dasm_ctx_t</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structelf__info.html">elf_info</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlibc__imports__t.html">libc_imports_t</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structimported__funcs__t.html">imported_funcs_t</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structglobal__context__t.html">global_context_t</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbackdoor__shared__globals__t.html">backdoor_shared_globals_t</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbackdoor__setup__params__t.html">backdoor_setup_params_t</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structelf__handles__t.html">elf_handles_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">array of ELF handles  <a href="structelf__handles__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmain__elf__t.html">main_elf_t</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbackdoor__data__handle__t.html">backdoor_data_handle_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">data passed to functions that access the backdoor data  <a href="structbackdoor__data__handle__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbackdoor__data.html">backdoor_data</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">this structure is used to hold most of the backdoor information. it's used as a local variable in function <a class="el" href="xzre_8h.html#a229ee0bd4111363061bc4230bc1f6423">backdoor_setup</a>  <a href="structbackdoor__data.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbackdoor__shared__libraries__data__t.html">backdoor_shared_libraries_data_t</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">union &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="unionsecret__data__shift__cursor.html">secret_data_shift_cursor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">represents a shift register, which will shift a '1' into the secret data array. the low 3 bits represent the bit index, while the rest represents the byte index this is convenient, since a simple increment will increment the buffer position correctly  <a href="unionsecret__data__shift__cursor.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structkey__payload__hdr__t.html">key_payload_hdr_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">the payload header. also used as Chacha IV  <a href="structkey__payload__hdr__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structkey__payload__body__t.html">key_payload_body_t</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structkey__payload__t.html">key_payload_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">the contents of the RSA 'n' field  <a href="structkey__payload__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">union &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="unionu__cmd__arguments.html">u_cmd_arguments</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcmd__arguments__t.html">cmd_arguments_t</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structkey__ctx__t.html">key_ctx_t</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:ab00cb4aeb1653ec4164170204142f57e"><td class="memItemLeft" align="right" valign="top"><a id="ab00cb4aeb1653ec4164170204142f57e"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>UPTR</b>(x)&#160;&#160;&#160;((uptr)(x))</td></tr>
<tr class="separator:ab00cb4aeb1653ec4164170204142f57e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8b325ef6e0fe3c944a4847a4b1f96c9"><td class="memItemLeft" align="right" valign="top"><a id="ac8b325ef6e0fe3c944a4847a4b1f96c9"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>PTRADD</b>(a,  b)&#160;&#160;&#160;(UPTR(a) + UPTR(b))</td></tr>
<tr class="separator:ac8b325ef6e0fe3c944a4847a4b1f96c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39ad72fe76265f5bc6cc25a95b54e2cd"><td class="memItemLeft" align="right" valign="top"><a id="a39ad72fe76265f5bc6cc25a95b54e2cd"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>PTRDIFF</b>(a,  b)&#160;&#160;&#160;(UPTR(a) - UPTR(b))</td></tr>
<tr class="separator:a39ad72fe76265f5bc6cc25a95b54e2cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab57fd92ea606d15c3291e6bc0396c8af"><td class="memItemLeft" align="right" valign="top"><a id="ab57fd92ea606d15c3291e6bc0396c8af"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>BUILD_BUG_ON_ZERO</b>(e)&#160;&#160;&#160;((int)(sizeof(struct { int:(-!!(e)); })))</td></tr>
<tr class="separator:ab57fd92ea606d15c3291e6bc0396c8af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a450aeb766a9af43aa7f9faf1279c8c8f"><td class="memItemLeft" align="right" valign="top"><a id="a450aeb766a9af43aa7f9faf1279c8c8f"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>__same_type</b>(a,  b)&#160;&#160;&#160;__builtin_types_compatible_p(typeof(a), typeof(b))</td></tr>
<tr class="separator:a450aeb766a9af43aa7f9faf1279c8c8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f27072e3a686ca053626f23d2551457"><td class="memItemLeft" align="right" valign="top"><a id="a1f27072e3a686ca053626f23d2551457"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>__must_be_array</b>(a)&#160;&#160;&#160;BUILD_BUG_ON_ZERO(__same_type((a), &amp;(a)[0]))</td></tr>
<tr class="separator:a1f27072e3a686ca053626f23d2551457"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c7c6a69f690fc8d2abf0e385280a532"><td class="memItemLeft" align="right" valign="top"><a id="a3c7c6a69f690fc8d2abf0e385280a532"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>ARRAY_SIZE</b>(arr)&#160;&#160;&#160;(sizeof(arr) / sizeof((arr)[0]) + __must_be_array(arr))</td></tr>
<tr class="separator:a3c7c6a69f690fc8d2abf0e385280a532"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1974ecd89574bc861c90392b3d570dcb"><td class="memItemLeft" align="right" valign="top"><a id="a1974ecd89574bc861c90392b3d570dcb"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>XZDASM_OPC</b>(op)&#160;&#160;&#160;(op - 0x80)</td></tr>
<tr class="separator:a1974ecd89574bc861c90392b3d570dcb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5fd0af1f78d21cfc6f8c25bef9f14bc"><td class="memItemLeft" align="right" valign="top"><a id="aa5fd0af1f78d21cfc6f8c25bef9f14bc"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>assert_offset</b>(t,  f,  o)&#160;&#160;&#160;static_assert(offsetof(t, f) == o)</td></tr>
<tr class="separator:aa5fd0af1f78d21cfc6f8c25bef9f14bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f18db18bca26cafa95e9719de4a41ef"><td class="memItemLeft" align="right" valign="top"><a id="a2f18db18bca26cafa95e9719de4a41ef"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>CONCAT</b>(x,  y)&#160;&#160;&#160;x ## y</td></tr>
<tr class="separator:a2f18db18bca26cafa95e9719de4a41ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5af923cb05ed3e3ff98866990b79752d"><td class="memItemLeft" align="right" valign="top"><a id="a5af923cb05ed3e3ff98866990b79752d"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>EXPAND</b>(x,  y)&#160;&#160;&#160;CONCAT(x, y)</td></tr>
<tr class="separator:a5af923cb05ed3e3ff98866990b79752d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a353d32e52768fa413b9d1f381a201efa"><td class="memItemLeft" align="right" valign="top"><a id="a353d32e52768fa413b9d1f381a201efa"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>PADDING</b>(size)&#160;&#160;&#160;u8 EXPAND(_unknown, __LINE__)[size]</td></tr>
<tr class="separator:a353d32e52768fa413b9d1f381a201efa"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a92c50087ca0e64fa93fc59402c55f8ca"><td class="memItemLeft" align="right" valign="top"><a id="a92c50087ca0e64fa93fc59402c55f8ca"></a>
typedef uint8_t&#160;</td><td class="memItemRight" valign="bottom"><b>u8</b></td></tr>
<tr class="separator:a92c50087ca0e64fa93fc59402c55f8ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace9d960e74685e2cd84b36132dbbf8aa"><td class="memItemLeft" align="right" valign="top"><a id="ace9d960e74685e2cd84b36132dbbf8aa"></a>
typedef uint16_t&#160;</td><td class="memItemRight" valign="bottom"><b>u16</b></td></tr>
<tr class="separator:ace9d960e74685e2cd84b36132dbbf8aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afaa62991928fb9fb18ff0db62a040aba"><td class="memItemLeft" align="right" valign="top"><a id="afaa62991928fb9fb18ff0db62a040aba"></a>
typedef uint32_t&#160;</td><td class="memItemRight" valign="bottom"><b>u32</b></td></tr>
<tr class="separator:afaa62991928fb9fb18ff0db62a040aba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f7e2bcbb0b4c338f3c4f6c937cd4234"><td class="memItemLeft" align="right" valign="top"><a id="a3f7e2bcbb0b4c338f3c4f6c937cd4234"></a>
typedef uint64_t&#160;</td><td class="memItemRight" valign="bottom"><b>u64</b></td></tr>
<tr class="separator:a3f7e2bcbb0b4c338f3c4f6c937cd4234"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93a1409151dffdb2c15147214279817a"><td class="memItemLeft" align="right" valign="top"><a id="a93a1409151dffdb2c15147214279817a"></a>
typedef uintptr_t&#160;</td><td class="memItemRight" valign="bottom"><b>uptr</b></td></tr>
<tr class="separator:a93a1409151dffdb2c15147214279817a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a050c65e107f0c828f856a231f4b4e788"><td class="memItemLeft" align="right" valign="top"><a id="a050c65e107f0c828f856a231f4b4e788"></a>
typedef int&#160;</td><td class="memItemRight" valign="bottom"><b>BOOL</b></td></tr>
<tr class="separator:a050c65e107f0c828f856a231f4b4e788"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a958fbc6aa42d63f2a2fd296bf0e586e4"><td class="memItemLeft" align="right" valign="top"><a id="a958fbc6aa42d63f2a2fd296bf0e586e4"></a>
typedef struct <a class="el" href="structelf__info.html">elf_info</a>&#160;</td><td class="memItemRight" valign="bottom"><b>elf_info_t</b></td></tr>
<tr class="separator:a958fbc6aa42d63f2a2fd296bf0e586e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adecb5c6743212f467a1dcb1137b9a068"><td class="memItemLeft" align="right" valign="top"><a id="adecb5c6743212f467a1dcb1137b9a068"></a>
typedef int(*&#160;</td><td class="memItemRight" valign="bottom"><b>pfn_RSA_public_decrypt_t</b>) (int flen, unsigned char *from, unsigned char *to, RSA *rsa, int padding)</td></tr>
<tr class="separator:adecb5c6743212f467a1dcb1137b9a068"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9942af087add10a0724704291e65c8f0"><td class="memItemLeft" align="right" valign="top"><a id="a9942af087add10a0724704291e65c8f0"></a>
typedef int(*&#160;</td><td class="memItemRight" valign="bottom"><b>pfn_EVP_PKEY_set1_RSA_t</b>) (EVP_PKEY *pkey, struct rsa_st *key)</td></tr>
<tr class="separator:a9942af087add10a0724704291e65c8f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e48c0241cc79ff63678f8ea3245e89b"><td class="memItemLeft" align="right" valign="top"><a id="a5e48c0241cc79ff63678f8ea3245e89b"></a>
typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><b>pfn_RSA_get0_key_t</b>) (const RSA *r, const BIGNUM **n, const BIGNUM **e, const BIGNUM **d)</td></tr>
<tr class="separator:a5e48c0241cc79ff63678f8ea3245e89b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78a513f8570845832aaf68c928a5126a"><td class="memItemLeft" align="right" valign="top"><a id="a78a513f8570845832aaf68c928a5126a"></a>
typedef struct <a class="el" href="structbackdoor__data.html">backdoor_data</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xzre_8h.html#a78a513f8570845832aaf68c928a5126a">backdoor_data_t</a></td></tr>
<tr class="memdesc:a78a513f8570845832aaf68c928a5126a"><td class="mdescLeft">&#160;</td><td class="mdescRight">this structure is used to hold most of the backdoor information. it's used as a local variable in function <a class="el" href="xzre_8h.html#a229ee0bd4111363061bc4230bc1f6423">backdoor_setup</a> <br /></td></tr>
<tr class="separator:a78a513f8570845832aaf68c928a5126a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:a7a28d9f889f70e46106eb6e946183605"><td class="memItemLeft" align="right" valign="top"><a id="a7a28d9f889f70e46106eb6e946183605"></a>enum &#160;</td><td class="memItemRight" valign="bottom"><b>InstructionFlags</b> { <br />
&#160;&#160;<b>DF_LOCK</b> = 1
, <b>DF_ESEG</b> = 2
, <b>DF_OSIZE</b> = 4
, <b>DF_ASIZE</b> = 8
, <br />
&#160;&#160;<b>DF_REX</b> = 0x20
<br />
 }</td></tr>
<tr class="separator:a7a28d9f889f70e46106eb6e946183605"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8720669b781fc318e97d4ec37ae4997c"><td class="memItemLeft" align="right" valign="top"><a id="a8720669b781fc318e97d4ec37ae4997c"></a>enum &#160;</td><td class="memItemRight" valign="bottom"><b>ElfFlags</b> { <br />
&#160;&#160;<b>X_ELF_PLTREL</b> = 0x1
, <b>X_ELF_RELA</b> = 0x2
, <b>X_ELF_RELR</b> = 0x4
, <b>X_ELF_VERSYM</b> = 0x10
, <br />
&#160;&#160;<b>X_ELF_NOW</b> = 0x20
<br />
 }</td></tr>
<tr class="separator:a8720669b781fc318e97d4ec37ae4997c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a312257dd76472b76f479e15d180c4570"><td class="memItemLeft" align="right" valign="top"><a id="a312257dd76472b76f479e15d180c4570"></a>enum &#160;</td><td class="memItemRight" valign="bottom"><b>ModRm_Mod</b> { <b>MRM_I_REG</b>
, <b>MRM_I_DISP1</b>
, <b>MRM_I_DISP4</b>
, <b>MRM_D_REG</b>
 }</td></tr>
<tr class="separator:a312257dd76472b76f479e15d180c4570"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4d7fb9dcfda9656ed2c6aeaec3357be"><td class="memItemLeft" align="right" valign="top"><a id="af4d7fb9dcfda9656ed2c6aeaec3357be"></a>enum &#160;</td><td class="memItemRight" valign="bottom"><b>FuncFindType</b> { <b>FIND_ENDBR64</b>
, <b>FIND_NOP</b>
 }</td></tr>
<tr class="separator:af4d7fb9dcfda9656ed2c6aeaec3357be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ed7f6d009d35ae3bdb830a7bb1e0289"><td class="memItemLeft" align="right" valign="top"><a id="a3ed7f6d009d35ae3bdb830a7bb1e0289"></a>enum &#160;</td><td class="memItemRight" valign="bottom"><b>ElfId</b> { <b>X_ELF_MAIN</b> = 0
, <b>X_ELF_TMP</b> = 1
, <b>X_ELF_LIBC</b> = 2
, <b>X_ELF_LIBCRYPTO</b> = 3
 }</td></tr>
<tr class="separator:a3ed7f6d009d35ae3bdb830a7bb1e0289"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f8f63d8ae502ab76547c7b077cb067c"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xzre_8h.html#a5f8f63d8ae502ab76547c7b077cb067c">CommandFlags1</a> { <a class="el" href="xzre_8h.html#a5f8f63d8ae502ab76547c7b077cb067caef08c4a90ed6e0457d25d2c229bd375a">CMDF_8BYTES</a> = 1 &lt;&lt; 0
, <a class="el" href="xzre_8h.html#a5f8f63d8ae502ab76547c7b077cb067ca3616e0158ba9d48631cbdf2f9ff3eb7e">CMDF_SETLOGMASK</a> = 1 &lt;&lt; 2
 }</td></tr>
<tr class="separator:a5f8f63d8ae502ab76547c7b077cb067c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a408b28a8a0686c2ba0ede1e1b4208348"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xzre_8h.html#a408b28a8a0686c2ba0ede1e1b4208348">CommandFlags2</a> { <a class="el" href="xzre_8h.html#a408b28a8a0686c2ba0ede1e1b4208348ae700a962c8a6f21e7e4f6b1a461e0f71">CMDF_CONTINUATION</a> = 0x40
, <a class="el" href="xzre_8h.html#a408b28a8a0686c2ba0ede1e1b4208348a955fb3640af5b4d2852a6f2b869d9940">CMDF_PSELECT</a> = 0xC0
 }</td></tr>
<tr class="separator:a408b28a8a0686c2ba0ede1e1b4208348"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a07340e0f8ca9df744bc24ed6a6d2414c"><td class="memItemLeft" align="right" valign="top"><a id="a07340e0f8ca9df744bc24ed6a6d2414c"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>assert_offset</b> (<a class="el" href="structelf__entry__ctx__t.html">elf_entry_ctx_t</a>, symbol_ptr, 0)</td></tr>
<tr class="separator:a07340e0f8ca9df744bc24ed6a6d2414c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e543602ec7511d624f8f3f7b83a1ee8"><td class="memItemLeft" align="right" valign="top"><a id="a4e543602ec7511d624f8f3f7b83a1ee8"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>assert_offset</b> (<a class="el" href="structelf__entry__ctx__t.html">elf_entry_ctx_t</a>, got_ptr, 8)</td></tr>
<tr class="separator:a4e543602ec7511d624f8f3f7b83a1ee8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a238dfcc13519ae09f6ae9097691f41b9"><td class="memItemLeft" align="right" valign="top"><a id="a238dfcc13519ae09f6ae9097691f41b9"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>assert_offset</b> (<a class="el" href="structelf__entry__ctx__t.html">elf_entry_ctx_t</a>, return_address, 0x10)</td></tr>
<tr class="separator:a238dfcc13519ae09f6ae9097691f41b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66d3cb2e332731ec072e1462a85884df"><td class="memItemLeft" align="right" valign="top"><a id="a66d3cb2e332731ec072e1462a85884df"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>assert_offset</b> (<a class="el" href="structelf__entry__ctx__t.html">elf_entry_ctx_t</a>, cpuid_fn, 0x18)</td></tr>
<tr class="separator:a66d3cb2e332731ec072e1462a85884df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12b5b3403c2bfcb1ad17f541f7c58761"><td class="memItemLeft" align="right" valign="top"><a id="a12b5b3403c2bfcb1ad17f541f7c58761"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>assert_offset</b> (<a class="el" href="structelf__entry__ctx__t.html">elf_entry_ctx_t</a>, got_offset, 0x20)</td></tr>
<tr class="separator:a12b5b3403c2bfcb1ad17f541f7c58761"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade42a29d7f52bd39f36766d5af17978e"><td class="memItemLeft" align="right" valign="top"><a id="ade42a29d7f52bd39f36766d5af17978e"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>assert_offset</b> (<a class="el" href="structelf__entry__ctx__t.html">elf_entry_ctx_t</a>, caller_locals, 0x28)</td></tr>
<tr class="separator:ade42a29d7f52bd39f36766d5af17978e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3d792dd4e4c22999ebf91eb5648a1f4"><td class="memItemLeft" align="right" valign="top"><a id="ab3d792dd4e4c22999ebf91eb5648a1f4"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>assert_offset</b> (<a class="el" href="structdasm__ctx__t.html">dasm_ctx_t</a>, instruction, 0)</td></tr>
<tr class="separator:ab3d792dd4e4c22999ebf91eb5648a1f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1eb145f12c67a4be49fbaa6e3099992"><td class="memItemLeft" align="right" valign="top"><a id="ab1eb145f12c67a4be49fbaa6e3099992"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>assert_offset</b> (<a class="el" href="structdasm__ctx__t.html">dasm_ctx_t</a>, instruction_size, 8)</td></tr>
<tr class="separator:ab1eb145f12c67a4be49fbaa6e3099992"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79e1a7055dcef8979c2b23a65ba621bb"><td class="memItemLeft" align="right" valign="top"><a id="a79e1a7055dcef8979c2b23a65ba621bb"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>assert_offset</b> (<a class="el" href="structdasm__ctx__t.html">dasm_ctx_t</a>, flags, 0x10)</td></tr>
<tr class="separator:a79e1a7055dcef8979c2b23a65ba621bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8376690511def56513ab02a0fb86b164"><td class="memItemLeft" align="right" valign="top"><a id="a8376690511def56513ab02a0fb86b164"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>assert_offset</b> (<a class="el" href="structdasm__ctx__t.html">dasm_ctx_t</a>, flags2, 0x11)</td></tr>
<tr class="separator:a8376690511def56513ab02a0fb86b164"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a712dd0741cd0f1f19762f77f7ee7a6fc"><td class="memItemLeft" align="right" valign="top"><a id="a712dd0741cd0f1f19762f77f7ee7a6fc"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>assert_offset</b> (<a class="el" href="structdasm__ctx__t.html">dasm_ctx_t</a>, lock_byte, 0x14)</td></tr>
<tr class="separator:a712dd0741cd0f1f19762f77f7ee7a6fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa8191a6eeda3f4475fc1e5726a555cd"><td class="memItemLeft" align="right" valign="top"><a id="aaa8191a6eeda3f4475fc1e5726a555cd"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>assert_offset</b> (<a class="el" href="structdasm__ctx__t.html">dasm_ctx_t</a>, last_prefix, 0x16)</td></tr>
<tr class="separator:aaa8191a6eeda3f4475fc1e5726a555cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e9aff34162fef534b67b1607f2c0393"><td class="memItemLeft" align="right" valign="top"><a id="a1e9aff34162fef534b67b1607f2c0393"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>assert_offset</b> (<a class="el" href="structdasm__ctx__t.html">dasm_ctx_t</a>, rex_byte, 0x1B)</td></tr>
<tr class="separator:a1e9aff34162fef534b67b1607f2c0393"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd204ec028d99bfdd5f4442789667f60"><td class="memItemLeft" align="right" valign="top"><a id="acd204ec028d99bfdd5f4442789667f60"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>assert_offset</b> (<a class="el" href="structdasm__ctx__t.html">dasm_ctx_t</a>, modrm, 0x1C)</td></tr>
<tr class="separator:acd204ec028d99bfdd5f4442789667f60"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38fd5334ee76d701cb9ea5ed59edb20a"><td class="memItemLeft" align="right" valign="top"><a id="a38fd5334ee76d701cb9ea5ed59edb20a"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>assert_offset</b> (<a class="el" href="structdasm__ctx__t.html">dasm_ctx_t</a>, modrm_mod, 0x1D)</td></tr>
<tr class="separator:a38fd5334ee76d701cb9ea5ed59edb20a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6195f64611e4619231a2565746d292a"><td class="memItemLeft" align="right" valign="top"><a id="ac6195f64611e4619231a2565746d292a"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>assert_offset</b> (<a class="el" href="structdasm__ctx__t.html">dasm_ctx_t</a>, modrm_reg, 0x1E)</td></tr>
<tr class="separator:ac6195f64611e4619231a2565746d292a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2834cafae7e8ef36218929187afe78e5"><td class="memItemLeft" align="right" valign="top"><a id="a2834cafae7e8ef36218929187afe78e5"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>assert_offset</b> (<a class="el" href="structdasm__ctx__t.html">dasm_ctx_t</a>, modrm_rm, 0x1F)</td></tr>
<tr class="separator:a2834cafae7e8ef36218929187afe78e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92f57bfeaa7959d5aabe4d3de379448a"><td class="memItemLeft" align="right" valign="top"><a id="a92f57bfeaa7959d5aabe4d3de379448a"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>assert_offset</b> (<a class="el" href="structdasm__ctx__t.html">dasm_ctx_t</a>, opcode, 0x28)</td></tr>
<tr class="separator:a92f57bfeaa7959d5aabe4d3de379448a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3de11c95cc0fe9586d7125c3aa0a1ff2"><td class="memItemLeft" align="right" valign="top"><a id="a3de11c95cc0fe9586d7125c3aa0a1ff2"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>assert_offset</b> (<a class="el" href="structdasm__ctx__t.html">dasm_ctx_t</a>, mem_disp, 0x30)</td></tr>
<tr class="separator:a3de11c95cc0fe9586d7125c3aa0a1ff2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63e08f3940f8ef224f578ed0107e3651"><td class="memItemLeft" align="right" valign="top"><a id="a63e08f3940f8ef224f578ed0107e3651"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>assert_offset</b> (<a class="el" href="structdasm__ctx__t.html">dasm_ctx_t</a>, operand, 0x38)</td></tr>
<tr class="separator:a63e08f3940f8ef224f578ed0107e3651"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb3f2de7b7e5754295e89cbf02531246"><td class="memItemLeft" align="right" valign="top"><a id="abb3f2de7b7e5754295e89cbf02531246"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>assert_offset</b> (<a class="el" href="structdasm__ctx__t.html">dasm_ctx_t</a>, insn_offset, 0x50)</td></tr>
<tr class="separator:abb3f2de7b7e5754295e89cbf02531246"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5416f420fcca6102d1bd2f242c6af3bc"><td class="memItemLeft" align="right" valign="top"><a id="a5416f420fcca6102d1bd2f242c6af3bc"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>assert_offset</b> (<a class="el" href="structelf__info.html">elf_info_t</a>, elfbase, 0x0)</td></tr>
<tr class="separator:a5416f420fcca6102d1bd2f242c6af3bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab61bf638327c66988e78d20f8c93aa2a"><td class="memItemLeft" align="right" valign="top"><a id="ab61bf638327c66988e78d20f8c93aa2a"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>assert_offset</b> (<a class="el" href="structelf__info.html">elf_info_t</a>, first_vaddr, 0x8)</td></tr>
<tr class="separator:ab61bf638327c66988e78d20f8c93aa2a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4421b8b37fd7c599f6be0c195a56d792"><td class="memItemLeft" align="right" valign="top"><a id="a4421b8b37fd7c599f6be0c195a56d792"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>assert_offset</b> (<a class="el" href="structelf__info.html">elf_info_t</a>, phdrs, 0x10)</td></tr>
<tr class="separator:a4421b8b37fd7c599f6be0c195a56d792"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e34f0eff9b6da18356194d477baaf91"><td class="memItemLeft" align="right" valign="top"><a id="a2e34f0eff9b6da18356194d477baaf91"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>assert_offset</b> (<a class="el" href="structelf__info.html">elf_info_t</a>, e_phnum, 0x18)</td></tr>
<tr class="separator:a2e34f0eff9b6da18356194d477baaf91"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64f4220b000ba672c282eb0a305df6e5"><td class="memItemLeft" align="right" valign="top"><a id="a64f4220b000ba672c282eb0a305df6e5"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>assert_offset</b> (<a class="el" href="structelf__info.html">elf_info_t</a>, dyn, 0x20)</td></tr>
<tr class="separator:a64f4220b000ba672c282eb0a305df6e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2f6b3ca1019cccb9253cb29f4b3e5c1"><td class="memItemLeft" align="right" valign="top"><a id="ac2f6b3ca1019cccb9253cb29f4b3e5c1"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>assert_offset</b> (<a class="el" href="structelf__info.html">elf_info_t</a>, dyn_num_entries, 0x28)</td></tr>
<tr class="separator:ac2f6b3ca1019cccb9253cb29f4b3e5c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af538d756521ed0fc4a0f91ca0f6602d5"><td class="memItemLeft" align="right" valign="top"><a id="af538d756521ed0fc4a0f91ca0f6602d5"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>assert_offset</b> (<a class="el" href="structelf__info.html">elf_info_t</a>, strtab, 0x30)</td></tr>
<tr class="separator:af538d756521ed0fc4a0f91ca0f6602d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6468e4e51c4a23ba1324a87265abbde6"><td class="memItemLeft" align="right" valign="top"><a id="a6468e4e51c4a23ba1324a87265abbde6"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>assert_offset</b> (<a class="el" href="structelf__info.html">elf_info_t</a>, symtab, 0x38)</td></tr>
<tr class="separator:a6468e4e51c4a23ba1324a87265abbde6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0a81e057eb2ac23075ac7e4b87f3d08"><td class="memItemLeft" align="right" valign="top"><a id="ac0a81e057eb2ac23075ac7e4b87f3d08"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>assert_offset</b> (<a class="el" href="structelf__info.html">elf_info_t</a>, plt_relocs, 0x40)</td></tr>
<tr class="separator:ac0a81e057eb2ac23075ac7e4b87f3d08"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c7d54c9d562655bef4411005c91ce5d"><td class="memItemLeft" align="right" valign="top"><a id="a0c7d54c9d562655bef4411005c91ce5d"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>assert_offset</b> (<a class="el" href="structelf__info.html">elf_info_t</a>, plt_relocs_num, 0x48)</td></tr>
<tr class="separator:a0c7d54c9d562655bef4411005c91ce5d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2649eefdb981092a4966acff10794356"><td class="memItemLeft" align="right" valign="top"><a id="a2649eefdb981092a4966acff10794356"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>assert_offset</b> (<a class="el" href="structelf__info.html">elf_info_t</a>, gnurelro_found, 0x4C)</td></tr>
<tr class="separator:a2649eefdb981092a4966acff10794356"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a657018488217b8f085e4ad037df4428b"><td class="memItemLeft" align="right" valign="top"><a id="a657018488217b8f085e4ad037df4428b"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>assert_offset</b> (<a class="el" href="structelf__info.html">elf_info_t</a>, gnurelro_vaddr, 0x50)</td></tr>
<tr class="separator:a657018488217b8f085e4ad037df4428b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75da95cf5fb8a74215d3071e7c7e2147"><td class="memItemLeft" align="right" valign="top"><a id="a75da95cf5fb8a74215d3071e7c7e2147"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>assert_offset</b> (<a class="el" href="structelf__info.html">elf_info_t</a>, gnurelro_memsize, 0x58)</td></tr>
<tr class="separator:a75da95cf5fb8a74215d3071e7c7e2147"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada2bbbbb7ab077575dd68942d8b2326b"><td class="memItemLeft" align="right" valign="top"><a id="ada2bbbbb7ab077575dd68942d8b2326b"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>assert_offset</b> (<a class="el" href="structelf__info.html">elf_info_t</a>, verdef, 0x60)</td></tr>
<tr class="separator:ada2bbbbb7ab077575dd68942d8b2326b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ab7213d4e836b9835119a782d04aca0"><td class="memItemLeft" align="right" valign="top"><a id="a5ab7213d4e836b9835119a782d04aca0"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>assert_offset</b> (<a class="el" href="structelf__info.html">elf_info_t</a>, verdef_num, 0x68)</td></tr>
<tr class="separator:a5ab7213d4e836b9835119a782d04aca0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d8aa794e4dab4d1187810d207e7e577"><td class="memItemLeft" align="right" valign="top"><a id="a9d8aa794e4dab4d1187810d207e7e577"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>assert_offset</b> (<a class="el" href="structelf__info.html">elf_info_t</a>, versym, 0x70)</td></tr>
<tr class="separator:a9d8aa794e4dab4d1187810d207e7e577"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad19909828dce0a610b733166946cdbdb"><td class="memItemLeft" align="right" valign="top"><a id="ad19909828dce0a610b733166946cdbdb"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>assert_offset</b> (<a class="el" href="structelf__info.html">elf_info_t</a>, rela_relocs, 0x78)</td></tr>
<tr class="separator:ad19909828dce0a610b733166946cdbdb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ff5c8a654bc51cc441e1d9089604933"><td class="memItemLeft" align="right" valign="top"><a id="a8ff5c8a654bc51cc441e1d9089604933"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>assert_offset</b> (<a class="el" href="structelf__info.html">elf_info_t</a>, rela_relocs_num, 0x80)</td></tr>
<tr class="separator:a8ff5c8a654bc51cc441e1d9089604933"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1d9bebf57801454f1008a16df5cab08"><td class="memItemLeft" align="right" valign="top"><a id="ab1d9bebf57801454f1008a16df5cab08"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>assert_offset</b> (<a class="el" href="structelf__info.html">elf_info_t</a>, relr_relocs, 0x88)</td></tr>
<tr class="separator:ab1d9bebf57801454f1008a16df5cab08"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2c9ae3b66e5bf8e842d53e80ce09e3d"><td class="memItemLeft" align="right" valign="top"><a id="aa2c9ae3b66e5bf8e842d53e80ce09e3d"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>assert_offset</b> (<a class="el" href="structelf__info.html">elf_info_t</a>, relr_relocs_num, 0x90)</td></tr>
<tr class="separator:aa2c9ae3b66e5bf8e842d53e80ce09e3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9fc38efd72107eade4c9671f6518c36d"><td class="memItemLeft" align="right" valign="top"><a id="a9fc38efd72107eade4c9671f6518c36d"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>assert_offset</b> (<a class="el" href="structelf__info.html">elf_info_t</a>, code_segment_start, 0x98)</td></tr>
<tr class="separator:a9fc38efd72107eade4c9671f6518c36d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb0937aa24d26b1d0ff613762ed91b4f"><td class="memItemLeft" align="right" valign="top"><a id="adb0937aa24d26b1d0ff613762ed91b4f"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>assert_offset</b> (<a class="el" href="structelf__info.html">elf_info_t</a>, code_segment_size, 0xA0)</td></tr>
<tr class="separator:adb0937aa24d26b1d0ff613762ed91b4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad454efb2e2e28c7efd261a691d1248a1"><td class="memItemLeft" align="right" valign="top"><a id="ad454efb2e2e28c7efd261a691d1248a1"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>assert_offset</b> (<a class="el" href="structelf__info.html">elf_info_t</a>, flags, 0xD0)</td></tr>
<tr class="separator:ad454efb2e2e28c7efd261a691d1248a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a040344add144ce988d0be2ae515ddf7b"><td class="memItemLeft" align="right" valign="top"><a id="a040344add144ce988d0be2ae515ddf7b"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>assert_offset</b> (<a class="el" href="structelf__info.html">elf_info_t</a>, gnu_hash_nbuckets, 0xd8)</td></tr>
<tr class="separator:a040344add144ce988d0be2ae515ddf7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae30d2c21ea86fb45f43bed0226bfd3a0"><td class="memItemLeft" align="right" valign="top"><a id="ae30d2c21ea86fb45f43bed0226bfd3a0"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>assert_offset</b> (<a class="el" href="structelf__info.html">elf_info_t</a>, gnu_hash_last_bloom, 0xdc)</td></tr>
<tr class="separator:ae30d2c21ea86fb45f43bed0226bfd3a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d95d2a44dc4ce9586cbfdf0ee27a103"><td class="memItemLeft" align="right" valign="top"><a id="a8d95d2a44dc4ce9586cbfdf0ee27a103"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>assert_offset</b> (<a class="el" href="structelf__info.html">elf_info_t</a>, gnu_hash_bloom_shift, 0xe0)</td></tr>
<tr class="separator:a8d95d2a44dc4ce9586cbfdf0ee27a103"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b6b4eeccbfa4914e8ea44d25257a925"><td class="memItemLeft" align="right" valign="top"><a id="a6b6b4eeccbfa4914e8ea44d25257a925"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>assert_offset</b> (<a class="el" href="structelf__info.html">elf_info_t</a>, gnu_hash_bloom, 0xe8)</td></tr>
<tr class="separator:a6b6b4eeccbfa4914e8ea44d25257a925"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50cc50a23e084b091c63a9fb46e2b580"><td class="memItemLeft" align="right" valign="top"><a id="a50cc50a23e084b091c63a9fb46e2b580"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>assert_offset</b> (<a class="el" href="structelf__info.html">elf_info_t</a>, gnu_hash_buckets, 0xf0)</td></tr>
<tr class="separator:a50cc50a23e084b091c63a9fb46e2b580"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad70f3e20103f9ba5f86dd4797fee165"><td class="memItemLeft" align="right" valign="top"><a id="aad70f3e20103f9ba5f86dd4797fee165"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>assert_offset</b> (<a class="el" href="structelf__info.html">elf_info_t</a>, gnu_hash_chain, 0xf8)</td></tr>
<tr class="separator:aad70f3e20103f9ba5f86dd4797fee165"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00860c16277f603a88e90ee7bdb4dcbb"><td class="memItemLeft" align="right" valign="top"><a id="a00860c16277f603a88e90ee7bdb4dcbb"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>assert_offset</b> (<a class="el" href="structlibc__imports__t.html">libc_imports_t</a>, resolved_imports_count, 0)</td></tr>
<tr class="separator:a00860c16277f603a88e90ee7bdb4dcbb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34bd5c6bf55d8e7275d0c0985b2e5573"><td class="memItemLeft" align="right" valign="top"><a id="a34bd5c6bf55d8e7275d0c0985b2e5573"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>assert_offset</b> (<a class="el" href="structlibc__imports__t.html">libc_imports_t</a>, malloc_usable_size, 8)</td></tr>
<tr class="separator:a34bd5c6bf55d8e7275d0c0985b2e5573"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71d6db47afe1c90489009655cab2fe50"><td class="memItemLeft" align="right" valign="top"><a id="a71d6db47afe1c90489009655cab2fe50"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>assert_offset</b> (<a class="el" href="structlibc__imports__t.html">libc_imports_t</a>, getuid, 0x10)</td></tr>
<tr class="separator:a71d6db47afe1c90489009655cab2fe50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aadb7b4f780e25591e202345fe5ce778c"><td class="memItemLeft" align="right" valign="top"><a id="aadb7b4f780e25591e202345fe5ce778c"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>assert_offset</b> (<a class="el" href="structlibc__imports__t.html">libc_imports_t</a>, exit, 0x18)</td></tr>
<tr class="separator:aadb7b4f780e25591e202345fe5ce778c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af14b1d92dcf9e13f15019a5794d50f95"><td class="memItemLeft" align="right" valign="top"><a id="af14b1d92dcf9e13f15019a5794d50f95"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>assert_offset</b> (<a class="el" href="structlibc__imports__t.html">libc_imports_t</a>, setresgid, 0x20)</td></tr>
<tr class="separator:af14b1d92dcf9e13f15019a5794d50f95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a690308f78d17f696eadab775d1748e9c"><td class="memItemLeft" align="right" valign="top"><a id="a690308f78d17f696eadab775d1748e9c"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>assert_offset</b> (<a class="el" href="structlibc__imports__t.html">libc_imports_t</a>, setresuid, 0x28)</td></tr>
<tr class="separator:a690308f78d17f696eadab775d1748e9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08578979bc50e6fc12121a85a1b55ba4"><td class="memItemLeft" align="right" valign="top"><a id="a08578979bc50e6fc12121a85a1b55ba4"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>assert_offset</b> (<a class="el" href="structlibc__imports__t.html">libc_imports_t</a>, system, 0x30)</td></tr>
<tr class="separator:a08578979bc50e6fc12121a85a1b55ba4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa32ec892ff21e9a696d1c844617d148e"><td class="memItemLeft" align="right" valign="top"><a id="aa32ec892ff21e9a696d1c844617d148e"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>assert_offset</b> (<a class="el" href="structlibc__imports__t.html">libc_imports_t</a>, write, 0x38)</td></tr>
<tr class="separator:aa32ec892ff21e9a696d1c844617d148e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94c39588627205dda1307dfd7eb91943"><td class="memItemLeft" align="right" valign="top"><a id="a94c39588627205dda1307dfd7eb91943"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>assert_offset</b> (<a class="el" href="structlibc__imports__t.html">libc_imports_t</a>, pselect, 0x40)</td></tr>
<tr class="separator:a94c39588627205dda1307dfd7eb91943"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a375d718f3973cd7c34e9f8d85230640a"><td class="memItemLeft" align="right" valign="top"><a id="a375d718f3973cd7c34e9f8d85230640a"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>assert_offset</b> (<a class="el" href="structlibc__imports__t.html">libc_imports_t</a>, read, 0x48)</td></tr>
<tr class="separator:a375d718f3973cd7c34e9f8d85230640a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9b20107be7daf5be86fa76b96e891b5"><td class="memItemLeft" align="right" valign="top"><a id="ab9b20107be7daf5be86fa76b96e891b5"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>assert_offset</b> (<a class="el" href="structlibc__imports__t.html">libc_imports_t</a>, __errno_location, 0x50)</td></tr>
<tr class="separator:ab9b20107be7daf5be86fa76b96e891b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab72ad74e5b5db370d8f763c5d27a54c9"><td class="memItemLeft" align="right" valign="top"><a id="ab72ad74e5b5db370d8f763c5d27a54c9"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>assert_offset</b> (<a class="el" href="structlibc__imports__t.html">libc_imports_t</a>, setlogmask, 0x58)</td></tr>
<tr class="separator:ab72ad74e5b5db370d8f763c5d27a54c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5851616bcf3585a4d63255e27d4b9080"><td class="memItemLeft" align="right" valign="top"><a id="a5851616bcf3585a4d63255e27d4b9080"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>assert_offset</b> (<a class="el" href="structlibc__imports__t.html">libc_imports_t</a>, shutdown, 0x60)</td></tr>
<tr class="separator:a5851616bcf3585a4d63255e27d4b9080"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4c84e3eaafa66db192ff467575c07ef"><td class="memItemLeft" align="right" valign="top"><a id="ac4c84e3eaafa66db192ff467575c07ef"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>assert_offset</b> (<a class="el" href="structimported__funcs__t.html">imported_funcs_t</a>, RSA_public_decrypt, 0)</td></tr>
<tr class="separator:ac4c84e3eaafa66db192ff467575c07ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06fbb87ece293673ae049e3d17a927fc"><td class="memItemLeft" align="right" valign="top"><a id="a06fbb87ece293673ae049e3d17a927fc"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>assert_offset</b> (<a class="el" href="structimported__funcs__t.html">imported_funcs_t</a>, EVP_PKEY_set1_RSA, 8)</td></tr>
<tr class="separator:a06fbb87ece293673ae049e3d17a927fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a686404ffefa47e862382092121bfc0b8"><td class="memItemLeft" align="right" valign="top"><a id="a686404ffefa47e862382092121bfc0b8"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>assert_offset</b> (<a class="el" href="structimported__funcs__t.html">imported_funcs_t</a>, RSA_get0_key_null, 0x10)</td></tr>
<tr class="separator:a686404ffefa47e862382092121bfc0b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab32e42958ca639e3cd3531f33de364d6"><td class="memItemLeft" align="right" valign="top"><a id="ab32e42958ca639e3cd3531f33de364d6"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>assert_offset</b> (<a class="el" href="structimported__funcs__t.html">imported_funcs_t</a>, RSA_public_decrypt_hook_ptr, 0x18)</td></tr>
<tr class="separator:ab32e42958ca639e3cd3531f33de364d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2e8419e269c6bb46e2a56b4a8edd095"><td class="memItemLeft" align="right" valign="top"><a id="ad2e8419e269c6bb46e2a56b4a8edd095"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>assert_offset</b> (<a class="el" href="structimported__funcs__t.html">imported_funcs_t</a>, EVP_PKEY_set1_RSA_hook_ptr, 0x20)</td></tr>
<tr class="separator:ad2e8419e269c6bb46e2a56b4a8edd095"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace0690caf6175f8d4904a46555b26a84"><td class="memItemLeft" align="right" valign="top"><a id="ace0690caf6175f8d4904a46555b26a84"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>assert_offset</b> (<a class="el" href="structimported__funcs__t.html">imported_funcs_t</a>, RSA_get0_key_hook_ptr, 0x28)</td></tr>
<tr class="separator:ace0690caf6175f8d4904a46555b26a84"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4204d0c32a5ccc55ab1a298d689bd4fb"><td class="memItemLeft" align="right" valign="top"><a id="a4204d0c32a5ccc55ab1a298d689bd4fb"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>assert_offset</b> (<a class="el" href="structimported__funcs__t.html">imported_funcs_t</a>, DSA_get0_pqg, 0x30)</td></tr>
<tr class="separator:a4204d0c32a5ccc55ab1a298d689bd4fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18134fb834fe77fbdaf346f5a6ee7549"><td class="memItemLeft" align="right" valign="top"><a id="a18134fb834fe77fbdaf346f5a6ee7549"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>assert_offset</b> (<a class="el" href="structimported__funcs__t.html">imported_funcs_t</a>, DSA_get0_pub_key, 0x38)</td></tr>
<tr class="separator:a18134fb834fe77fbdaf346f5a6ee7549"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afdd75328fa4e18f7af8e5dc822202c2b"><td class="memItemLeft" align="right" valign="top"><a id="afdd75328fa4e18f7af8e5dc822202c2b"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>assert_offset</b> (<a class="el" href="structimported__funcs__t.html">imported_funcs_t</a>, EC_POINT_point2oct, 0x40)</td></tr>
<tr class="separator:afdd75328fa4e18f7af8e5dc822202c2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4d189f2eb6f3a41e228a04ac75d3aae"><td class="memItemLeft" align="right" valign="top"><a id="ae4d189f2eb6f3a41e228a04ac75d3aae"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>assert_offset</b> (<a class="el" href="structimported__funcs__t.html">imported_funcs_t</a>, EC_KEY_get0_public_key, 0x48)</td></tr>
<tr class="separator:ae4d189f2eb6f3a41e228a04ac75d3aae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd622db624e55e081943d52838837d1f"><td class="memItemLeft" align="right" valign="top"><a id="acd622db624e55e081943d52838837d1f"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>assert_offset</b> (<a class="el" href="structimported__funcs__t.html">imported_funcs_t</a>, EC_KEY_get0_group, 0x50)</td></tr>
<tr class="separator:acd622db624e55e081943d52838837d1f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7615b76f76544beead47d64ef914859"><td class="memItemLeft" align="right" valign="top"><a id="ad7615b76f76544beead47d64ef914859"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>assert_offset</b> (<a class="el" href="structimported__funcs__t.html">imported_funcs_t</a>, EVP_sha256, 0x58)</td></tr>
<tr class="separator:ad7615b76f76544beead47d64ef914859"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaace0e1ca20316181905ff732b2eb0fb"><td class="memItemLeft" align="right" valign="top"><a id="aaace0e1ca20316181905ff732b2eb0fb"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>assert_offset</b> (<a class="el" href="structimported__funcs__t.html">imported_funcs_t</a>, RSA_get0_key, 0x60)</td></tr>
<tr class="separator:aaace0e1ca20316181905ff732b2eb0fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a306bfc6358dc48cff25f872096df386b"><td class="memItemLeft" align="right" valign="top"><a id="a306bfc6358dc48cff25f872096df386b"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>assert_offset</b> (<a class="el" href="structimported__funcs__t.html">imported_funcs_t</a>, BN_num_bits, 0x68)</td></tr>
<tr class="separator:a306bfc6358dc48cff25f872096df386b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf26f8ccf05b46f22b7fc7aa077905a9"><td class="memItemLeft" align="right" valign="top"><a id="aaf26f8ccf05b46f22b7fc7aa077905a9"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>assert_offset</b> (<a class="el" href="structimported__funcs__t.html">imported_funcs_t</a>, EVP_PKEY_new_raw_public_key, 0x70)</td></tr>
<tr class="separator:aaf26f8ccf05b46f22b7fc7aa077905a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ea84ab683be032441e50ffd0bb60e27"><td class="memItemLeft" align="right" valign="top"><a id="a9ea84ab683be032441e50ffd0bb60e27"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>assert_offset</b> (<a class="el" href="structimported__funcs__t.html">imported_funcs_t</a>, EVP_MD_CTX_new, 0x78)</td></tr>
<tr class="separator:a9ea84ab683be032441e50ffd0bb60e27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5361f6713ec771fba1da20f1527ee09"><td class="memItemLeft" align="right" valign="top"><a id="ae5361f6713ec771fba1da20f1527ee09"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>assert_offset</b> (<a class="el" href="structimported__funcs__t.html">imported_funcs_t</a>, EVP_DigestVerifyInit, 0x80)</td></tr>
<tr class="separator:ae5361f6713ec771fba1da20f1527ee09"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6743e3f7daa3de9aab69f5ef92ecc47d"><td class="memItemLeft" align="right" valign="top"><a id="a6743e3f7daa3de9aab69f5ef92ecc47d"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>assert_offset</b> (<a class="el" href="structimported__funcs__t.html">imported_funcs_t</a>, EVP_DigestVerify, 0x88)</td></tr>
<tr class="separator:a6743e3f7daa3de9aab69f5ef92ecc47d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5271d6a4cbc70ff5992fd17319b3cd95"><td class="memItemLeft" align="right" valign="top"><a id="a5271d6a4cbc70ff5992fd17319b3cd95"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>assert_offset</b> (<a class="el" href="structimported__funcs__t.html">imported_funcs_t</a>, EVP_MD_CTX_free, 0x90)</td></tr>
<tr class="separator:a5271d6a4cbc70ff5992fd17319b3cd95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45f8a45c924a6f26f414d592033c9f7d"><td class="memItemLeft" align="right" valign="top"><a id="a45f8a45c924a6f26f414d592033c9f7d"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>assert_offset</b> (<a class="el" href="structimported__funcs__t.html">imported_funcs_t</a>, EVP_PKEY_free, 0x98)</td></tr>
<tr class="separator:a45f8a45c924a6f26f414d592033c9f7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acdd8da9c279377f086aab6d205f6844b"><td class="memItemLeft" align="right" valign="top"><a id="acdd8da9c279377f086aab6d205f6844b"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>assert_offset</b> (<a class="el" href="structimported__funcs__t.html">imported_funcs_t</a>, EVP_CIPHER_CTX_new, 0xA0)</td></tr>
<tr class="separator:acdd8da9c279377f086aab6d205f6844b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afdb57a8f4309629adfcf8c842c503176"><td class="memItemLeft" align="right" valign="top"><a id="afdb57a8f4309629adfcf8c842c503176"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>assert_offset</b> (<a class="el" href="structimported__funcs__t.html">imported_funcs_t</a>, EVP_DecryptInit_ex, 0xA8)</td></tr>
<tr class="separator:afdb57a8f4309629adfcf8c842c503176"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3a1887614fbee1696da57f7dc6e9864"><td class="memItemLeft" align="right" valign="top"><a id="af3a1887614fbee1696da57f7dc6e9864"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>assert_offset</b> (<a class="el" href="structimported__funcs__t.html">imported_funcs_t</a>, EVP_DecryptUpdate, 0xB0)</td></tr>
<tr class="separator:af3a1887614fbee1696da57f7dc6e9864"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa02f27ad8051268be4613cb9827eb1b3"><td class="memItemLeft" align="right" valign="top"><a id="aa02f27ad8051268be4613cb9827eb1b3"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>assert_offset</b> (<a class="el" href="structimported__funcs__t.html">imported_funcs_t</a>, EVP_DecryptFinal_ex, 0xB8)</td></tr>
<tr class="separator:aa02f27ad8051268be4613cb9827eb1b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac475dcc45734903683471084caad0918"><td class="memItemLeft" align="right" valign="top"><a id="ac475dcc45734903683471084caad0918"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>assert_offset</b> (<a class="el" href="structimported__funcs__t.html">imported_funcs_t</a>, EVP_CIPHER_CTX_free, 0xC0)</td></tr>
<tr class="separator:ac475dcc45734903683471084caad0918"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae63f8a206a3f03f7fb8260f6fe606438"><td class="memItemLeft" align="right" valign="top"><a id="ae63f8a206a3f03f7fb8260f6fe606438"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>assert_offset</b> (<a class="el" href="structimported__funcs__t.html">imported_funcs_t</a>, EVP_chacha20, 0xC8)</td></tr>
<tr class="separator:ae63f8a206a3f03f7fb8260f6fe606438"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03e5c50bca35bcc32f1859f2b2ddb7b8"><td class="memItemLeft" align="right" valign="top"><a id="a03e5c50bca35bcc32f1859f2b2ddb7b8"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>assert_offset</b> (<a class="el" href="structimported__funcs__t.html">imported_funcs_t</a>, RSA_new, 0xD0)</td></tr>
<tr class="separator:a03e5c50bca35bcc32f1859f2b2ddb7b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adce484d36308b289a9cc3bd3a5a2dda4"><td class="memItemLeft" align="right" valign="top"><a id="adce484d36308b289a9cc3bd3a5a2dda4"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>assert_offset</b> (<a class="el" href="structimported__funcs__t.html">imported_funcs_t</a>, BN_dup, 0xD8)</td></tr>
<tr class="separator:adce484d36308b289a9cc3bd3a5a2dda4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8ea945c77605c2b6012b055955b4d38"><td class="memItemLeft" align="right" valign="top"><a id="ab8ea945c77605c2b6012b055955b4d38"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>assert_offset</b> (<a class="el" href="structimported__funcs__t.html">imported_funcs_t</a>, BN_bin2bn, 0xE0)</td></tr>
<tr class="separator:ab8ea945c77605c2b6012b055955b4d38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afce8c57269083c142ddd7aea866aa6b6"><td class="memItemLeft" align="right" valign="top"><a id="afce8c57269083c142ddd7aea866aa6b6"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>assert_offset</b> (<a class="el" href="structimported__funcs__t.html">imported_funcs_t</a>, RSA_set0_key, 0xE8)</td></tr>
<tr class="separator:afce8c57269083c142ddd7aea866aa6b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3cb21a334291a1a16d2f547aecadfb6f"><td class="memItemLeft" align="right" valign="top"><a id="a3cb21a334291a1a16d2f547aecadfb6f"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>assert_offset</b> (<a class="el" href="structimported__funcs__t.html">imported_funcs_t</a>, EVP_Digest, 0xF0)</td></tr>
<tr class="separator:a3cb21a334291a1a16d2f547aecadfb6f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a204c89138b3b25ccaf4aeb753c6834c7"><td class="memItemLeft" align="right" valign="top"><a id="a204c89138b3b25ccaf4aeb753c6834c7"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>assert_offset</b> (<a class="el" href="structimported__funcs__t.html">imported_funcs_t</a>, RSA_sign, 0xF8)</td></tr>
<tr class="separator:a204c89138b3b25ccaf4aeb753c6834c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a643d3a39abf92b1a5c4cd89435ab51ab"><td class="memItemLeft" align="right" valign="top"><a id="a643d3a39abf92b1a5c4cd89435ab51ab"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>assert_offset</b> (<a class="el" href="structimported__funcs__t.html">imported_funcs_t</a>, BN_bn2bin, 0x100)</td></tr>
<tr class="separator:a643d3a39abf92b1a5c4cd89435ab51ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a455ac4af3eb01b235e75df7043c6384f"><td class="memItemLeft" align="right" valign="top"><a id="a455ac4af3eb01b235e75df7043c6384f"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>assert_offset</b> (<a class="el" href="structimported__funcs__t.html">imported_funcs_t</a>, RSA_free, 0x108)</td></tr>
<tr class="separator:a455ac4af3eb01b235e75df7043c6384f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9f62e7e684eb1f90580b1f9c7e39d9e"><td class="memItemLeft" align="right" valign="top"><a id="ae9f62e7e684eb1f90580b1f9c7e39d9e"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>assert_offset</b> (<a class="el" href="structimported__funcs__t.html">imported_funcs_t</a>, BN_free, 0x110)</td></tr>
<tr class="separator:ae9f62e7e684eb1f90580b1f9c7e39d9e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a0e5e1a42b92c15477e0774d1662508"><td class="memItemLeft" align="right" valign="top"><a id="a9a0e5e1a42b92c15477e0774d1662508"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>assert_offset</b> (<a class="el" href="structimported__funcs__t.html">imported_funcs_t</a>, libc, 0x118)</td></tr>
<tr class="separator:a9a0e5e1a42b92c15477e0774d1662508"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41f247c8e977b275256102c5a2af23c7"><td class="memItemLeft" align="right" valign="top"><a id="a41f247c8e977b275256102c5a2af23c7"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>assert_offset</b> (<a class="el" href="structimported__funcs__t.html">imported_funcs_t</a>, resolved_imports_count, 0x120)</td></tr>
<tr class="separator:a41f247c8e977b275256102c5a2af23c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7fbe48e7391456ba960d7f26714f170"><td class="memItemLeft" align="right" valign="top"><a id="ac7fbe48e7391456ba960d7f26714f170"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>assert_offset</b> (<a class="el" href="structglobal__context__t.html">global_context_t</a>, imported_funcs, 8)</td></tr>
<tr class="separator:ac7fbe48e7391456ba960d7f26714f170"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a35276b37081a5e5f24ca625ede71186e"><td class="memItemLeft" align="right" valign="top"><a id="a35276b37081a5e5f24ca625ede71186e"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>assert_offset</b> (<a class="el" href="structglobal__context__t.html">global_context_t</a>, code_range_start, 0x80)</td></tr>
<tr class="separator:a35276b37081a5e5f24ca625ede71186e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf8465f266dbb363e75fa20d4263bee4"><td class="memItemLeft" align="right" valign="top"><a id="aaf8465f266dbb363e75fa20d4263bee4"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>assert_offset</b> (<a class="el" href="structglobal__context__t.html">global_context_t</a>, code_range_end, 0x88)</td></tr>
<tr class="separator:aaf8465f266dbb363e75fa20d4263bee4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f40ad493b38891682b414abc9b70a32"><td class="memItemLeft" align="right" valign="top"><a id="a8f40ad493b38891682b414abc9b70a32"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>assert_offset</b> (<a class="el" href="structglobal__context__t.html">global_context_t</a>, secret_data, 0x108)</td></tr>
<tr class="separator:a8f40ad493b38891682b414abc9b70a32"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a376bd60de48e9143dd59f2cb1a121619"><td class="memItemLeft" align="right" valign="top"><a id="a376bd60de48e9143dd59f2cb1a121619"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>assert_offset</b> (<a class="el" href="structglobal__context__t.html">global_context_t</a>, shift_operations, 0x141)</td></tr>
<tr class="separator:a376bd60de48e9143dd59f2cb1a121619"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a07630769c5ccfca03eafcb006f3f62"><td class="memItemLeft" align="right" valign="top"><a id="a5a07630769c5ccfca03eafcb006f3f62"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>assert_offset</b> (<a class="el" href="structglobal__context__t.html">global_context_t</a>, reg2reg_instructions_count, 0x160)</td></tr>
<tr class="separator:a5a07630769c5ccfca03eafcb006f3f62"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94c3fff16b704f8d529ce25798073af3"><td class="memItemLeft" align="right" valign="top"><a id="a94c3fff16b704f8d529ce25798073af3"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>assert_offset</b> (<a class="el" href="structbackdoor__shared__globals__t.html">backdoor_shared_globals_t</a>, globals, 0x10)</td></tr>
<tr class="separator:a94c3fff16b704f8d529ce25798073af3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b25e68f96fef005e33fd1f93f1cce3d"><td class="memItemLeft" align="right" valign="top"><a id="a0b25e68f96fef005e33fd1f93f1cce3d"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>assert_offset</b> (<a class="el" href="structbackdoor__setup__params__t.html">backdoor_setup_params_t</a>, shared, 0x8)</td></tr>
<tr class="separator:a0b25e68f96fef005e33fd1f93f1cce3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5a94e874d57beee98370fe9e1cefd58"><td class="memItemLeft" align="right" valign="top"><a id="af5a94e874d57beee98370fe9e1cefd58"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>assert_offset</b> (<a class="el" href="structbackdoor__setup__params__t.html">backdoor_setup_params_t</a>, entry_ctx, 0x80)</td></tr>
<tr class="separator:af5a94e874d57beee98370fe9e1cefd58"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30e2e711133deaa2b255596805d91662"><td class="memItemLeft" align="right" valign="top"><a id="a30e2e711133deaa2b255596805d91662"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>assert_offset</b> (<a class="el" href="structelf__handles__t.html">elf_handles_t</a>, main, 0x0)</td></tr>
<tr class="separator:a30e2e711133deaa2b255596805d91662"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8bb70352cf385e9810f5ff5b9c0481d"><td class="memItemLeft" align="right" valign="top"><a id="ad8bb70352cf385e9810f5ff5b9c0481d"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>assert_offset</b> (<a class="el" href="structelf__handles__t.html">elf_handles_t</a>, tmp, 0x8)</td></tr>
<tr class="separator:ad8bb70352cf385e9810f5ff5b9c0481d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a467cc299537ef2bec41b423f4b000e66"><td class="memItemLeft" align="right" valign="top"><a id="a467cc299537ef2bec41b423f4b000e66"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>assert_offset</b> (<a class="el" href="structelf__handles__t.html">elf_handles_t</a>, libc, 0x10)</td></tr>
<tr class="separator:a467cc299537ef2bec41b423f4b000e66"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1748b47f26bba5c9b40fd8bb0adb8c29"><td class="memItemLeft" align="right" valign="top"><a id="a1748b47f26bba5c9b40fd8bb0adb8c29"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>assert_offset</b> (<a class="el" href="structelf__handles__t.html">elf_handles_t</a>, liblzma, 0x18)</td></tr>
<tr class="separator:a1748b47f26bba5c9b40fd8bb0adb8c29"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a476822f11a5fce8a08806fb9e27324e1"><td class="memItemLeft" align="right" valign="top"><a id="a476822f11a5fce8a08806fb9e27324e1"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>assert_offset</b> (<a class="el" href="structelf__handles__t.html">elf_handles_t</a>, libcrypto, 0x20)</td></tr>
<tr class="separator:a476822f11a5fce8a08806fb9e27324e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60ea39255e696332df00acc923138bee"><td class="memItemLeft" align="right" valign="top"><a id="a60ea39255e696332df00acc923138bee"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>assert_offset</b> (<a class="el" href="structmain__elf__t.html">main_elf_t</a>, handles, 0x0)</td></tr>
<tr class="separator:a60ea39255e696332df00acc923138bee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4765d0eff67808d1e72ff1ee2cffa2a0"><td class="memItemLeft" align="right" valign="top"><a id="a4765d0eff67808d1e72ff1ee2cffa2a0"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>assert_offset</b> (<a class="el" href="structmain__elf__t.html">main_elf_t</a>, ehdr, 0x8)</td></tr>
<tr class="separator:a4765d0eff67808d1e72ff1ee2cffa2a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70b389c91d58960da1dfd8b0b8780848"><td class="memItemLeft" align="right" valign="top"><a id="a70b389c91d58960da1dfd8b0b8780848"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>assert_offset</b> (<a class="el" href="structmain__elf__t.html">main_elf_t</a>, __libc_stack_end, 0x10)</td></tr>
<tr class="separator:a70b389c91d58960da1dfd8b0b8780848"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad240914d1020a2c6cc4af519cf312dd9"><td class="memItemLeft" align="right" valign="top"><a id="ad240914d1020a2c6cc4af519cf312dd9"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>assert_offset</b> (<a class="el" href="structbackdoor__data__handle__t.html">backdoor_data_handle_t</a>, data, 0x0)</td></tr>
<tr class="separator:ad240914d1020a2c6cc4af519cf312dd9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2934e1fc87c15302b153d4cc15f1f9c4"><td class="memItemLeft" align="right" valign="top"><a id="a2934e1fc87c15302b153d4cc15f1f9c4"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>assert_offset</b> (<a class="el" href="structbackdoor__data__handle__t.html">backdoor_data_handle_t</a>, elf_handles, 0x8)</td></tr>
<tr class="separator:a2934e1fc87c15302b153d4cc15f1f9c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5e80dc08a6eb1a376410812c0feae22"><td class="memItemLeft" align="right" valign="top"><a id="ac5e80dc08a6eb1a376410812c0feae22"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>assert_offset</b> (<a class="el" href="xzre_8h.html#a78a513f8570845832aaf68c928a5126a">backdoor_data_t</a>, main_map, 0)</td></tr>
<tr class="separator:ac5e80dc08a6eb1a376410812c0feae22"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91a1c0dbea4cf420e221a0cb2bf403e1"><td class="memItemLeft" align="right" valign="top"><a id="a91a1c0dbea4cf420e221a0cb2bf403e1"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>assert_offset</b> (<a class="el" href="xzre_8h.html#a78a513f8570845832aaf68c928a5126a">backdoor_data_t</a>, dynamic_linker_map, 0x8)</td></tr>
<tr class="separator:a91a1c0dbea4cf420e221a0cb2bf403e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10bb954aaa78f8845d4a31edf731f313"><td class="memItemLeft" align="right" valign="top"><a id="a10bb954aaa78f8845d4a31edf731f313"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>assert_offset</b> (<a class="el" href="xzre_8h.html#a78a513f8570845832aaf68c928a5126a">backdoor_data_t</a>, liblzma_map, 0x10)</td></tr>
<tr class="separator:a10bb954aaa78f8845d4a31edf731f313"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c3046b4e3cd83077072f55f42b0e7ab"><td class="memItemLeft" align="right" valign="top"><a id="a3c3046b4e3cd83077072f55f42b0e7ab"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>assert_offset</b> (<a class="el" href="xzre_8h.html#a78a513f8570845832aaf68c928a5126a">backdoor_data_t</a>, libcrypto_map, 0x18)</td></tr>
<tr class="separator:a3c3046b4e3cd83077072f55f42b0e7ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90849f8226700f9fc9e8806123002876"><td class="memItemLeft" align="right" valign="top"><a id="a90849f8226700f9fc9e8806123002876"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>assert_offset</b> (<a class="el" href="xzre_8h.html#a78a513f8570845832aaf68c928a5126a">backdoor_data_t</a>, libsystemd_map, 0x20)</td></tr>
<tr class="separator:a90849f8226700f9fc9e8806123002876"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb27d2315a6c64e5a8273d08e9073f13"><td class="memItemLeft" align="right" valign="top"><a id="abb27d2315a6c64e5a8273d08e9073f13"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>assert_offset</b> (<a class="el" href="xzre_8h.html#a78a513f8570845832aaf68c928a5126a">backdoor_data_t</a>, libc_map, 0x28)</td></tr>
<tr class="separator:abb27d2315a6c64e5a8273d08e9073f13"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa496711b73ba8684046af04317b727cf"><td class="memItemLeft" align="right" valign="top"><a id="aa496711b73ba8684046af04317b727cf"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>assert_offset</b> (<a class="el" href="xzre_8h.html#a78a513f8570845832aaf68c928a5126a">backdoor_data_t</a>, elf_handles, 0x30)</td></tr>
<tr class="separator:aa496711b73ba8684046af04317b727cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a4053fbbd30f6e722605f9b0a686ec4"><td class="memItemLeft" align="right" valign="top"><a id="a2a4053fbbd30f6e722605f9b0a686ec4"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>assert_offset</b> (<a class="el" href="xzre_8h.html#a78a513f8570845832aaf68c928a5126a">backdoor_data_t</a>, libc_info, 0x268)</td></tr>
<tr class="separator:a2a4053fbbd30f6e722605f9b0a686ec4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3fe5fa8a2a464ceeef178a3bfee0febb"><td class="memItemLeft" align="right" valign="top"><a id="a3fe5fa8a2a464ceeef178a3bfee0febb"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>assert_offset</b> (<a class="el" href="xzre_8h.html#a78a513f8570845832aaf68c928a5126a">backdoor_data_t</a>, libcrypto_info, 0x468)</td></tr>
<tr class="separator:a3fe5fa8a2a464ceeef178a3bfee0febb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acea945d4b1eb08cb3d5826e9bf5418ab"><td class="memItemLeft" align="right" valign="top"><a id="acea945d4b1eb08cb3d5826e9bf5418ab"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>assert_offset</b> (<a class="el" href="xzre_8h.html#a78a513f8570845832aaf68c928a5126a">backdoor_data_t</a>, libc_imports, 0x568)</td></tr>
<tr class="separator:acea945d4b1eb08cb3d5826e9bf5418ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80339b10786531e6061e8087045c92d9"><td class="memItemLeft" align="right" valign="top"><a id="a80339b10786531e6061e8087045c92d9"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>assert_offset</b> (<a class="el" href="xzre_8h.html#a78a513f8570845832aaf68c928a5126a">backdoor_data_t</a>, import_resolver, 0x950)</td></tr>
<tr class="separator:a80339b10786531e6061e8087045c92d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac82e17a1f10bad69aa9680e89dae0fc1"><td class="memItemLeft" align="right" valign="top"><a id="ac82e17a1f10bad69aa9680e89dae0fc1"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>assert_offset</b> (<a class="el" href="structbackdoor__shared__libraries__data__t.html">backdoor_shared_libraries_data_t</a>, data, 0x0)</td></tr>
<tr class="separator:ac82e17a1f10bad69aa9680e89dae0fc1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d720c43910725c7479e25f27f309da4"><td class="memItemLeft" align="right" valign="top"><a id="a3d720c43910725c7479e25f27f309da4"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>assert_offset</b> (<a class="el" href="structbackdoor__shared__libraries__data__t.html">backdoor_shared_libraries_data_t</a>, elf_handles, 0x8)</td></tr>
<tr class="separator:a3d720c43910725c7479e25f27f309da4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34d6bb837cbfeecfa2815803c70bd290"><td class="memItemLeft" align="right" valign="top"><a id="a34d6bb837cbfeecfa2815803c70bd290"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>assert_offset</b> (<a class="el" href="structbackdoor__shared__libraries__data__t.html">backdoor_shared_libraries_data_t</a>, RSA_public_decrypt, 0x10)</td></tr>
<tr class="separator:a34d6bb837cbfeecfa2815803c70bd290"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8242c405857d0bcbaba2584ecfc36858"><td class="memItemLeft" align="right" valign="top"><a id="a8242c405857d0bcbaba2584ecfc36858"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>assert_offset</b> (<a class="el" href="structbackdoor__shared__libraries__data__t.html">backdoor_shared_libraries_data_t</a>, EVP_PKEY_set1_RSA, 0x18)</td></tr>
<tr class="separator:a8242c405857d0bcbaba2584ecfc36858"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3837d5df8a084f4d375e090453b5f561"><td class="memItemLeft" align="right" valign="top"><a id="a3837d5df8a084f4d375e090453b5f561"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>assert_offset</b> (<a class="el" href="structbackdoor__shared__libraries__data__t.html">backdoor_shared_libraries_data_t</a>, RSA_get0_key, 0x20)</td></tr>
<tr class="separator:a3837d5df8a084f4d375e090453b5f561"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1451f92c8f0cf7451ffdb8dfcd799742"><td class="memItemLeft" align="right" valign="top"><a id="a1451f92c8f0cf7451ffdb8dfcd799742"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>assert_offset</b> (<a class="el" href="structbackdoor__shared__libraries__data__t.html">backdoor_shared_libraries_data_t</a>, libc_imports, 0x30)</td></tr>
<tr class="separator:a1451f92c8f0cf7451ffdb8dfcd799742"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa970c4ef889a63da65319360b6b6a320"><td class="memItemLeft" align="right" valign="top"><a id="aa970c4ef889a63da65319360b6b6a320"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>assert_offset</b> (<a class="el" href="structcmd__arguments__t.html">cmd_arguments_t</a>, flags1, 0)</td></tr>
<tr class="separator:aa970c4ef889a63da65319360b6b6a320"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa105d857f1825e66aefd1bd84435b0fe"><td class="memItemLeft" align="right" valign="top"><a id="aa105d857f1825e66aefd1bd84435b0fe"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>assert_offset</b> (<a class="el" href="structcmd__arguments__t.html">cmd_arguments_t</a>, flags2, 1)</td></tr>
<tr class="separator:aa105d857f1825e66aefd1bd84435b0fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d71b89283fd8e1451188363f58a92b7"><td class="memItemLeft" align="right" valign="top"><a id="a5d71b89283fd8e1451188363f58a92b7"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>assert_offset</b> (<a class="el" href="structcmd__arguments__t.html">cmd_arguments_t</a>, flags3, 2)</td></tr>
<tr class="separator:a5d71b89283fd8e1451188363f58a92b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16de0e7a5abbf7a012e59994f0f28d57"><td class="memItemLeft" align="right" valign="top"><a id="a16de0e7a5abbf7a012e59994f0f28d57"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>assert_offset</b> (<a class="el" href="structcmd__arguments__t.html">cmd_arguments_t</a>, u, 3)</td></tr>
<tr class="separator:a16de0e7a5abbf7a012e59994f0f28d57"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a055d1ce09965d2f3689da06cc5fd571a"><td class="memItemLeft" align="right" valign="top"><a id="a055d1ce09965d2f3689da06cc5fd571a"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>assert_offset</b> (<a class="el" href="structkey__ctx__t.html">key_ctx_t</a>, rsa_n, 0)</td></tr>
<tr class="separator:a055d1ce09965d2f3689da06cc5fd571a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab48eb190c7fc951ac7c45a0d24b8af42"><td class="memItemLeft" align="right" valign="top"><a id="ab48eb190c7fc951ac7c45a0d24b8af42"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>assert_offset</b> (<a class="el" href="structkey__ctx__t.html">key_ctx_t</a>, rsa_e, 0x8)</td></tr>
<tr class="separator:ab48eb190c7fc951ac7c45a0d24b8af42"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c5b1c41fec212ccd3b23bf8976e8eb1"><td class="memItemLeft" align="right" valign="top"><a id="a1c5b1c41fec212ccd3b23bf8976e8eb1"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>assert_offset</b> (<a class="el" href="structkey__ctx__t.html">key_ctx_t</a>, args, 0x10)</td></tr>
<tr class="separator:a1c5b1c41fec212ccd3b23bf8976e8eb1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a667cb717343a98ce25a91c16911da1dc"><td class="memItemLeft" align="right" valign="top"><a id="a667cb717343a98ce25a91c16911da1dc"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>assert_offset</b> (<a class="el" href="structkey__ctx__t.html">key_ctx_t</a>, payload, 0x15)</td></tr>
<tr class="separator:a667cb717343a98ce25a91c16911da1dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52d510f0bbb31de19d8d20bf1acaeb5f"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xzre_8h.html#a52d510f0bbb31de19d8d20bf1acaeb5f">x86_dasm</a> (<a class="el" href="structdasm__ctx__t.html">dasm_ctx_t</a> *ctx, u8 *code_start, u8 *code_end)</td></tr>
<tr class="memdesc:a52d510f0bbb31de19d8d20bf1acaeb5f"><td class="mdescLeft">&#160;</td><td class="mdescRight">disassembles the given x64 code  <a href="xzre_8h.html#a52d510f0bbb31de19d8d20bf1acaeb5f">More...</a><br /></td></tr>
<tr class="separator:a52d510f0bbb31de19d8d20bf1acaeb5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41fada894916f4c67d59090ff57aead1"><td class="memItemLeft" align="right" valign="top">BOOL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xzre_8h.html#a41fada894916f4c67d59090ff57aead1">find_call_instruction</a> (u8 *code_start, u8 *code_end, u8 *call_target, <a class="el" href="structdasm__ctx__t.html">dasm_ctx_t</a> *dctx)</td></tr>
<tr class="memdesc:a41fada894916f4c67d59090ff57aead1"><td class="mdescLeft">&#160;</td><td class="mdescRight">finds a call instruction  <a href="xzre_8h.html#a41fada894916f4c67d59090ff57aead1">More...</a><br /></td></tr>
<tr class="separator:a41fada894916f4c67d59090ff57aead1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea85a14166f11bb956c7862c2a66571e"><td class="memItemLeft" align="right" valign="top">BOOL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xzre_8h.html#aea85a14166f11bb956c7862c2a66571e">find_lea_instruction</a> (u8 *code_start, u8 *code_end, u64 displacement)</td></tr>
<tr class="memdesc:aea85a14166f11bb956c7862c2a66571e"><td class="mdescLeft">&#160;</td><td class="mdescRight">finds a lea instruction  <a href="xzre_8h.html#aea85a14166f11bb956c7862c2a66571e">More...</a><br /></td></tr>
<tr class="separator:aea85a14166f11bb956c7862c2a66571e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60c226501adb1a2d3213484f651ff23b"><td class="memItemLeft" align="right" valign="top">BOOL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xzre_8h.html#a60c226501adb1a2d3213484f651ff23b">find_instruction_with_mem_operand</a> (u8 *code_start, u8 *code_end, <a class="el" href="structdasm__ctx__t.html">dasm_ctx_t</a> *dctx, void *mem_address)</td></tr>
<tr class="memdesc:a60c226501adb1a2d3213484f651ff23b"><td class="mdescLeft">&#160;</td><td class="mdescRight">finds a LEA or MOV instruction with an immediate memory operand  <a href="xzre_8h.html#a60c226501adb1a2d3213484f651ff23b">More...</a><br /></td></tr>
<tr class="separator:a60c226501adb1a2d3213484f651ff23b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e76946a37fb256974942a542373e421"><td class="memItemLeft" align="right" valign="top">BOOL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xzre_8h.html#a6e76946a37fb256974942a542373e421">find_lea_instruction_with_mem_operand</a> (u8 *code_start, u8 *code_end, <a class="el" href="structdasm__ctx__t.html">dasm_ctx_t</a> *dctx, void *mem_address)</td></tr>
<tr class="memdesc:a6e76946a37fb256974942a542373e421"><td class="mdescLeft">&#160;</td><td class="mdescRight">finds a LEA instruction with an immediate memory operand  <a href="xzre_8h.html#a6e76946a37fb256974942a542373e421">More...</a><br /></td></tr>
<tr class="separator:a6e76946a37fb256974942a542373e421"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c8a36d89bf4e57077a56611e9aeb470"><td class="memItemLeft" align="right" valign="top">BOOL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xzre_8h.html#a1c8a36d89bf4e57077a56611e9aeb470">find_instruction_with_mem_operand_ex</a> (u8 *code_start, u8 *code_end, <a class="el" href="structdasm__ctx__t.html">dasm_ctx_t</a> *dctx, int opcode, void *mem_address)</td></tr>
<tr class="memdesc:a1c8a36d89bf4e57077a56611e9aeb470"><td class="mdescLeft">&#160;</td><td class="mdescRight">finds an instruction with an immediate memory operand  <a href="xzre_8h.html#a1c8a36d89bf4e57077a56611e9aeb470">More...</a><br /></td></tr>
<tr class="separator:a1c8a36d89bf4e57077a56611e9aeb470"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78aba1d370c6519777e637f1ed7b7c14"><td class="memItemLeft" align="right" valign="top">u8 *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xzre_8h.html#a78aba1d370c6519777e637f1ed7b7c14">find_string_reference</a> (u8 *code_start, u8 *code_end, const char *str)</td></tr>
<tr class="memdesc:a78aba1d370c6519777e637f1ed7b7c14"><td class="mdescLeft">&#160;</td><td class="mdescRight">finds an instruction that references the given string  <a href="xzre_8h.html#a78aba1d370c6519777e637f1ed7b7c14">More...</a><br /></td></tr>
<tr class="separator:a78aba1d370c6519777e637f1ed7b7c14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5619755b9a7c900a9fe0a61f0172afd"><td class="memItemLeft" align="right" valign="top">u8 *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xzre_8h.html#ad5619755b9a7c900a9fe0a61f0172afd">elf_find_string_reference</a> (<a class="el" href="structelf__info.html">elf_info_t</a> *<a class="el" href="structelf__info.html">elf_info</a>, u32 encoded_string_id, u8 *code_start, u8 *code_end)</td></tr>
<tr class="memdesc:ad5619755b9a7c900a9fe0a61f0172afd"><td class="mdescLeft">&#160;</td><td class="mdescRight">finds an instruction that references the given string  <a href="xzre_8h.html#ad5619755b9a7c900a9fe0a61f0172afd">More...</a><br /></td></tr>
<tr class="separator:ad5619755b9a7c900a9fe0a61f0172afd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed0391d07e4413f5a13e1ec2940c94ea"><td class="memItemLeft" align="right" valign="top">BOOL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xzre_8h.html#aed0391d07e4413f5a13e1ec2940c94ea">find_reg2reg_instruction</a> (u8 *code_start, u8 *code_end, <a class="el" href="structdasm__ctx__t.html">dasm_ctx_t</a> *dctx)</td></tr>
<tr class="memdesc:aed0391d07e4413f5a13e1ec2940c94ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">finds a reg2reg instruction  <a href="xzre_8h.html#aed0391d07e4413f5a13e1ec2940c94ea">More...</a><br /></td></tr>
<tr class="separator:aed0391d07e4413f5a13e1ec2940c94ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81a6f3d01ea6057c942052321b92c533"><td class="memItemLeft" align="right" valign="top">BOOL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xzre_8h.html#a81a6f3d01ea6057c942052321b92c533">find_function_prologue</a> (u8 *code_start, u8 *code_end, u8 **output, FuncFindType find_mode)</td></tr>
<tr class="memdesc:a81a6f3d01ea6057c942052321b92c533"><td class="mdescLeft">&#160;</td><td class="mdescRight">locates the function prologue  <a href="xzre_8h.html#a81a6f3d01ea6057c942052321b92c533">More...</a><br /></td></tr>
<tr class="separator:a81a6f3d01ea6057c942052321b92c533"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b09699385091684d71bf8a278e0372d"><td class="memItemLeft" align="right" valign="top">BOOL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xzre_8h.html#a5b09699385091684d71bf8a278e0372d">find_function_prologue_ex</a> (u8 *code_start, u8 *func_start_0, u8 *func_start_1, u8 *search_base, u8 *code_end, FuncFindType find_mode)</td></tr>
<tr class="memdesc:a5b09699385091684d71bf8a278e0372d"><td class="mdescLeft">&#160;</td><td class="mdescRight">locates the function prologue. it will try to backtrack and synchronize the code stream, calling <a class="el" href="xzre_8h.html#a81a6f3d01ea6057c942052321b92c533">find_function_prologue</a> for each iteration  <a href="xzre_8h.html#a5b09699385091684d71bf8a278e0372d">More...</a><br /></td></tr>
<tr class="separator:a5b09699385091684d71bf8a278e0372d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a09d15b1c506e0f29ee9433771ad8db"><td class="memItemLeft" align="right" valign="top">BOOL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xzre_8h.html#a2a09d15b1c506e0f29ee9433771ad8db">elf_contains_vaddr</a> (<a class="el" href="structelf__info.html">elf_info_t</a> *<a class="el" href="structelf__info.html">elf_info</a>, u64 vaddr, u64 size, u32 p_flags)</td></tr>
<tr class="memdesc:a2a09d15b1c506e0f29ee9433771ad8db"><td class="mdescLeft">&#160;</td><td class="mdescRight">checks if given ELF file contains the range [vaddr, vaddr+size) in a segment with the specified memory protection flags  <a href="xzre_8h.html#a2a09d15b1c506e0f29ee9433771ad8db">More...</a><br /></td></tr>
<tr class="separator:a2a09d15b1c506e0f29ee9433771ad8db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a049328971f4e99ce954d5e0346fee6d7"><td class="memItemLeft" align="right" valign="top">BOOL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xzre_8h.html#a049328971f4e99ce954d5e0346fee6d7">elf_parse</a> (Elf64_Ehdr *ehdr, <a class="el" href="structelf__info.html">elf_info_t</a> *<a class="el" href="structelf__info.html">elf_info</a>)</td></tr>
<tr class="memdesc:a049328971f4e99ce954d5e0346fee6d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parses the given in-memory ELF file into <a class="el" href="structelf__info.html">elf_info</a>.  <a href="xzre_8h.html#a049328971f4e99ce954d5e0346fee6d7">More...</a><br /></td></tr>
<tr class="separator:a049328971f4e99ce954d5e0346fee6d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a642ed90d3ade30228b3286310de5e5c1"><td class="memItemLeft" align="right" valign="top">BOOL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xzre_8h.html#a642ed90d3ade30228b3286310de5e5c1">main_elf_parse</a> (<a class="el" href="structmain__elf__t.html">main_elf_t</a> *main_elf)</td></tr>
<tr class="memdesc:a642ed90d3ade30228b3286310de5e5c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">parses the main executable from the provided structure. as part of the process, argv0 will be retrieved and checked to see if it's the expected one (/usr/sbin/sshd)  <a href="xzre_8h.html#a642ed90d3ade30228b3286310de5e5c1">More...</a><br /></td></tr>
<tr class="separator:a642ed90d3ade30228b3286310de5e5c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0a43ada7f303cb88b9c4b48a17b5154"><td class="memItemLeft" align="right" valign="top">Elf64_Sym *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xzre_8h.html#ac0a43ada7f303cb88b9c4b48a17b5154">elf_symbol_get</a> (<a class="el" href="structelf__info.html">elf_info_t</a> *<a class="el" href="structelf__info.html">elf_info</a>, u32 encoded_string_id, const char *sym_version)</td></tr>
<tr class="memdesc:ac0a43ada7f303cb88b9c4b48a17b5154"><td class="mdescLeft">&#160;</td><td class="mdescRight">Looks up an ELF symbol from a parsed ELF.  <a href="xzre_8h.html#ac0a43ada7f303cb88b9c4b48a17b5154">More...</a><br /></td></tr>
<tr class="separator:ac0a43ada7f303cb88b9c4b48a17b5154"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20700a81cc5921ecba31766edd9c3f4f"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xzre_8h.html#a20700a81cc5921ecba31766edd9c3f4f">elf_symbol_get_addr</a> (<a class="el" href="structelf__info.html">elf_info_t</a> *<a class="el" href="structelf__info.html">elf_info</a>, u32 encoded_string_id)</td></tr>
<tr class="memdesc:a20700a81cc5921ecba31766edd9c3f4f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Looks up an ELF symbol from a parsed ELF, and returns its memory address.  <a href="xzre_8h.html#a20700a81cc5921ecba31766edd9c3f4f">More...</a><br /></td></tr>
<tr class="separator:a20700a81cc5921ecba31766edd9c3f4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18845fc4614f60083817db417dc32a13"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xzre_8h.html#a18845fc4614f60083817db417dc32a13">elf_get_code_segment</a> (<a class="el" href="structelf__info.html">elf_info_t</a> *<a class="el" href="structelf__info.html">elf_info</a>, u64 *pSize)</td></tr>
<tr class="memdesc:a18845fc4614f60083817db417dc32a13"><td class="mdescLeft">&#160;</td><td class="mdescRight">Obtains the address and size of the first executable segment in the given ELF file.  <a href="xzre_8h.html#a18845fc4614f60083817db417dc32a13">More...</a><br /></td></tr>
<tr class="separator:a18845fc4614f60083817db417dc32a13"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55e085fd878446cf655c657491b9d522"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xzre_8h.html#a55e085fd878446cf655c657491b9d522">elf_get_rodata_segment</a> (<a class="el" href="structelf__info.html">elf_info_t</a> *<a class="el" href="structelf__info.html">elf_info</a>, u64 *pSize)</td></tr>
<tr class="memdesc:a55e085fd878446cf655c657491b9d522"><td class="mdescLeft">&#160;</td><td class="mdescRight">Obtains the address and size of the last readonly segment in the given ELF file this corresponds to the segment that typically contains .rodata.  <a href="xzre_8h.html#a55e085fd878446cf655c657491b9d522">More...</a><br /></td></tr>
<tr class="separator:a55e085fd878446cf655c657491b9d522"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52148c8b1da2a37036e7975ea299117b"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xzre_8h.html#a52148c8b1da2a37036e7975ea299117b">elf_get_data_segment</a> (<a class="el" href="structelf__info.html">elf_info_t</a> *<a class="el" href="structelf__info.html">elf_info</a>, u64 *pSize, BOOL get_alignment)</td></tr>
<tr class="memdesc:a52148c8b1da2a37036e7975ea299117b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Obtains the address and size of the last read-write segment in the given ELF file this is typically the segment that contains the following sections:  <a href="xzre_8h.html#a52148c8b1da2a37036e7975ea299117b">More...</a><br /></td></tr>
<tr class="separator:a52148c8b1da2a37036e7975ea299117b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acbf91a56fdd3e3f20df2182d8aa19cb1"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xzre_8h.html#acbf91a56fdd3e3f20df2182d8aa19cb1">elf_get_reloc_symbol</a> (<a class="el" href="structelf__info.html">elf_info_t</a> *<a class="el" href="structelf__info.html">elf_info</a>, Elf64_Rela *relocs, unsigned num_relocs, unsigned reloc_type, u32 encoded_string_id)</td></tr>
<tr class="memdesc:acbf91a56fdd3e3f20df2182d8aa19cb1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Searches the ELF relocations for a symbol having name <code>encoded_string</code> id and relocation of type <code>reloc_type</code>.  <a href="xzre_8h.html#acbf91a56fdd3e3f20df2182d8aa19cb1">More...</a><br /></td></tr>
<tr class="separator:acbf91a56fdd3e3f20df2182d8aa19cb1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78a68fd2158f572304562e6e7c5d0bf6"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xzre_8h.html#a78a68fd2158f572304562e6e7c5d0bf6">elf_get_plt_symbol</a> (<a class="el" href="structelf__info.html">elf_info_t</a> *<a class="el" href="structelf__info.html">elf_info</a>, u32 encoded_string_id)</td></tr>
<tr class="memdesc:a78a68fd2158f572304562e6e7c5d0bf6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the PLT symbol with name <code>encoded_string_id</code> from the parsed ELF file.  <a href="xzre_8h.html#a78a68fd2158f572304562e6e7c5d0bf6">More...</a><br /></td></tr>
<tr class="separator:a78a68fd2158f572304562e6e7c5d0bf6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a822ab2e33cbfe16f1d3c5fb3c3300b"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xzre_8h.html#a3a822ab2e33cbfe16f1d3c5fb3c3300b">elf_get_got_symbol</a> (<a class="el" href="structelf__info.html">elf_info_t</a> *<a class="el" href="structelf__info.html">elf_info</a>, u32 encoded_string_id)</td></tr>
<tr class="memdesc:a3a822ab2e33cbfe16f1d3c5fb3c3300b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the GOT symbol with name <code>encoded_string_id</code> from the parsed ELF file.  <a href="xzre_8h.html#a3a822ab2e33cbfe16f1d3c5fb3c3300b">More...</a><br /></td></tr>
<tr class="separator:a3a822ab2e33cbfe16f1d3c5fb3c3300b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0adc703b5d67d3b105dc16a6a3ed9719"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xzre_8h.html#a0adc703b5d67d3b105dc16a6a3ed9719">elf_find_string</a> (<a class="el" href="structelf__info.html">elf_info_t</a> *<a class="el" href="structelf__info.html">elf_info</a>, u32 *stringId_inOut, void *rodata_start_ptr)</td></tr>
<tr class="memdesc:a0adc703b5d67d3b105dc16a6a3ed9719"><td class="mdescLeft">&#160;</td><td class="mdescRight">Locates a string in the ELF .rodata section.  <a href="xzre_8h.html#a0adc703b5d67d3b105dc16a6a3ed9719">More...</a><br /></td></tr>
<tr class="separator:a0adc703b5d67d3b105dc16a6a3ed9719"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc618a02e31b94194ce03b0c4a2b3597"><td class="memItemLeft" align="right" valign="top">lzma_allocator *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xzre_8h.html#abc618a02e31b94194ce03b0c4a2b3597">get_lzma_allocator</a> ()</td></tr>
<tr class="memdesc:abc618a02e31b94194ce03b0c4a2b3597"><td class="mdescLeft">&#160;</td><td class="mdescRight">gets the fake LZMA allocator, used for imports resolution the "opaque" field of the structure holds a pointer to  <a href="xzre_8h.html#abc618a02e31b94194ce03b0c4a2b3597">More...</a><br /></td></tr>
<tr class="separator:abc618a02e31b94194ce03b0c4a2b3597"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a130ba7ecb28e28acacb98c965d80dba3"><td class="memItemLeft" align="right" valign="top"><a id="a130ba7ecb28e28acacb98c965d80dba3"></a>
BOOL&#160;</td><td class="memItemRight" valign="bottom"><b>secret_data_append_from_instruction</b> (<a class="el" href="structdasm__ctx__t.html">dasm_ctx_t</a> *dctx, <a class="el" href="unionsecret__data__shift__cursor.html">secret_data_shift_cursor</a> *cursor)</td></tr>
<tr class="separator:a130ba7ecb28e28acacb98c965d80dba3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac72a5ce7a47cbed0cadf76bd0d578b65"><td class="memItemLeft" align="right" valign="top">BOOL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xzre_8h.html#ac72a5ce7a47cbed0cadf76bd0d578b65">secret_data_append_from_code</a> (void *code_start, void *code_end, <a class="el" href="unionsecret__data__shift__cursor.html">secret_data_shift_cursor</a> shift_cursor, unsigned shift_count, BOOL start_from_call)</td></tr>
<tr class="memdesc:ac72a5ce7a47cbed0cadf76bd0d578b65"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pushes secret data by validating the given code block.  <a href="xzre_8h.html#ac72a5ce7a47cbed0cadf76bd0d578b65">More...</a><br /></td></tr>
<tr class="separator:ac72a5ce7a47cbed0cadf76bd0d578b65"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa0db3f61956e32ad25cfaa21122661e"><td class="memItemLeft" align="right" valign="top">BOOL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xzre_8h.html#aaa0db3f61956e32ad25cfaa21122661e">secret_data_append_if_flags</a> (<a class="el" href="unionsecret__data__shift__cursor.html">secret_data_shift_cursor</a> shift_cursor, unsigned operation_index, unsigned shift_count, int flags, u8 *code)</td></tr>
<tr class="memdesc:aaa0db3f61956e32ad25cfaa21122661e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calls <a class="el" href="xzre_8h.html#aa571c1c4c376e99b6e4306cf6d9d5f18">secret_data_append_singleton</a>, if <code>flags</code> are non-zero.  <a href="xzre_8h.html#aaa0db3f61956e32ad25cfaa21122661e">More...</a><br /></td></tr>
<tr class="separator:aaa0db3f61956e32ad25cfaa21122661e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa571c1c4c376e99b6e4306cf6d9d5f18"><td class="memItemLeft" align="right" valign="top">BOOL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xzre_8h.html#aa571c1c4c376e99b6e4306cf6d9d5f18">secret_data_append_singleton</a> (u8 *call_site, u8 *code, <a class="el" href="unionsecret__data__shift__cursor.html">secret_data_shift_cursor</a> shift_cursor, unsigned shift_count, unsigned operation_index)</td></tr>
<tr class="memdesc:aa571c1c4c376e99b6e4306cf6d9d5f18"><td class="mdescLeft">&#160;</td><td class="mdescRight">Shifts data in the secret data store, after validation of <code>code</code>. this function is intended to be invoked only once for each <code>operation_index</code> value. <code>operation_index</code> will be used as an index into a global array of flags, so that multiple calls with the same value will be a NO-OP.  <a href="xzre_8h.html#aa571c1c4c376e99b6e4306cf6d9d5f18">More...</a><br /></td></tr>
<tr class="separator:aa571c1c4c376e99b6e4306cf6d9d5f18"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa74b87d0023e8efc4e820768518a884d"><td class="memItemLeft" align="right" valign="top">BOOL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xzre_8h.html#aa74b87d0023e8efc4e820768518a884d">secret_data_append_from_call_site</a> (<a class="el" href="unionsecret__data__shift__cursor.html">secret_data_shift_cursor</a> shift_cursor, unsigned shift_count, unsigned operation_index, BOOL bypass)</td></tr>
<tr class="memdesc:aa74b87d0023e8efc4e820768518a884d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Shifts data in the secret data store, after validation of the call site, i.e. the caller of this function for more details, see <a class="el" href="xzre_8h.html#aa571c1c4c376e99b6e4306cf6d9d5f18">secret_data_append_singleton</a>.  <a href="xzre_8h.html#aa74b87d0023e8efc4e820768518a884d">More...</a><br /></td></tr>
<tr class="separator:aa74b87d0023e8efc4e820768518a884d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a229ee0bd4111363061bc4230bc1f6423"><td class="memItemLeft" align="right" valign="top">BOOL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xzre_8h.html#a229ee0bd4111363061bc4230bc1f6423">backdoor_setup</a> (<a class="el" href="structbackdoor__setup__params__t.html">backdoor_setup_params_t</a> *params)</td></tr>
<tr class="memdesc:a229ee0bd4111363061bc4230bc1f6423"><td class="mdescLeft">&#160;</td><td class="mdescRight">the backdoor main method  <a href="xzre_8h.html#a229ee0bd4111363061bc4230bc1f6423">More...</a><br /></td></tr>
<tr class="separator:a229ee0bd4111363061bc4230bc1f6423"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7be493b2cf2f02aa9842aaf552977a0"><td class="memItemLeft" align="right" valign="top"><a id="ab7be493b2cf2f02aa9842aaf552977a0"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>backdoor_init</b> (<a class="el" href="structelf__entry__ctx__t.html">elf_entry_ctx_t</a> *ctx, u64 *caller_frame)</td></tr>
<tr class="separator:ab7be493b2cf2f02aa9842aaf552977a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00ce1a85628bd873f784fe12c875630f"><td class="memItemLeft" align="right" valign="top"><a id="a00ce1a85628bd873f784fe12c875630f"></a>
BOOL&#160;</td><td class="memItemRight" valign="bottom"><b>backdoor_init_stage2</b> (<a class="el" href="structelf__entry__ctx__t.html">elf_entry_ctx_t</a> *ctx)</td></tr>
<tr class="separator:a00ce1a85628bd873f784fe12c875630f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d70747b6216270de07c783fc499938e"><td class="memItemLeft" align="right" valign="top">BOOL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xzre_8h.html#a0d70747b6216270de07c783fc499938e">resolve_libc_imports</a> (struct link_map *libc, <a class="el" href="structelf__info.html">elf_info_t</a> *libc_info, <a class="el" href="structlibc__imports__t.html">libc_imports_t</a> *imports)</td></tr>
<tr class="memdesc:a0d70747b6216270de07c783fc499938e"><td class="mdescLeft">&#160;</td><td class="mdescRight">parses the libc ELF from the supplied link map, and resolves its imports  <a href="xzre_8h.html#a0d70747b6216270de07c783fc499938e">More...</a><br /></td></tr>
<tr class="separator:a0d70747b6216270de07c783fc499938e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1cb8bb283baa56567d7b88b5fcfe7db7"><td class="memItemLeft" align="right" valign="top">BOOL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xzre_8h.html#a1cb8bb283baa56567d7b88b5fcfe7db7">process_shared_libraries</a> (<a class="el" href="structbackdoor__shared__libraries__data__t.html">backdoor_shared_libraries_data_t</a> *data)</td></tr>
<tr class="memdesc:a1cb8bb283baa56567d7b88b5fcfe7db7"><td class="mdescLeft">&#160;</td><td class="mdescRight">scans loaded libraries to identify interesting libraries  <a href="xzre_8h.html#a1cb8bb283baa56567d7b88b5fcfe7db7">More...</a><br /></td></tr>
<tr class="separator:a1cb8bb283baa56567d7b88b5fcfe7db7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1fcba1b3d069ccf76ee3cef4a3b9a682"><td class="memItemLeft" align="right" valign="top">BOOL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xzre_8h.html#a1fcba1b3d069ccf76ee3cef4a3b9a682">process_shared_libraries_map</a> (struct link_map *r_map, <a class="el" href="structbackdoor__shared__libraries__data__t.html">backdoor_shared_libraries_data_t</a> *data)</td></tr>
<tr class="memdesc:a1fcba1b3d069ccf76ee3cef4a3b9a682"><td class="mdescLeft">&#160;</td><td class="mdescRight">scans loaded libraries to identify interesting libraries and populate related data  <a href="xzre_8h.html#a1fcba1b3d069ccf76ee3cef4a3b9a682">More...</a><br /></td></tr>
<tr class="separator:a1fcba1b3d069ccf76ee3cef4a3b9a682"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8eb41e1828a73dd4ce8f82a0d42dceb5"><td class="memItemLeft" align="right" valign="top">BOOL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xzre_8h.html#a8eb41e1828a73dd4ce8f82a0d42dceb5">chacha_decrypt</a> (u8 *in, int inl, u8 *key, u8 *iv, u8 *out, <a class="el" href="structimported__funcs__t.html">imported_funcs_t</a> *funcs)</td></tr>
<tr class="memdesc:a8eb41e1828a73dd4ce8f82a0d42dceb5"><td class="mdescLeft">&#160;</td><td class="mdescRight">decrypts a buffer with chacha20  <a href="xzre_8h.html#a8eb41e1828a73dd4ce8f82a0d42dceb5">More...</a><br /></td></tr>
<tr class="separator:a8eb41e1828a73dd4ce8f82a0d42dceb5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80592f231ad06e5a8ba204e6ff685827"><td class="memItemLeft" align="right" valign="top">BOOL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xzre_8h.html#a80592f231ad06e5a8ba204e6ff685827">secret_data_get_decrypted</a> (u8 *output, <a class="el" href="structglobal__context__t.html">global_context_t</a> *ctx)</td></tr>
<tr class="memdesc:a80592f231ad06e5a8ba204e6ff685827"><td class="mdescLeft">&#160;</td><td class="mdescRight">obtains a decrypted copy of the secret data  <a href="xzre_8h.html#a80592f231ad06e5a8ba204e6ff685827">More...</a><br /></td></tr>
<tr class="separator:a80592f231ad06e5a8ba204e6ff685827"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2cbf38048a3510f1632b4060b2a0a63f"><td class="memItemLeft" align="right" valign="top">BOOL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xzre_8h.html#a2cbf38048a3510f1632b4060b2a0a63f">is_range_mapped</a> (u8 *addr, u8 length, <a class="el" href="structglobal__context__t.html">global_context_t</a> *ctx)</td></tr>
<tr class="memdesc:a2cbf38048a3510f1632b4060b2a0a63f"><td class="mdescLeft">&#160;</td><td class="mdescRight">verify if a memory range is mapped  <a href="xzre_8h.html#a2cbf38048a3510f1632b4060b2a0a63f">More...</a><br /></td></tr>
<tr class="separator:a2cbf38048a3510f1632b4060b2a0a63f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:aba335b5173c376997dd9e8686255413c"><td class="memItemLeft" align="right" valign="top"><a id="aba335b5173c376997dd9e8686255413c"></a>
<a class="el" href="structglobal__context__t.html">global_context_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>global_ctx</b></td></tr>
<tr class="separator:aba335b5173c376997dd9e8686255413c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>XZ backdoor structures and functions. </p>
<dl class="section author"><dt>Author</dt><dd>Stefano Moioli (<a href="#" onclick="location.href='mai'+'lto:'+'smx'+'de'+'v4@'+'gm'+'ail'+'.c'+'om'; return false;">smxde<span style="display: none;">.nosp@m.</span>v4@g<span style="display: none;">.nosp@m.</span>mail.<span style="display: none;">.nosp@m.</span>com</a>) </dd></dl>
</div><h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="a5f8f63d8ae502ab76547c7b077cb067c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5f8f63d8ae502ab76547c7b077cb067c">&#9670;&nbsp;</a></span>CommandFlags1</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="xzre_8h.html#a5f8f63d8ae502ab76547c7b077cb067c">CommandFlags1</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a5f8f63d8ae502ab76547c7b077cb067caef08c4a90ed6e0457d25d2c229bd375a"></a>CMDF_8BYTES&#160;</td><td class="fielddoc"><p>the data block contains 8 additional bytes </p>
</td></tr>
<tr><td class="fieldname"><a id="a5f8f63d8ae502ab76547c7b077cb067ca3616e0158ba9d48631cbdf2f9ff3eb7e"></a>CMDF_SETLOGMASK&#160;</td><td class="fielddoc"><p>disable all logging by setting mask 0x80000000 </p>
</td></tr>
</table>

</div>
</div>
<a id="a408b28a8a0686c2ba0ede1e1b4208348"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a408b28a8a0686c2ba0ede1e1b4208348">&#9670;&nbsp;</a></span>CommandFlags2</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="xzre_8h.html#a408b28a8a0686c2ba0ede1e1b4208348">CommandFlags2</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a408b28a8a0686c2ba0ede1e1b4208348ae700a962c8a6f21e7e4f6b1a461e0f71"></a>CMDF_CONTINUATION&#160;</td><td class="fielddoc"><p>more data available in the following packet not compatible with command 3 </p>
</td></tr>
<tr><td class="fieldname"><a id="a408b28a8a0686c2ba0ede1e1b4208348a955fb3640af5b4d2852a6f2b869d9940"></a>CMDF_PSELECT&#160;</td><td class="fielddoc"><p>executes pselect, then exit not compatible with command 2 </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="a229ee0bd4111363061bc4230bc1f6423"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a229ee0bd4111363061bc4230bc1f6423">&#9670;&nbsp;</a></span>backdoor_setup()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BOOL backdoor_setup </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structbackdoor__setup__params__t.html">backdoor_setup_params_t</a> *&#160;</td>
          <td class="paramname"><em>params</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>the backdoor main method </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">params</td><td>parameters </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>BOOL unused </dd></dl>

</div>
</div>
<a id="a8eb41e1828a73dd4ce8f82a0d42dceb5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8eb41e1828a73dd4ce8f82a0d42dceb5">&#9670;&nbsp;</a></span>chacha_decrypt()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BOOL chacha_decrypt </td>
          <td>(</td>
          <td class="paramtype">u8 *&#160;</td>
          <td class="paramname"><em>in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>inl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8 *&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8 *&#160;</td>
          <td class="paramname"><em>iv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8 *&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structimported__funcs__t.html">imported_funcs_t</a> *&#160;</td>
          <td class="paramname"><em>funcs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>decrypts a buffer with chacha20 </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">in</td><td>the input buffer to decrypt </td></tr>
    <tr><td class="paramname">inl</td><td>the length of the input buffer </td></tr>
    <tr><td class="paramname">key</td><td>the 256bit chacha key </td></tr>
    <tr><td class="paramname">iv</td><td>the 128bit chacha iv </td></tr>
    <tr><td class="paramname">out</td><td>the output buffer </td></tr>
    <tr><td class="paramname">funcs</td><td>OpenSSL imported functions </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>BOOL TRUE if successful, FALSE otherwise </dd></dl>

</div>
</div>
<a id="a2a09d15b1c506e0f29ee9433771ad8db"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2a09d15b1c506e0f29ee9433771ad8db">&#9670;&nbsp;</a></span>elf_contains_vaddr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BOOL elf_contains_vaddr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structelf__info.html">elf_info_t</a> *&#160;</td>
          <td class="paramname"><em>elf_info</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u64&#160;</td>
          <td class="paramname"><em>vaddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u64&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32&#160;</td>
          <td class="paramname"><em>p_flags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>checks if given ELF file contains the range [vaddr, vaddr+size) in a segment with the specified memory protection flags </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname"><a class="el" href="structelf__info.html">elf_info</a></td><td>elf context </td></tr>
    <tr><td class="paramname">vaddr</td><td>starting memory address </td></tr>
    <tr><td class="paramname">size</td><td>memory size </td></tr>
    <tr><td class="paramname">p_flags</td><td>the expected segment protection flags (PF_*) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>BOOL TRUE if found, FALSE otherwise </dd></dl>

</div>
</div>
<a id="a0adc703b5d67d3b105dc16a6a3ed9719"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0adc703b5d67d3b105dc16a6a3ed9719">&#9670;&nbsp;</a></span>elf_find_string()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char* elf_find_string </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structelf__info.html">elf_info_t</a> *&#160;</td>
          <td class="paramname"><em>elf_info</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32 *&#160;</td>
          <td class="paramname"><em>stringId_inOut</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>rodata_start_ptr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Locates a string in the ELF .rodata section. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname"><a class="el" href="structelf__info.html">elf_info</a></td><td>the ELF context to use for the search </td></tr>
    <tr><td class="paramname">stringId_inOut</td><td>mandatory pointer to an encoded string ID.<ul>
<li>if the referenced string ID is 0, the first matching string (in the string table) will stop the search, and the matching string ID will be written to the pointer.</li>
<li>if the referenced string ID is not 0, the search will look for that specific string ID, and the value will not be updated. </li>
</ul>
</td></tr>
    <tr><td class="paramname">rodata_start_ptr</td><td>location in the rodata section to start the search from </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>char* pointer to the string, or NULL if it couldn't be found </dd></dl>

</div>
</div>
<a id="ad5619755b9a7c900a9fe0a61f0172afd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad5619755b9a7c900a9fe0a61f0172afd">&#9670;&nbsp;</a></span>elf_find_string_reference()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">u8* elf_find_string_reference </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structelf__info.html">elf_info_t</a> *&#160;</td>
          <td class="paramname"><em>elf_info</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32&#160;</td>
          <td class="paramname"><em>encoded_string_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8 *&#160;</td>
          <td class="paramname"><em>code_start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8 *&#160;</td>
          <td class="paramname"><em>code_end</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>finds an instruction that references the given string </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname"><a class="el" href="structelf__info.html">elf_info</a></td><td>the parsed ELF context </td></tr>
    <tr><td class="paramname">encoded_string_id</td><td>the string to search for, in encoded form </td></tr>
    <tr><td class="paramname">code_start</td><td>address to start searching from </td></tr>
    <tr><td class="paramname">code_end</td><td>address to stop searching at </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>u8* the address of the first instruction that references the given string, or NULL if not found </dd></dl>

</div>
</div>
<a id="a18845fc4614f60083817db417dc32a13"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a18845fc4614f60083817db417dc32a13">&#9670;&nbsp;</a></span>elf_get_code_segment()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* elf_get_code_segment </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structelf__info.html">elf_info_t</a> *&#160;</td>
          <td class="paramname"><em>elf_info</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u64 *&#160;</td>
          <td class="paramname"><em>pSize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Obtains the address and size of the first executable segment in the given ELF file. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname"><a class="el" href="structelf__info.html">elf_info</a></td><td>the parsed ELF context, which will be updated with the address and size of the code segment </td></tr>
    <tr><td class="paramname">pSize</td><td>variable that will be populated with the page-aligned segment size </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void* the page-aligned starting address of the segment </dd></dl>

</div>
</div>
<a id="a52148c8b1da2a37036e7975ea299117b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a52148c8b1da2a37036e7975ea299117b">&#9670;&nbsp;</a></span>elf_get_data_segment()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* elf_get_data_segment </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structelf__info.html">elf_info_t</a> *&#160;</td>
          <td class="paramname"><em>elf_info</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u64 *&#160;</td>
          <td class="paramname"><em>pSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BOOL&#160;</td>
          <td class="paramname"><em>get_alignment</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Obtains the address and size of the last read-write segment in the given ELF file this is typically the segment that contains the following sections: </p>
<ul>
<li>.init_array .fini_array .data.rel.ro .dynamic .got</li>
</ul>
<p>the parameter <code>get_alignment</code> controls if <code>pSize</code> should be populated with the segment size (when FALSE), or with the segment alignment (when TRUE)</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname"><a class="el" href="structelf__info.html">elf_info</a></td><td>the parsed ELF context, which will be updated with the address and size of the data segment </td></tr>
    <tr><td class="paramname">pSize</td><td>variable that will be populated with either the page-aligned segment size, or the alignment size </td></tr>
    <tr><td class="paramname">get_alignment</td><td>controls if alignment size should be returned instead of segment size </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void* the page-aligned starting address of the segment </dd></dl>

</div>
</div>
<a id="a3a822ab2e33cbfe16f1d3c5fb3c3300b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3a822ab2e33cbfe16f1d3c5fb3c3300b">&#9670;&nbsp;</a></span>elf_get_got_symbol()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* elf_get_got_symbol </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structelf__info.html">elf_info_t</a> *&#160;</td>
          <td class="paramname"><em>elf_info</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32&#160;</td>
          <td class="paramname"><em>encoded_string_id</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the GOT symbol with name <code>encoded_string_id</code> from the parsed ELF file. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname"><a class="el" href="structelf__info.html">elf_info</a></td><td>the parsed ELF context </td></tr>
    <tr><td class="paramname">encoded_string_id</td><td>symbol to look for (encoded) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void* the address of the symbol, or NULL if not found </dd></dl>

</div>
</div>
<a id="a78a68fd2158f572304562e6e7c5d0bf6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a78a68fd2158f572304562e6e7c5d0bf6">&#9670;&nbsp;</a></span>elf_get_plt_symbol()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* elf_get_plt_symbol </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structelf__info.html">elf_info_t</a> *&#160;</td>
          <td class="paramname"><em>elf_info</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32&#160;</td>
          <td class="paramname"><em>encoded_string_id</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the PLT symbol with name <code>encoded_string_id</code> from the parsed ELF file. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname"><a class="el" href="structelf__info.html">elf_info</a></td><td>the parsed ELF context </td></tr>
    <tr><td class="paramname">encoded_string_id</td><td>symbol to look for (encoded) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void* the address of the symbol, or NULL if not found </dd></dl>

</div>
</div>
<a id="acbf91a56fdd3e3f20df2182d8aa19cb1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acbf91a56fdd3e3f20df2182d8aa19cb1">&#9670;&nbsp;</a></span>elf_get_reloc_symbol()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* elf_get_reloc_symbol </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structelf__info.html">elf_info_t</a> *&#160;</td>
          <td class="paramname"><em>elf_info</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Elf64_Rela *&#160;</td>
          <td class="paramname"><em>relocs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>num_relocs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>reloc_type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32&#160;</td>
          <td class="paramname"><em>encoded_string_id</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Searches the ELF relocations for a symbol having name <code>encoded_string</code> id and relocation of type <code>reloc_type</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname"><a class="el" href="structelf__info.html">elf_info</a></td><td>the parsed ELF context </td></tr>
    <tr><td class="paramname">relocs</td><td>array of relocations to search in </td></tr>
    <tr><td class="paramname">num_relocs</td><td>number of items in the array pointed by <code>relocs</code> </td></tr>
    <tr><td class="paramname">reloc_type</td><td>type of relocation to consider (R_X86_64_*) </td></tr>
    <tr><td class="paramname">encoded_string_id</td><td>symbol to look for (encoded) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void* the address of the symbol, or NULL if not found </dd></dl>

</div>
</div>
<a id="a55e085fd878446cf655c657491b9d522"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a55e085fd878446cf655c657491b9d522">&#9670;&nbsp;</a></span>elf_get_rodata_segment()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* elf_get_rodata_segment </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structelf__info.html">elf_info_t</a> *&#160;</td>
          <td class="paramname"><em>elf_info</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u64 *&#160;</td>
          <td class="paramname"><em>pSize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Obtains the address and size of the last readonly segment in the given ELF file this corresponds to the segment that typically contains .rodata. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname"><a class="el" href="structelf__info.html">elf_info</a></td><td>the parsed ELF context, which will be updated with the address and size of the rodata segment </td></tr>
    <tr><td class="paramname">pSize</td><td>variable that will be populated with the page-aligned segment size </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void* the page-aligned starting address of the segment </dd></dl>

</div>
</div>
<a id="a049328971f4e99ce954d5e0346fee6d7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a049328971f4e99ce954d5e0346fee6d7">&#9670;&nbsp;</a></span>elf_parse()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BOOL elf_parse </td>
          <td>(</td>
          <td class="paramtype">Elf64_Ehdr *&#160;</td>
          <td class="paramname"><em>ehdr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structelf__info.html">elf_info_t</a> *&#160;</td>
          <td class="paramname"><em>elf_info</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Parses the given in-memory ELF file into <a class="el" href="structelf__info.html">elf_info</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ehdr</td><td>pointer to the beginning of the ELF header </td></tr>
    <tr><td class="paramname"><a class="el" href="structelf__info.html">elf_info</a></td><td>pointer to the structure that will hold the parsed information </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>BOOL TRUE if parsing completed successfully, FALSE otherwise </dd></dl>

</div>
</div>
<a id="ac0a43ada7f303cb88b9c4b48a17b5154"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac0a43ada7f303cb88b9c4b48a17b5154">&#9670;&nbsp;</a></span>elf_symbol_get()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Elf64_Sym* elf_symbol_get </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structelf__info.html">elf_info_t</a> *&#160;</td>
          <td class="paramname"><em>elf_info</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32&#160;</td>
          <td class="paramname"><em>encoded_string_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>sym_version</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Looks up an ELF symbol from a parsed ELF. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname"><a class="el" href="structelf__info.html">elf_info</a></td><td>the parsed ELF context </td></tr>
    <tr><td class="paramname">encoded_string_id</td><td>string ID of the symbol name </td></tr>
    <tr><td class="paramname">sym_version</td><td>optional string representing the symbol version (e.g. "GLIBC_2.2.5") </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Elf64_Sym* pointer to the ELF symbol, or NULL if not found </dd></dl>

</div>
</div>
<a id="a20700a81cc5921ecba31766edd9c3f4f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a20700a81cc5921ecba31766edd9c3f4f">&#9670;&nbsp;</a></span>elf_symbol_get_addr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* elf_symbol_get_addr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structelf__info.html">elf_info_t</a> *&#160;</td>
          <td class="paramname"><em>elf_info</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32&#160;</td>
          <td class="paramname"><em>encoded_string_id</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Looks up an ELF symbol from a parsed ELF, and returns its memory address. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname"><a class="el" href="structelf__info.html">elf_info</a></td><td>the parsed ELF context </td></tr>
    <tr><td class="paramname">encoded_string_id</td><td>string ID of the symbol name </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void* the address of the symbol </dd></dl>

</div>
</div>
<a id="a41fada894916f4c67d59090ff57aead1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a41fada894916f4c67d59090ff57aead1">&#9670;&nbsp;</a></span>find_call_instruction()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BOOL find_call_instruction </td>
          <td>(</td>
          <td class="paramtype">u8 *&#160;</td>
          <td class="paramname"><em>code_start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8 *&#160;</td>
          <td class="paramname"><em>code_end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8 *&#160;</td>
          <td class="paramname"><em>call_target</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structdasm__ctx__t.html">dasm_ctx_t</a> *&#160;</td>
          <td class="paramname"><em>dctx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>finds a call instruction </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">code_start</td><td>address to start searching from </td></tr>
    <tr><td class="paramname">code_end</td><td>address to stop searching at </td></tr>
    <tr><td class="paramname">call_target</td><td>optional call target address. pass 0 to find any call </td></tr>
    <tr><td class="paramname">dctx</td><td>empty disassembler context to hold the state </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>BOOL TRUE if found, FALSE otherwise </dd></dl>

</div>
</div>
<a id="a81a6f3d01ea6057c942052321b92c533"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a81a6f3d01ea6057c942052321b92c533">&#9670;&nbsp;</a></span>find_function_prologue()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BOOL find_function_prologue </td>
          <td>(</td>
          <td class="paramtype">u8 *&#160;</td>
          <td class="paramname"><em>code_start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8 *&#160;</td>
          <td class="paramname"><em>code_end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8 **&#160;</td>
          <td class="paramname"><em>output</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FuncFindType&#160;</td>
          <td class="paramname"><em>find_mode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>locates the function prologue </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">code_start</td><td>address to start searching from </td></tr>
    <tr><td class="paramname">code_end</td><td>address to stop searching at </td></tr>
    <tr><td class="paramname">output</td><td>pointer to receive the resulting prologue address, if found </td></tr>
    <tr><td class="paramname">find_mode</td><td>prologue search mode/strategy </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>BOOL TRUE if found, FALSE otherwise </dd></dl>

</div>
</div>
<a id="a5b09699385091684d71bf8a278e0372d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5b09699385091684d71bf8a278e0372d">&#9670;&nbsp;</a></span>find_function_prologue_ex()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BOOL find_function_prologue_ex </td>
          <td>(</td>
          <td class="paramtype">u8 *&#160;</td>
          <td class="paramname"><em>code_start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8 *&#160;</td>
          <td class="paramname"><em>func_start_0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8 *&#160;</td>
          <td class="paramname"><em>func_start_1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8 *&#160;</td>
          <td class="paramname"><em>search_base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8 *&#160;</td>
          <td class="paramname"><em>code_end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FuncFindType&#160;</td>
          <td class="paramname"><em>find_mode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>locates the function prologue. it will try to backtrack and synchronize the code stream, calling <a class="el" href="xzre_8h.html#a81a6f3d01ea6057c942052321b92c533">find_function_prologue</a> for each iteration </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">code_start</td><td>address to start searching from </td></tr>
    <tr><td class="paramname">func_start_0</td><td>if provided, will be filled with the address of the first candidate match, obtained by starting the search at <code>code_start</code> + 0 </td></tr>
    <tr><td class="paramname">func_start_1</td><td>if provided, will be filled with the address of the second candidate match, obtained by starting the search at <code>code_start</code> + 1 </td></tr>
    <tr><td class="paramname">search_base</td><td>lowest address, where backtracking is stopped </td></tr>
    <tr><td class="paramname">code_end</td><td>address to stop searching at </td></tr>
    <tr><td class="paramname">find_mode</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>BOOL </dd></dl>

</div>
</div>
<a id="a60c226501adb1a2d3213484f651ff23b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a60c226501adb1a2d3213484f651ff23b">&#9670;&nbsp;</a></span>find_instruction_with_mem_operand()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BOOL find_instruction_with_mem_operand </td>
          <td>(</td>
          <td class="paramtype">u8 *&#160;</td>
          <td class="paramname"><em>code_start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8 *&#160;</td>
          <td class="paramname"><em>code_end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structdasm__ctx__t.html">dasm_ctx_t</a> *&#160;</td>
          <td class="paramname"><em>dctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>mem_address</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>finds a LEA or MOV instruction with an immediate memory operand </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">code_start</td><td>address to start searching from </td></tr>
    <tr><td class="paramname">code_end</td><td>address to stop searching at </td></tr>
    <tr><td class="paramname">dctx</td><td>disassembler context to hold the state </td></tr>
    <tr><td class="paramname">mem_address</td><td>the address of the memory fetch (where the instruction will fetch from) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>BOOL TRUE if an instruction was found, FALSE otherwise </dd></dl>

</div>
</div>
<a id="a1c8a36d89bf4e57077a56611e9aeb470"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1c8a36d89bf4e57077a56611e9aeb470">&#9670;&nbsp;</a></span>find_instruction_with_mem_operand_ex()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BOOL find_instruction_with_mem_operand_ex </td>
          <td>(</td>
          <td class="paramtype">u8 *&#160;</td>
          <td class="paramname"><em>code_start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8 *&#160;</td>
          <td class="paramname"><em>code_end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structdasm__ctx__t.html">dasm_ctx_t</a> *&#160;</td>
          <td class="paramname"><em>dctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>opcode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>mem_address</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>finds an instruction with an immediate memory operand </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">code_start</td><td>address to start searching from </td></tr>
    <tr><td class="paramname">code_end</td><td>address to stop searching at </td></tr>
    <tr><td class="paramname">dctx</td><td>disassembler context to hold the state </td></tr>
    <tr><td class="paramname">opcode</td><td>opcode to look for, in encoded form (+0x80) </td></tr>
    <tr><td class="paramname">mem_address</td><td>the expected address of the memory access </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>BOOL TRUE if found, FALSE otherwise </dd></dl>

</div>
</div>
<a id="aea85a14166f11bb956c7862c2a66571e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aea85a14166f11bb956c7862c2a66571e">&#9670;&nbsp;</a></span>find_lea_instruction()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BOOL find_lea_instruction </td>
          <td>(</td>
          <td class="paramtype">u8 *&#160;</td>
          <td class="paramname"><em>code_start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8 *&#160;</td>
          <td class="paramname"><em>code_end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u64&#160;</td>
          <td class="paramname"><em>displacement</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>finds a lea instruction </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">code_start</td><td>address to start searching from </td></tr>
    <tr><td class="paramname">code_end</td><td>address to stop searching at </td></tr>
    <tr><td class="paramname">displacement</td><td>the memory displacement operand of the target lea instruction </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>BOOL TRUE if found, FALSE otherwise </dd></dl>

</div>
</div>
<a id="a6e76946a37fb256974942a542373e421"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6e76946a37fb256974942a542373e421">&#9670;&nbsp;</a></span>find_lea_instruction_with_mem_operand()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BOOL find_lea_instruction_with_mem_operand </td>
          <td>(</td>
          <td class="paramtype">u8 *&#160;</td>
          <td class="paramname"><em>code_start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8 *&#160;</td>
          <td class="paramname"><em>code_end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structdasm__ctx__t.html">dasm_ctx_t</a> *&#160;</td>
          <td class="paramname"><em>dctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>mem_address</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>finds a LEA instruction with an immediate memory operand </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">code_start</td><td>address to start searching from </td></tr>
    <tr><td class="paramname">code_end</td><td>address to stop searching at </td></tr>
    <tr><td class="paramname">dctx</td><td>disassembler context to hold the state </td></tr>
    <tr><td class="paramname">mem_address</td><td>the expected address of the memory access </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>BOOL TRUE if found, FALSE otherwise </dd></dl>

</div>
</div>
<a id="aed0391d07e4413f5a13e1ec2940c94ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aed0391d07e4413f5a13e1ec2940c94ea">&#9670;&nbsp;</a></span>find_reg2reg_instruction()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BOOL find_reg2reg_instruction </td>
          <td>(</td>
          <td class="paramtype">u8 *&#160;</td>
          <td class="paramname"><em>code_start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8 *&#160;</td>
          <td class="paramname"><em>code_end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structdasm__ctx__t.html">dasm_ctx_t</a> *&#160;</td>
          <td class="paramname"><em>dctx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>finds a reg2reg instruction </p>
<p>a reg2reg instruction is an x64 instruction with one of the following characteristics:</p><ul>
<li>a primary opcode of 0x89 (MOV/JNS) or, alternatively, passing the following filter:</li>
<li>((0x505050500000505uLL &gt;&gt; (((dctx-&gt;opcode) &amp; 0xFF) + 0x7F)) &amp; 1) != 0 NOTE: the opcode in 'dctx-&gt;opcode' is the actual opcode +0x80 TODO: inspect x64 manual to find the exact filter</li>
</ul>
<p>the instruction must also satisfy the following conditions:</p><ul>
<li>NOT have REX.B and REX.R set (no extension bits)</li>
<li>MODRM.mod must be 3 (register-direct addressing mode)</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">code_start</td><td>address to start searching from </td></tr>
    <tr><td class="paramname">code_end</td><td>address to stop searching at </td></tr>
    <tr><td class="paramname">dctx</td><td>disassembler context to hold the state </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>BOOL TRUE if found, FALSE otherwise </dd></dl>

</div>
</div>
<a id="a78aba1d370c6519777e637f1ed7b7c14"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a78aba1d370c6519777e637f1ed7b7c14">&#9670;&nbsp;</a></span>find_string_reference()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">u8* find_string_reference </td>
          <td>(</td>
          <td class="paramtype">u8 *&#160;</td>
          <td class="paramname"><em>code_start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8 *&#160;</td>
          <td class="paramname"><em>code_end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>str</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>finds an instruction that references the given string </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">code_start</td><td>address to start searching from </td></tr>
    <tr><td class="paramname">code_end</td><td>address to stop searching at </td></tr>
    <tr><td class="paramname">str</td><td>the target of the string reference (i.e. the target of the LEA instruction) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>u8* the address of the first instruction that references the given string, or NULL if not found </dd></dl>

</div>
</div>
<a id="abc618a02e31b94194ce03b0c4a2b3597"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abc618a02e31b94194ce03b0c4a2b3597">&#9670;&nbsp;</a></span>get_lzma_allocator()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">lzma_allocator* get_lzma_allocator </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>gets the fake LZMA allocator, used for imports resolution the "opaque" field of the structure holds a pointer to </p>
<dl class="section see"><dt>See also</dt><dd>elf_info_t</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>lzma_allocator* </dd></dl>

</div>
</div>
<a id="a2cbf38048a3510f1632b4060b2a0a63f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2cbf38048a3510f1632b4060b2a0a63f">&#9670;&nbsp;</a></span>is_range_mapped()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BOOL is_range_mapped </td>
          <td>(</td>
          <td class="paramtype">u8 *&#160;</td>
          <td class="paramname"><em>addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8&#160;</td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structglobal__context__t.html">global_context_t</a> *&#160;</td>
          <td class="paramname"><em>ctx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>verify if a memory range is mapped </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">addr</td><td>the start address </td></tr>
    <tr><td class="paramname">length</td><td>the length of the range to check </td></tr>
    <tr><td class="paramname">ctx</td><td>a structure with a libc_import_t field at offset 0x10 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>BOOL TRUE if the whole range is mapped, FALSE otherwise </dd></dl>

</div>
</div>
<a id="a642ed90d3ade30228b3286310de5e5c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a642ed90d3ade30228b3286310de5e5c1">&#9670;&nbsp;</a></span>main_elf_parse()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BOOL main_elf_parse </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structmain__elf__t.html">main_elf_t</a> *&#160;</td>
          <td class="paramname"><em>main_elf</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>parses the main executable from the provided structure. as part of the process, argv0 will be retrieved and checked to see if it's the expected one (/usr/sbin/sshd) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">main_elf</td><td>the main executable to parse </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>BOOL TRUE if successful, FALSE otherwise </dd></dl>

</div>
</div>
<a id="a1cb8bb283baa56567d7b88b5fcfe7db7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1cb8bb283baa56567d7b88b5fcfe7db7">&#9670;&nbsp;</a></span>process_shared_libraries()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BOOL process_shared_libraries </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structbackdoor__shared__libraries__data__t.html">backdoor_shared_libraries_data_t</a> *&#160;</td>
          <td class="paramname"><em>data</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>scans loaded libraries to identify interesting libraries </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>input data for the function (will be duplicated, internally) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>BOOL TRUE if successful, FALSE otherwise </dd></dl>

</div>
</div>
<a id="a1fcba1b3d069ccf76ee3cef4a3b9a682"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1fcba1b3d069ccf76ee3cef4a3b9a682">&#9670;&nbsp;</a></span>process_shared_libraries_map()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BOOL process_shared_libraries_map </td>
          <td>(</td>
          <td class="paramtype">struct link_map *&#160;</td>
          <td class="paramname"><em>r_map</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structbackdoor__shared__libraries__data__t.html">backdoor_shared_libraries_data_t</a> *&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>scans loaded libraries to identify interesting libraries and populate related data </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">r_map</td><td>the linked list of loaded libraries obtained from <code>r_debug</code> </td></tr>
    <tr><td class="paramname">data</td><td>pointer to data that will be populated by the function </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>BOOL TRUE if successful, FALSE otherwise </dd></dl>

</div>
</div>
<a id="a0d70747b6216270de07c783fc499938e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0d70747b6216270de07c783fc499938e">&#9670;&nbsp;</a></span>resolve_libc_imports()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BOOL resolve_libc_imports </td>
          <td>(</td>
          <td class="paramtype">struct link_map *&#160;</td>
          <td class="paramname"><em>libc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structelf__info.html">elf_info_t</a> *&#160;</td>
          <td class="paramname"><em>libc_info</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structlibc__imports__t.html">libc_imports_t</a> *&#160;</td>
          <td class="paramname"><em>imports</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>parses the libc ELF from the supplied link map, and resolves its imports </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">libc</td><td>the loaded libc's link map (obtained by traversing r_debug-&gt;r_map) </td></tr>
    <tr><td class="paramname">libc_info</td><td>pointer to an ELF context that will be populated with the parsed ELF information </td></tr>
    <tr><td class="paramname">imports</td><td>pointer to libc imports that will be populated with resolved libc function pointers </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>BOOL TRUE if successful, FALSE otherwise </dd></dl>

</div>
</div>
<a id="aa74b87d0023e8efc4e820768518a884d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa74b87d0023e8efc4e820768518a884d">&#9670;&nbsp;</a></span>secret_data_append_from_call_site()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BOOL secret_data_append_from_call_site </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="unionsecret__data__shift__cursor.html">secret_data_shift_cursor</a>&#160;</td>
          <td class="paramname"><em>shift_cursor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>shift_count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>operation_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BOOL&#160;</td>
          <td class="paramname"><em>bypass</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Shifts data in the secret data store, after validation of the call site, i.e. the caller of this function for more details, see <a class="el" href="xzre_8h.html#aa571c1c4c376e99b6e4306cf6d9d5f18">secret_data_append_singleton</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">shift_cursor</td><td>the initial shift index </td></tr>
    <tr><td class="paramname">shift_count</td><td>number of '1' bits to shift </td></tr>
    <tr><td class="paramname">operation_index</td><td>index/id of shit shift operation </td></tr>
    <tr><td class="paramname">bypass</td><td>forces the result to be TRUE, evne if validation failed </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>BOOL TRUE if validation was successful and data was added, FALSE otherwise </dd></dl>

</div>
</div>
<a id="ac72a5ce7a47cbed0cadf76bd0d578b65"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac72a5ce7a47cbed0cadf76bd0d578b65">&#9670;&nbsp;</a></span>secret_data_append_from_code()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BOOL secret_data_append_from_code </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>code_start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>code_end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="unionsecret__data__shift__cursor.html">secret_data_shift_cursor</a>&#160;</td>
          <td class="paramname"><em>shift_cursor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>shift_count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BOOL&#160;</td>
          <td class="paramname"><em>start_from_call</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Pushes secret data by validating the given code block. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">code_start</td><td>pointer to the beginning of code/function to analyze </td></tr>
    <tr><td class="paramname">code_end</td><td>pointer to the end of code/function to analyze </td></tr>
    <tr><td class="paramname">shift_cursor</td><td>shift index </td></tr>
    <tr><td class="paramname">shift_count</td><td>how many '1' bits to shift </td></tr>
    <tr><td class="paramname">start_from_call</td><td>TRUE if analysis should begin from the first CALL instruction FALSE to start from the first instruction </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>BOOL TRUE if all requested shifts were all executed. FALSE if some shift wasn't executed due to code validation failure. </dd></dl>

</div>
</div>
<a id="aaa0db3f61956e32ad25cfaa21122661e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaa0db3f61956e32ad25cfaa21122661e">&#9670;&nbsp;</a></span>secret_data_append_if_flags()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BOOL secret_data_append_if_flags </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="unionsecret__data__shift__cursor.html">secret_data_shift_cursor</a>&#160;</td>
          <td class="paramname"><em>shift_cursor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>operation_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>shift_count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8 *&#160;</td>
          <td class="paramname"><em>code</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calls <a class="el" href="xzre_8h.html#aa571c1c4c376e99b6e4306cf6d9d5f18">secret_data_append_singleton</a>, if <code>flags</code> are non-zero. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">shift_cursor</td><td>the initial shift index </td></tr>
    <tr><td class="paramname">operation_index</td><td>identification for this shift operation </td></tr>
    <tr><td class="paramname">shift_count</td><td>how many '1' bits to shift </td></tr>
    <tr><td class="paramname">flags</td><td>must be non-zero in order for the operation to be executed </td></tr>
    <tr><td class="paramname">code</td><td>pointer to code that will be checked by the function, to "authorize" the data load </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>BOOL TRUE if validation was successful and data was added, FALSE otherwise </dd></dl>

</div>
</div>
<a id="aa571c1c4c376e99b6e4306cf6d9d5f18"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa571c1c4c376e99b6e4306cf6d9d5f18">&#9670;&nbsp;</a></span>secret_data_append_singleton()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BOOL secret_data_append_singleton </td>
          <td>(</td>
          <td class="paramtype">u8 *&#160;</td>
          <td class="paramname"><em>call_site</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8 *&#160;</td>
          <td class="paramname"><em>code</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="unionsecret__data__shift__cursor.html">secret_data_shift_cursor</a>&#160;</td>
          <td class="paramname"><em>shift_cursor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>shift_count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>operation_index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Shifts data in the secret data store, after validation of <code>code</code>. this function is intended to be invoked only once for each <code>operation_index</code> value. <code>operation_index</code> will be used as an index into a global array of flags, so that multiple calls with the same value will be a NO-OP. </p>
<p>the <code>code</code> will be verified to check if the shift operation should be allowed or not. the algorithm will:</p><ul>
<li>locate the beginning of the function, by scanning for the <code>endbr64</code> instruction and making sure that the code lies between a pre-defined code range (set in <a class="el" href="xzre_8h.html#a229ee0bd4111363061bc4230bc1f6423">backdoor_setup</a> from <a class="el" href="xzre_8h.html#a18845fc4614f60083817db417dc32a13">elf_get_code_segment</a>)</li>
<li>search for <code>shift_count</code> number of "reg2reg" instructions (explained below)</li>
<li>for each instruction, shift a '1' in the data register, and increment the shift cursor to the next bit index the code only considers reg2reg instruction. other instructions are skipped. the function will return TRUE if the number of shifts executed == number of wanted shifts (that is, if there are as many compatible reg2reg instructions as the number of requested shifts) NOTE: MOV instructions are counted, but don't cause any shift (they are skipped).</li>
</ul>
<p>a reg2reg instruction is an x64 instruction with one of the following characteristics:</p><ul>
<li>primary opcode of 0x89 (MOV) or 0x3B (CMP) or, alternatively, an opcode that passes the following validation opcode_check = opcode - 0x83; if ( opcode_check &gt; 0x2E || ((0x410100000101 &gt;&gt; opcode_value) &amp; 1) == 0 )</li>
</ul>
<p>additionally, checks outlined in <a class="el" href="xzre_8h.html#aed0391d07e4413f5a13e1ec2940c94ea">find_reg2reg_instruction</a> must also pass NOTE: the opcode in 'opcode' is the actual opcode +0x80 TODO: inspect x64 manual to find the exact filter</p>
<p>if <code>call_site</code> is supplied, a preliminary check will be conducted to see if the caller function contains a CALL-relative instruction. several functions have a CALL in the prologue which serves a dual purpose:</p><ul>
<li>push more data in the secret data store</li>
<li>check if the call is authorized (the code is in the authorized range, and starts with a CALL-relative instruction)</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">call_site</td><td>if supplied, it will be checked if it contains a valid CALL-relative instruction </td></tr>
    <tr><td class="paramname">code</td><td>pointer to code that will be checked by the function, to "authorize" the data load </td></tr>
    <tr><td class="paramname">shift_cursor</td><td>the initial shift index </td></tr>
    <tr><td class="paramname">shift_count</td><td>number of '1' bits to shift, represented by the number of"reg2reg" instructions expected in the function pointed to by <code>code</code> </td></tr>
    <tr><td class="paramname">operation_index</td><td>index/id of shit shift operation </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>BOOL TRUE if all requested shifts were all executed. FALSE if some shift wasn't executed due to code validation failure. </dd></dl>

</div>
</div>
<a id="a80592f231ad06e5a8ba204e6ff685827"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a80592f231ad06e5a8ba204e6ff685827">&#9670;&nbsp;</a></span>secret_data_get_decrypted()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BOOL secret_data_get_decrypted </td>
          <td>(</td>
          <td class="paramtype">u8 *&#160;</td>
          <td class="paramname"><em>output</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structglobal__context__t.html">global_context_t</a> *&#160;</td>
          <td class="paramname"><em>ctx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>obtains a decrypted copy of the secret data </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">output</td><td>output buffer that will receive the decrypted data </td></tr>
    <tr><td class="paramname">ctx</td><td>the global context (for secret data and function imports) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>BOOL TRUE if successful, FALSE otherwise </dd></dl>

</div>
</div>
<a id="a52d510f0bbb31de19d8d20bf1acaeb5f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a52d510f0bbb31de19d8d20bf1acaeb5f">&#9670;&nbsp;</a></span>x86_dasm()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int x86_dasm </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdasm__ctx__t.html">dasm_ctx_t</a> *&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8 *&#160;</td>
          <td class="paramname"><em>code_start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8 *&#160;</td>
          <td class="paramname"><em>code_end</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>disassembles the given x64 code </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctx</td><td>empty disassembler context to hold the state </td></tr>
    <tr><td class="paramname">code_start</td><td>pointer to the start of buffer (first disassemblable location) </td></tr>
    <tr><td class="paramname">code_end</td><td>pointer to the end of the buffer </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>int TRUE if disassembly was successful, FALSE otherwise </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
